\hypertarget{ContextualEquivalence}{%
\chapter{ContextualEquivalence: Denotational equality implies contextual
equivalence}\label{ContextualEquivalence}}

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{plfa.part3.ContextualEquivalence}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\end{code}
\end{fence}

\hypertarget{imports}{%
\section{Imports}\label{imports}}

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{open}%
\>[2I]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}×\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaRecord{Σ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{Σ-syntax}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{∃}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{∃-syntax}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{proj₁}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{proj₂}\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[2I]%
\>[5]\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨\AgdaUnderscore{},\AgdaUnderscore{}⟩}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{plfa.part2.Untyped}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}⊢\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{ƛ\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}—↠\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{plfa.part2.BigStep}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}⊢\AgdaUnderscore{}⇓\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{cbn→reduce}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{plfa.part3.Denotational}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ℰ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≃\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{≃-sym}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{≃-trans}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}iff\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{plfa.part3.Compositional}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{Ctx}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{plug}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{compositionality}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{plfa.part3.Soundness}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{soundness}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{plfa.part3.Adequacy}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{↓→⇓}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

\hypertarget{contextual-equivalence}{%
\section{Contextual Equivalence}\label{contextual-equivalence}}

The notion of \emph{contextual equivalence} is an important one for
programming languages because it is the sufficient condition for
changing a subterm of a program while maintaining the program's overall
behavior. Two terms \texttt{M} and \texttt{N} are contextually
equivalent if they can plugged into any context \texttt{C} and produce
equivalent results. As discuss in the Denotational chapter, the result
of a program in the lambda calculus is to terminate or not. We
characterize termination with the reduction semantics as follows.

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{terminates}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{M}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaFunction{terminates}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{—↠}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{ƛ}}\AgdaSpace{}%
\AgdaBound{N}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

So two terms are contextually equivalent if plugging them into the same
context produces two programs that either terminate or diverge together.

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≅\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{M}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≅\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaBound{N}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[92I]\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{C}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Ctx}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[92I]%
\>[16]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{terminates}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{plug}\AgdaSpace{}%
\AgdaBound{C}\AgdaSpace{}%
\AgdaBound{M}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{iff}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{terminates}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{plug}\AgdaSpace{}%
\AgdaBound{C}\AgdaSpace{}%
\AgdaBound{N}\AgdaSymbol{))}\<%
\end{code}
\end{fence}

The contextual equivalence of two terms is difficult to prove directly
based on the above definition because of the universal quantification of
the context \texttt{C}. One of the main motivations for developing
denotational semantics is to have an alternative way to prove contextual
equivalence that instead only requires reasoning about the two terms.

\hypertarget{denotational-equivalence-implies-contextual-equivalence}{%
\section{Denotational equivalence implies contextual
equivalence}\label{denotational-equivalence-implies-contextual-equivalence}}

Thankfully, the proof that denotational equality implies contextual
equivalence is an easy corollary of the results that we have already
established. Furthermore, the two directions of the if-and-only-if are
symmetric, so we can prove one lemma and then use it twice in the
theorem.

The lemma states that if \texttt{M} and \texttt{N} are denotationally
equal and if \texttt{M} plugged into \texttt{C} terminates, then so does
\texttt{N} plugged into \texttt{C}.

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{denot-equal-terminates}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{M}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{C}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Ctx}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}%
\>[120I]\AgdaFunction{ℰ}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≃}}\AgdaSpace{}%
\AgdaFunction{ℰ}\AgdaSpace{}%
\AgdaBound{N}%
\>[15]\AgdaSymbol{→}%
\>[18]\AgdaFunction{terminates}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{plug}\AgdaSpace{}%
\AgdaBound{C}\AgdaSpace{}%
\AgdaBound{M}\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[120I]%
\>[4]\AgdaComment{-----------------------------------}\<%
\\
%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{terminates}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{plug}\AgdaSpace{}%
\AgdaBound{C}\AgdaSpace{}%
\AgdaBound{N}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{denot-equal-terminates}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSymbol{\}\{}\AgdaBound{M}\AgdaSymbol{\}\{}\AgdaBound{N}\AgdaSymbol{\}\{}\AgdaBound{C}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{ℰM≃ℰN}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{N′}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{CM—↠ƛN′}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{let}\AgdaSpace{}%
\AgdaBound{ℰCM≃ℰƛN′}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{soundness}\AgdaSpace{}%
\AgdaBound{CM—↠ƛN′}\AgdaSpace{}%
\AgdaKeyword{in}\<%
\\
%
\>[2]\AgdaKeyword{let}\AgdaSpace{}%
\AgdaBound{ℰCM≃ℰCN}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{compositionality}\AgdaSymbol{\{}\AgdaArgument{Γ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSymbol{\}\{}\AgdaArgument{Δ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSymbol{\}\{}\AgdaArgument{C}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{C}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{ℰM≃ℰN}\AgdaSpace{}%
\AgdaKeyword{in}\<%
\\
%
\>[2]\AgdaKeyword{let}\AgdaSpace{}%
\AgdaBound{ℰCN≃ℰƛN′}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{≃-trans}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{≃-sym}\AgdaSpace{}%
\AgdaBound{ℰCM≃ℰCN}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ℰCM≃ℰƛN′}\AgdaSpace{}%
\AgdaKeyword{in}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{cbn→reduce}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{proj₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{proj₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{proj₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{↓→⇓}\AgdaSpace{}%
\AgdaBound{ℰCN≃ℰƛN′}\AgdaSymbol{))))}\<%
\end{code}
\end{fence}

The proof is direct. Because \texttt{plug\ C\ —↠\ plug\ C\ (ƛN′)}, we
can apply soundness to obtain

\begin{myDisplay}
ℰ (plug C M) ≃ ℰ (ƛN′)
\end{myDisplay}

From \texttt{ℰ\ M\ ≃\ ℰ\ N}, compositionality gives us

\begin{myDisplay}
ℰ (plug C M) ≃ ℰ (plug C N).
\end{myDisplay}

Putting these two facts together gives us

\begin{myDisplay}
ℰ (plug C N) ≃ ℰ (ƛN′).
\end{myDisplay}

We then apply \texttt{↓→⇓} from Chapter
\protect\hyperlink{Adequacy}{Adequacy} to deduce

\begin{myDisplay}
∅' ⊢ plug C N ⇓ clos (ƛ N′′) δ).
\end{myDisplay}

Call-by-name evaluation implies reduction to a lambda abstraction, so we
conclude that

\begin{myDisplay}
terminates (plug C N).
\end{myDisplay}

The main theorem follows by two applications of the lemma.

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{denot-equal-contex-equal}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{M}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}%
\>[176I]\AgdaFunction{ℰ}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≃}}\AgdaSpace{}%
\AgdaFunction{ℰ}\AgdaSpace{}%
\AgdaBound{N}\<%
\\
\>[.][@{}l@{}]\<[176I]%
\>[4]\AgdaComment{---------}\<%
\\
%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≅}}\AgdaSpace{}%
\AgdaBound{N}\<%
\\
\>[0]\AgdaFunction{denot-equal-contex-equal}\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSymbol{\}\{}\AgdaBound{M}\AgdaSymbol{\}\{}\AgdaBound{N}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{eq}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{C}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[3]\AgdaOperator{\AgdaInductiveConstructor{⟨}}%
\>[187I]\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{tm}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{denot-equal-terminates}\AgdaSpace{}%
\AgdaBound{eq}\AgdaSpace{}%
\AgdaBound{tm}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\<%
\\
\>[.][@{}l@{}]\<[187I]%
\>[5]\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{tn}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{denot-equal-terminates}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{≃-sym}\AgdaSpace{}%
\AgdaBound{eq}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{tn}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\<%
\end{code}
\end{fence}

\hypertarget{unicode}{%
\section{Unicode}\label{unicode}}

This chapter uses the following unicode:

\begin{myDisplay}
≅  U+2245  APPROXIMATELY EQUAL TO (\~= or \cong)
\end{myDisplay}

