\hypertarget{Inference}{%
\chapter{Inference: Bidirectional type inference}\label{Inference}}

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{plfa.part2.Inference}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\end{code}
\end{fence}

So far in our development, type derivations for the corresponding term
have been provided by fiat. In Chapter
\protect\hyperlink{Lambda}{Lambda} type derivations are extrinsic to the
term, while in Chapter \protect\hyperlink{DeBruijn}{DeBruijn} type
derivations are intrinsic to the term, but in both we have written out
the type derivations in full.

In practice, one often writes down a term with a few decorations and
applies an algorithm to \emph{infer} the corresponding type derivation.
Indeed, this is exactly what happens in Agda: we specify the types for
top-level function declarations, and type information for everything
else is inferred from what has been given. The style of inference Agda
uses is based on a technique called \emph{bidirectional} type inference,
which will be presented in this chapter.

This chapter ties our previous developments together. We begin with a
term with some type annotations, close to the raw terms of Chapter
\protect\hyperlink{Lambda}{Lambda}, and from it we compute an
intrinsically-typed term, in the style of Chapter
\protect\hyperlink{DeBruijn}{DeBruijn}.

\hypertarget{Inference-algorithms}{%
\section{Introduction: Inference rules as
algorithms}\label{Inference-algorithms}}

In the calculus we have considered so far, a term may have more than one
type. For example,

\begin{myDisplay}
(ƛ x ⇒ x) ⦂ (A ⇒ A)
\end{myDisplay}

holds for \emph{every} type \texttt{A}. We start by considering a small
language for lambda terms where every term has a unique type. All we
need do is decorate each abstraction term with the type of its argument.
This gives us the grammar:

\begin{myDisplay}
L, M, N ::=                         decorated terms
  x                                   variable
  ƛ x ⦂ A ⇒ N                         abstraction (decorated)
  L · M                               application
\end{myDisplay}

Each of the associated type rules can be read as an algorithm for type
checking. For each typing judgment, we label each position as either an
\emph{input} or an \emph{output}.

For the judgment

\begin{myDisplay}
Γ ∋ x ⦂ A
\end{myDisplay}

we take the context \texttt{Γ} and the variable \texttt{x} as inputs,
and the type \texttt{A} as output. Consider the rules:

\begin{myDisplay}
----------------- Z
Γ , x ⦂ A ∋ x ⦂ A

Γ ∋ x ⦂ A
----------------- S
Γ , y ⦂ B ∋ x ⦂ A
\end{myDisplay}

From the inputs we can determine which rule applies: if the last
variable in the context matches the given variable then the first rule
applies, else the second. (For de Bruijn indices, it is even easier:
zero matches the first rule and successor the second.) For the first
rule, the output type can be read off as the last type in the input
context. For the second rule, the inputs of the conclusion determine the
inputs of the hypothesis, and the output of the hypothesis determines
the output of the conclusion.

For the judgment

\begin{myDisplay}
Γ ⊢ M ⦂ A
\end{myDisplay}

we take the context \texttt{Γ} and term \texttt{M} as inputs, and the
type \texttt{A} as output. Consider the rules:

\begin{myDisplay}
Γ ∋ x ⦂ A
-----------
Γ ⊢ ` x ⦂ A

Γ , x ⦂ A ⊢ N ⦂ B
---------------------------
Γ ⊢ (ƛ x ⦂ A ⇒ N) ⦂ (A ⇒ B)

Γ ⊢ L ⦂ A ⇒ B
Γ ⊢ M ⦂ A′
A ≡ A′
-------------
Γ ⊢ L · M ⦂ B
\end{myDisplay}

The input term determines which rule applies: variables use the first
rule, abstractions the second, and applications the third. We say such
rules are \emph{syntax directed}. For the variable rule, the inputs of
the conclusion determine the inputs of the hypothesis, and the output of
the hypothesis determines the output of the conclusion. Same for the
abstraction rule --- the bound variable and argument are carried from
the term of the conclusion into the context of the hypothesis; this
works because we added the argument type to the abstraction. For the
application rule, we add a third hypothesis to check whether the domain
of the function matches the type of the argument; this judgment is
decidable when both types are given as inputs. The inputs of the
conclusion determine the inputs of the first two hypotheses, the outputs
of the first two hypotheses determine the inputs of the third
hypothesis, and the output of the first hypothesis determines the output
of the conclusion.

Converting the above to an algorithm is straightforward, as is adding
naturals and fixpoint. We omit the details. Instead, we consider a
detailed description of an approach that requires less obtrusive
decoration. The idea is to break the normal typing judgment into two
judgments, one that produces the type as an output (as above), and
another that takes it as an input.

\hypertarget{synthesising-and-inheriting-types}{%
\section{Synthesising and inheriting
types}\label{synthesising-and-inheriting-types}}

In addition to the lookup judgment for variables, which will remain as
before, we now have two judgments for the type of the term:

\begin{myDisplay}
Γ ⊢ M ↑ A
Γ ⊢ M ↓ A
\end{myDisplay}

The first of these \emph{synthesises} the type of a term, as before,
while the second \emph{inherits} the type. In the first, the context and
term are inputs and the type is an output; while in the second, all
three of the context, term, and type are inputs.

Which terms use synthesis and which inheritance? Our approach will be
that the main term in a \emph{deconstructor} is typed via synthesis
while \emph{constructors} are typed via inheritance. For instance, the
function in an application is typed via synthesis, but an abstraction is
typed via inheritance. The inherited type in an abstraction term serves
the same purpose as the argument type decoration of the previous
section.

Terms that deconstruct a value of a type always have a main term
(supplying an argument of the required type) and often have side-terms.
For application, the main term supplies the function and the side term
supplies the argument. For case terms, the main term supplies a natural
and the side terms are the two branches. In a deconstructor, the main
term will be typed using synthesis but the side terms will be typed
using inheritance. As we will see, this leads naturally to an
application as a whole being typed by synthesis, while a case term as a
whole will be typed by inheritance. Variables are naturally typed by
synthesis, since we can look up the type in the input context. Fixed
points will be naturally typed by inheritance.

In order to get a syntax-directed type system we break terms into two
kinds, \texttt{Term⁺} and \texttt{Term⁻}, which are typed by synthesis
and inheritance, respectively. A subterm that is typed by synthesis may
appear in a context where it is typed by inheritance, or vice-versa, and
this gives rise to two new term forms.

For instance, we said above that the argument of an application is typed
by inheritance and that variables are typed by synthesis, giving a
mismatch if the argument of an application is a variable. Hence, we need
a way to treat a synthesized term as if it is inherited. We introduce a
new term form, \texttt{M\ ↑} for this purpose. The typing judgment
checks that the inherited and synthesised types match.

Similarly, we said above that the function of an application is typed by
synthesis and that abstractions are typed by inheritance, giving a
mismatch if the function of an application is an abstraction. Hence, we
need a way to treat an inherited term as if it is synthesised. We
introduce a new term form \texttt{M\ ↓\ A} for this purpose. The typing
judgment returns \texttt{A} as the synthesized type of the term as a
whole, as well as using it as the inherited type for \texttt{M}.

The term form \texttt{M\ ↓\ A} represents the only place terms need to
be decorated with types. It only appears when switching from synthesis
to inheritance, that is, when a term that \emph{deconstructs} a value of
a type contains as its main term a term that \emph{constructs} a value
of a type, in other words, a place where a \texttt{β}-reduction will
occur. Typically, we will find that decorations are only required on top
level declarations.

We can extract the grammar for terms from the above:

\begin{myDisplay}
L⁺, M⁺, N⁺ ::=                      terms with synthesized type
  x                                   variable
  L⁺ · M⁻                             application
  M⁻ ↓ A                              switch to inherited

L⁻, M⁻, N⁻ ::=                      terms with inherited type
  ƛ x ⇒ N⁻                            abstraction
  `zero                               zero
  `suc M⁻                             successor
  case L⁺ [zero⇒ M⁻ |suc x ⇒ N⁻ ]     case
  μ x ⇒ N⁻                            fixpoint
  M⁺ ↑                                switch to synthesized
\end{myDisplay}

We will formalise the above shortly.

\hypertarget{soundness-and-completeness}{%
\section{Soundness and completeness}\label{soundness-and-completeness}}

What we intend to show is that the typing judgments are
\emph{decidable}:

\begin{myDisplay}
synthesize : ∀ (Γ : Context) (M : Term⁺)
    -----------------------
  → Dec (∃[ A ](Γ ⊢ M ↑ A))

inherit : ∀ (Γ : Context) (M : Term⁻) (A : Type)
    ---------------
  → Dec (Γ ⊢ M ↓ A)
\end{myDisplay}

Given context \texttt{Γ} and synthesised term \texttt{M}, we must decide
whether there exists a type \texttt{A} such that \texttt{Γ\ ⊢\ M\ ↑\ A}
holds, or its negation. Similarly, given context \texttt{Γ}, inherited
term \texttt{M}, and type \texttt{A}, we must decide whether
\texttt{Γ\ ⊢\ M\ ↓\ A} holds, or its negation.

Our proof is constructive. In the synthesised case, it will either
deliver a pair of a type \texttt{A} and evidence that
\texttt{Γ\ ⊢\ M\ ↓\ A}, or a function that given such a pair produces
evidence of a contradiction. In the inherited case, it will either
deliver evidence that \texttt{Γ\ ⊢\ M\ ↑\ A}, or a function that given
such evidence produces evidence of a contradiction. The positive case is
referred to as \emph{soundness} --- synthesis and inheritance succeed
only if the corresponding relation holds. The negative case is referred
to as \emph{completeness} --- synthesis and inheritance fail only when
they cannot possibly succeed.

Another approach might be to return a derivation if synthesis or
inheritance succeeds, and an error message otherwise --- for instance,
see the section of the Agda user manual discussing
\href{https://agda.readthedocs.io/en/latest/language/syntactic-sugar.html\#example}{syntactic
sugar}. Such an approach demonstrates soundness, but not completeness.
If it returns a derivation, we know it is correct; but there is nothing
to prevent us from writing a function that \emph{always} returns an
error, even when there exists a correct derivation. Demonstrating both
soundness and completeness is significantly stronger than demonstrating
soundness alone. The negative proof can be thought of as a semantically
verified error message, although in practice it may be less readable
than a well-crafted error message.

We are now ready to begin the formal development.

\hypertarget{imports}{%
\section{Imports}\label{imports}}

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary.PropositionalEquality}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Eq}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Eq}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{trans}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{cong₂}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≢\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Empty}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{⊥}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{⊥-elim}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{ℕ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.String}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{String}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≟\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}×\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{∃}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{∃-syntax}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨\AgdaUnderscore{},\AgdaUnderscore{}⟩}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{¬\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

Once we have a type derivation, it will be easy to construct from it the
intrinsically-typed representation. In order that we can compare with
our previous development, we import module \texttt{plfa.part2.More}:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{plfa.part2.More}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{DB}\<%
\end{code}
\end{fence}

The phrase \texttt{as\ DB} allows us to refer to definitions from that
module as, for instance, \texttt{DB.\_⊢\_}, which is invoked as
\texttt{Γ\ DB.⊢\ A}, where \texttt{Γ} has type \texttt{DB.Context} and
\texttt{A} has type \texttt{DB.Type}.

\hypertarget{syntax}{%
\section{Syntax}\label{syntax}}

First, we get all our infix declarations out of the way. We list
separately operators for judgments and terms:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{infix}%
\>[8]\AgdaNumber{4}%
\>[11]\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}∋\AgdaUnderscore{}⦂\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaKeyword{infix}%
\>[8]\AgdaNumber{4}%
\>[11]\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}⊢\AgdaUnderscore{}↑\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaKeyword{infix}%
\>[8]\AgdaNumber{4}%
\>[11]\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}⊢\AgdaUnderscore{}↓\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaKeyword{infixl}%
\>[8]\AgdaNumber{5}%
\>[11]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}⦂\AgdaUnderscore{}}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{infixr}%
\>[8]\AgdaNumber{7}%
\>[11]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⇒\AgdaUnderscore{}}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{infix}%
\>[8]\AgdaNumber{5}%
\>[11]\AgdaOperator{\AgdaInductiveConstructor{ƛ\AgdaUnderscore{}⇒\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaKeyword{infix}%
\>[8]\AgdaNumber{5}%
\>[11]\AgdaOperator{\AgdaInductiveConstructor{μ\AgdaUnderscore{}⇒\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaKeyword{infix}%
\>[8]\AgdaNumber{6}%
\>[11]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}↑}}\<%
\\
\>[0]\AgdaKeyword{infix}%
\>[8]\AgdaNumber{6}%
\>[11]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}↓\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaKeyword{infixl}%
\>[8]\AgdaNumber{7}%
\>[11]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}·\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaKeyword{infix}%
\>[8]\AgdaNumber{8}%
\>[11]\AgdaOperator{\AgdaInductiveConstructor{`suc\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaKeyword{infix}%
\>[8]\AgdaNumber{9}%
\>[11]\AgdaOperator{\AgdaInductiveConstructor{`\AgdaUnderscore{}}}\<%
\end{code}
\end{fence}

Identifiers, types, and contexts are as before:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{Id}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaFunction{Id}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{String}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{`ℕ}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⇒\AgdaUnderscore{}}}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Context}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{∅}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Context}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}⦂\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Context}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Id}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Context}\<%
\end{code}
\end{fence}

The syntax of terms is defined by mutual recursion. We use
\texttt{Term⁺} and \texttt{Term⁻} for terms with synthesized and
inherited types, respectively. Note the inclusion of the switching
forms, \texttt{M\ ↓\ A} and \texttt{M\ ↑}:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Term⁺}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Term⁺}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{`\AgdaUnderscore{}}}%
\>[28]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Id}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Term⁺}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}·\AgdaUnderscore{}}}%
\>[28]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Term⁺}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Term⁺}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}↓\AgdaUnderscore{}}}%
\>[28]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Term⁺}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{ƛ\AgdaUnderscore{}⇒\AgdaUnderscore{}}}%
\>[27]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Id}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\<%
\\
%
\>[2]\AgdaInductiveConstructor{`zero}%
\>[27]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{`suc\AgdaUnderscore{}}}%
\>[27]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{`case\AgdaUnderscore{}[zero⇒\AgdaUnderscore{}|suc\AgdaUnderscore{}⇒\AgdaUnderscore{}]}}%
\>[27]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Term⁺}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Id}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{μ\AgdaUnderscore{}⇒\AgdaUnderscore{}}}%
\>[27]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Id}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}↑}}%
\>[27]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Term⁺}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\<%
\end{code}
\end{fence}

The choice as to whether each term is synthesized or inherited follows
the discussion above, and can be read off from the informal grammar
presented earlier. Main terms in deconstructors synthesise, constructors
and side terms in deconstructors inherit.

\hypertarget{example-terms}{%
\section{Example terms}\label{example-terms}}

We can recreate the examples from preceding chapters. First, computing
two plus two on naturals:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{two}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\<%
\\
\>[0]\AgdaFunction{two}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`suc}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`suc}}\AgdaSpace{}%
\AgdaInductiveConstructor{`zero}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{plus}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Term⁺}\<%
\\
\>[0]\AgdaFunction{plus}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{μ}}%
\>[138I]\AgdaString{"p"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{ƛ}}\AgdaSpace{}%
\AgdaString{"m"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{ƛ}}\AgdaSpace{}%
\AgdaString{"n"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\<%
\\
\>[.][@{}l@{}]\<[138I]%
\>[10]\AgdaOperator{\AgdaInductiveConstructor{`case}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"m"}\AgdaSymbol{)}%
\>[148I]\AgdaOperator{\AgdaInductiveConstructor{[zero⇒}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"n"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\<%
\\
\>[.][@{}l@{}]\<[148I]%
\>[24]\AgdaOperator{\AgdaInductiveConstructor{|suc}}\AgdaSpace{}%
\AgdaString{"m"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`suc}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"p"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"m"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"n"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\<%
\\
\>[10][@{}l@{\AgdaIndent{0}}]%
\>[12]\AgdaOperator{\AgdaInductiveConstructor{↓}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{2+2}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Term⁺}\<%
\\
\>[0]\AgdaFunction{2+2}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{plus}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{two}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{two}\<%
\end{code}
\end{fence}

The only change is to decorate with down and up arrows as required. The
only type decoration required is for \texttt{plus}.

Next, computing two plus two with Church numerals:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{Ch}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\<%
\\
\>[0]\AgdaFunction{Ch}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{twoᶜ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\<%
\\
\>[0]\AgdaFunction{twoᶜ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{ƛ}}\AgdaSpace{}%
\AgdaString{"s"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{ƛ}}\AgdaSpace{}%
\AgdaString{"z"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"s"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"s"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"z"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{plusᶜ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Term⁺}\<%
\\
\>[0]\AgdaFunction{plusᶜ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{ƛ}}%
\>[214I]\AgdaString{"m"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{ƛ}}\AgdaSpace{}%
\AgdaString{"n"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{ƛ}}\AgdaSpace{}%
\AgdaString{"s"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{ƛ}}\AgdaSpace{}%
\AgdaString{"z"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\<%
\\
\>[.][@{}l@{}]\<[214I]%
\>[11]\AgdaOperator{\AgdaInductiveConstructor{`}}%
\>[225I]\AgdaString{"m"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"s"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"n"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"s"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"z"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[225I]%
\>[13]\AgdaOperator{\AgdaInductiveConstructor{↓}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Ch}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaFunction{Ch}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaFunction{Ch}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{sucᶜ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\<%
\\
\>[0]\AgdaFunction{sucᶜ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{ƛ}}\AgdaSpace{}%
\AgdaString{"x"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`suc}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"x"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{2+2ᶜ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Term⁺}\<%
\\
\>[0]\AgdaFunction{2+2ᶜ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{plusᶜ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{twoᶜ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{twoᶜ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{sucᶜ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaInductiveConstructor{`zero}\<%
\end{code}
\end{fence}

The only type decoration required is for \texttt{plusᶜ}. One is not even
required for \texttt{sucᶜ}, which inherits its type as an argument of
\texttt{plusᶜ}.

\hypertarget{bidirectional-type-checking}{%
\section{Bidirectional type
checking}\label{bidirectional-type-checking}}

The typing rules for variables are as in
\protect\hyperlink{Lambda}{Lambda}:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}∋\AgdaUnderscore{}⦂\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Context}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Id}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{Z}%
\>[280I]\AgdaSymbol{:}%
\>[281I]\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[281I]%
\>[6]\AgdaComment{--------------------}\<%
\\
\>[.][@{}l@{}]\<[280I]%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⦂}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{∋}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⦂}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{S}%
\>[294I]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[294I]%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≢}}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
%
\>[4]\AgdaSymbol{→}%
\>[304I]\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{∋}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⦂}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[.][@{}l@{}]\<[304I]%
\>[6]\AgdaComment{-----------------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⦂}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{∋}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⦂}}\AgdaSpace{}%
\AgdaBound{A}\<%
\end{code}
\end{fence}

As with syntax, the judgments for synthesizing and inheriting types are
mutually recursive:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}⊢\AgdaUnderscore{}↑\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Context}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Term⁺}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}⊢\AgdaUnderscore{}↓\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Context}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}⊢\AgdaUnderscore{}↑\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}%
\>[343I]\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{∋}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⦂}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[.][@{}l@{}]\<[343I]%
\>[6]\AgdaComment{-----------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↑}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}·\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{L}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{L}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↑}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
%
\>[4]\AgdaSymbol{→}%
\>[368I]\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[.][@{}l@{}]\<[368I]%
\>[6]\AgdaComment{-------------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↑}}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{⊢↓}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}%
\>[385I]\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[.][@{}l@{}]\<[385I]%
\>[6]\AgdaComment{---------------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↓}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↑}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}⊢\AgdaUnderscore{}↓\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{⊢ƛ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}%
\>[406I]\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⦂}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
\>[.][@{}l@{}]\<[406I]%
\>[6]\AgdaComment{-------------------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{ƛ}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{⊢zero}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaComment{--------------}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaInductiveConstructor{`zero}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{⊢suc}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{M}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}%
\>[437I]\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\<%
\\
\>[.][@{}l@{}]\<[437I]%
\>[6]\AgdaComment{---------------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`suc}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{⊢case}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{L}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{L}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↑}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\>[4]\AgdaSymbol{→}%
\>[466I]\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⦂}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[.][@{}l@{}]\<[466I]%
\>[6]\AgdaComment{-------------------------------------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`case}}\AgdaSpace{}%
\AgdaBound{L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[zero⇒}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{|suc}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{⊢μ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}%
\>[494I]\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⦂}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[.][@{}l@{}]\<[494I]%
\>[6]\AgdaComment{-----------------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{μ}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↑}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\>[4]\AgdaSymbol{→}%
\>[522I]\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
\>[.][@{}l@{}]\<[522I]%
\>[6]\AgdaComment{-------------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaBound{B}\<%
\end{code}
\end{fence}

We follow the same convention as Chapter
\protect\hyperlink{Lambda}{Lambda}, prefacing the constructor with
\texttt{⊢} to derive the name of the corresponding type rule.

The rules are similar to those in Chapter
\protect\hyperlink{Lambda}{Lambda}, modified to support synthesised and
inherited types. The two new rules are those for \texttt{⊢↓} and
\texttt{⊢↑}. The former both passes the type decoration as the inherited
type and returns it as the synthesised type. The latter takes the
synthesised type and the inherited type and confirms they are identical
--- it should remind you of the equality test in the application rule in
the first \protect\hyperlink{Inference-algorithms}{section}.

\hypertarget{Inference-bidirectional-mul}{%
\subsubsection{\texorpdfstring{Exercise \texttt{bidirectional-mul}
(recommended)}{Exercise bidirectional-mul (recommended)}}\label{Inference-bidirectional-mul}}

Rewrite your definition of multiplication from Chapter
\protect\hyperlink{Lambda}{Lambda}, decorated to support inference.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{Inference-bidirectional-products}{%
\subsubsection{\texorpdfstring{Exercise \texttt{bidirectional-products}
(recommended)}{Exercise bidirectional-products (recommended)}}\label{Inference-bidirectional-products}}

Extend the bidirectional type rules to include products from Chapter
\protect\hyperlink{More}{More}.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-bidirectional-rest-stretch}{%
\subsubsection{\texorpdfstring{Exercise \texttt{bidirectional-rest}
(stretch)}{Exercise bidirectional-rest (stretch)}}\label{exercise-bidirectional-rest-stretch}}

Extend the bidirectional type rules to include the rest of the
constructs from Chapter \protect\hyperlink{More}{More}.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{prerequisites}{%
\section{Prerequisites}\label{prerequisites}}

The rule for \texttt{M\ ↑} requires the ability to decide whether two
types are equal. It is straightforward to code:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≟Tp\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaInductiveConstructor{`ℕ}%
\>[8]\AgdaOperator{\AgdaFunction{≟Tp}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaInductiveConstructor{`ℕ}%
\>[8]\AgdaOperator{\AgdaFunction{≟Tp}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ()}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≟Tp}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ()}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≟Tp}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A′}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B′}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{with}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≟Tp}}\AgdaSpace{}%
\AgdaBound{A′}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≟Tp}}\AgdaSpace{}%
\AgdaBound{B′}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[5]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{A≢}%
\>[16]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ\{}\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A≢}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[5]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[16]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{B≢}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ\{}\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B≢}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[5]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

We will also need a couple of obvious lemmas; the domain and range of
equal function types are equal:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{dom≡}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{A′}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{B′}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{A′}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B′}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{A′}\<%
\\
\>[0]\AgdaFunction{dom≡}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{rng≡}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{A′}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{B′}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{A′}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B′}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{B′}\<%
\\
\>[0]\AgdaFunction{rng≡}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

We will also need to know that the types \texttt{\textasciigrave{}ℕ} and
\texttt{A\ ⇒\ B} are not equal:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{ℕ≢⇒}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≢}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
\>[0]\AgdaFunction{ℕ≢⇒}\AgdaSpace{}%
\AgdaSymbol{()}\<%
\end{code}
\end{fence}

\hypertarget{unique-types}{%
\section{Unique types}\label{unique-types}}

Looking up a type in the context is unique. Given two derivations, one
showing \texttt{Γ\ ∋\ x\ ⦂\ A} and one showing \texttt{Γ\ ∋\ x\ ⦂\ B},
it follows that \texttt{A} and \texttt{B} must be identical:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{uniq-∋}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{∋}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⦂}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{∋}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⦂}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
\>[0]\AgdaFunction{uniq-∋}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}%
\>[27]\AgdaSymbol{=}%
\>[30]\AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaFunction{uniq-∋}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaBound{x≢y}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}%
\>[27]\AgdaSymbol{=}%
\>[30]\AgdaFunction{⊥-elim}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x≢y}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{uniq-∋}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaBound{x≢y}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}%
\>[27]\AgdaSymbol{=}%
\>[30]\AgdaFunction{⊥-elim}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x≢y}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{uniq-∋}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaBound{∋x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaBound{∋x′}\AgdaSymbol{)}%
\>[27]\AgdaSymbol{=}%
\>[30]\AgdaFunction{uniq-∋}\AgdaSpace{}%
\AgdaBound{∋x}\AgdaSpace{}%
\AgdaBound{∋x′}\<%
\end{code}
\end{fence}

If both derivations are by rule \texttt{Z} then uniqueness follows
immediately, while if both derivations are by rule \texttt{S} then
uniqueness follows by induction. It is a contradiction if one derivation
is by rule \texttt{Z} and one by rule \texttt{S}, since rule \texttt{Z}
requires the variable we are looking for is the final one in the
context, while rule \texttt{S} requires it is not.

Synthesizing a type is also unique. Given two derivations, one showing
\texttt{Γ\ ⊢\ M\ ↑\ A} and one showing \texttt{Γ\ ⊢\ M\ ↑\ B}, it
follows that \texttt{A} and \texttt{B} must be identical:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{uniq-↑}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↑}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↑}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
\>[0]\AgdaFunction{uniq-↑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaBound{∋x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaBound{∋x′}\AgdaSymbol{)}%
\>[30]\AgdaSymbol{=}%
\>[33]\AgdaFunction{uniq-∋}\AgdaSpace{}%
\AgdaBound{∋x}\AgdaSpace{}%
\AgdaBound{∋x′}\<%
\\
\>[0]\AgdaFunction{uniq-↑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{⊢L′}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{⊢M′}\AgdaSymbol{)}%
\>[30]\AgdaSymbol{=}%
\>[33]\AgdaFunction{rng≡}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{uniq-↑}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaBound{⊢L′}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{uniq-↑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢↓}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢↓}\AgdaSpace{}%
\AgdaBound{⊢M′}\AgdaSymbol{)}%
\>[30]\AgdaSymbol{=}%
\>[33]\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

There are three possibilities for the term. If it is a variable,
uniqueness of synthesis follows from uniqueness of lookup. If it is an
application, uniqueness follows by induction on the function in the
application, since the range of equal types are equal. If it is a switch
expression, uniqueness follows since both terms are decorated with the
same type.

\hypertarget{lookup-type-of-a-variable-in-the-context}{%
\section{Lookup type of a variable in the
context}\label{lookup-type-of-a-variable-in-the-context}}

Given \texttt{Γ} and two distinct variables \texttt{x} and \texttt{y},
if there is no type \texttt{A} such that \texttt{Γ\ ∋\ x\ ⦂\ A} holds,
then there is also no type \texttt{A} such that
\texttt{Γ\ ,\ y\ ⦂\ B\ ∋\ x\ ⦂\ A} holds:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{ext∋}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≢}}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
%
\>[2]\AgdaSymbol{→}%
\>[733I]\AgdaOperator{\AgdaFunction{¬}}\AgdaSpace{}%
\AgdaFunction{∃[}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSymbol{(}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{∋}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⦂}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[733I]%
\>[4]\AgdaComment{-----------------------------}\<%
\\
%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{¬}}\AgdaSpace{}%
\AgdaFunction{∃[}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSymbol{(}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⦂}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{∋}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⦂}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{ext∋}\AgdaSpace{}%
\AgdaBound{x≢y}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[12]\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaBound{x≢y}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaFunction{ext∋}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[9]\AgdaBound{¬∃}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaBound{∋x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaBound{¬∃}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{∋x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\<%
\end{code}
\end{fence}

Given a type \texttt{A} and evidence that
\texttt{Γ\ ,\ y\ ⦂\ B\ ∋\ x\ ⦂\ A} holds, we must demonstrate a
contradiction. If the judgment holds by \texttt{Z}, then we must have
that \texttt{x} and \texttt{y} are the same, which contradicts the first
assumption. If the judgment holds by \texttt{S\ \_\ ⊢x} then \texttt{⊢x}
provides evidence that \texttt{Γ\ ∋\ x\ ⦂\ A}, which contradicts the
second assumption.

Given a context \texttt{Γ} and a variable \texttt{x}, we decide whether
there exists a type \texttt{A} such that \texttt{Γ\ ∋\ x\ ⦂\ A} holds,
or its negation:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{lookup}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Context}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Id}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaComment{-----------------------}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{∃[}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{∋}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⦂}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{))}\<%
\\
\>[0]\AgdaFunction{lookup}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSpace{}%
\AgdaBound{x}%
\>[34]\AgdaSymbol{=}%
\>[37]\AgdaInductiveConstructor{no}%
\>[41]\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaSymbol{())}\<%
\\
\>[0]\AgdaFunction{lookup}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⦂}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≟}}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}%
\>[34]\AgdaSymbol{=}%
\>[37]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{x≢y}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{lookup}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[16]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}%
\>[22]\AgdaBound{¬∃}%
\>[34]\AgdaSymbol{=}%
\>[37]\AgdaInductiveConstructor{no}%
\>[41]\AgdaSymbol{(}\AgdaFunction{ext∋}\AgdaSpace{}%
\AgdaBound{x≢y}\AgdaSpace{}%
\AgdaBound{¬∃}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[16]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{∋x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}%
\>[34]\AgdaSymbol{=}%
\>[37]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaBound{x≢y}\AgdaSpace{}%
\AgdaBound{∋x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\<%
\end{code}
\end{fence}

Consider the context:

\begin{itemize}
\item
  If it is empty, then trivially there is no possible derivation.
\item
  If it is non-empty, compare the given variable to the most recent
  binding:

  \begin{itemize}
  \item
    If they are identical, we have succeeded, with \texttt{Z} as the
    appropriate derivation.
  \item
    If they differ, we recurse:

    \begin{itemize}
    \item
      If lookup fails, we apply \texttt{ext∋} to convert the proof there
      is no derivation from the contained context to the extended
      context.
    \item
      If lookup succeeds, we extend the derivation with \texttt{S}.
    \end{itemize}
  \end{itemize}
\end{itemize}

\hypertarget{promoting-negations}{%
\section{Promoting negations}\label{promoting-negations}}

For each possible term form, we need to show that if one of its
components fails to type, then the whole fails to type. Most of these
results are easy to demonstrate inline, but we provide auxiliary
functions for a couple of the trickier cases.

If \texttt{Γ\ ⊢\ L\ ↑\ A\ ⇒\ B} holds but \texttt{Γ\ ⊢\ M\ ↓\ A} does
not hold, then there is no term \texttt{B′} such that
\texttt{Γ\ ⊢\ L\ ·\ M\ ↑\ B′} holds:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{¬arg}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{L}\AgdaSpace{}%
\AgdaBound{M}\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{L}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↑}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
%
\>[2]\AgdaSymbol{→}%
\>[851I]\AgdaOperator{\AgdaFunction{¬}}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[.][@{}l@{}]\<[851I]%
\>[4]\AgdaComment{-------------------------}\<%
\\
%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{¬}}\AgdaSpace{}%
\AgdaFunction{∃[}\AgdaSpace{}%
\AgdaBound{B′}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↑}}\AgdaSpace{}%
\AgdaBound{B′}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{¬arg}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaBound{¬⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{B′}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{⊢L′}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{⊢M′}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\AgdaSpace{}%
\AgdaKeyword{rewrite}\AgdaSpace{}%
\AgdaFunction{dom≡}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{uniq-↑}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaBound{⊢L′}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{¬⊢M}\AgdaSpace{}%
\AgdaBound{⊢M′}\<%
\end{code}
\end{fence}

Let \texttt{⊢L} be evidence that \texttt{Γ\ ⊢\ L\ ↑\ A\ ⇒\ B} holds and
\texttt{¬⊢M} be evidence that \texttt{Γ\ ⊢\ M\ ↓\ A} does not hold.
Given a type \texttt{B′} and evidence that \texttt{Γ\ ⊢\ L\ ·\ M\ ↑\ B′}
holds, we must demonstrate a contradiction. The evidence must take the
form \texttt{⊢L′\ ·\ ⊢M′}, where \texttt{⊢L′} is evidence that
\texttt{Γ\ ⊢\ L\ ↑\ A′\ ⇒\ B′} and \texttt{⊢M′} is evidence that
\texttt{Γ\ ⊢\ M\ ↓\ A′}. By \texttt{uniq-↑} applied to \texttt{⊢L} and
\texttt{⊢L′}, we know that \texttt{A\ ⇒\ B\ ≡\ A′\ ⇒\ B′}, and hence
that \texttt{A\ ≡\ A′}, which means that \texttt{¬⊢M} and \texttt{⊢M′}
yield a contradiction. Without the \texttt{rewrite} clause, Agda would
not allow us to derive a contradiction between \texttt{¬⊢M} and
\texttt{⊢M′}, since one concerns type \texttt{A} and the other type
\texttt{A′}.

If \texttt{Γ\ ⊢\ M\ ↑\ A} holds and \texttt{A\ ≢\ B}, then
\texttt{Γ\ ⊢\ (M\ ↑)\ ↓\ B} does not hold:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{¬switch}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↑}}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\>[2]\AgdaSymbol{→}%
\>[895I]\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≢}}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
\>[.][@{}l@{}]\<[895I]%
\>[4]\AgdaComment{---------------}\<%
\\
%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{¬}}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
\>[0]\AgdaFunction{¬switch}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaBound{A≢B}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaBound{⊢M′}\AgdaSpace{}%
\AgdaBound{A′≡B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{rewrite}\AgdaSpace{}%
\AgdaFunction{uniq-↑}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaBound{⊢M′}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A≢B}\AgdaSpace{}%
\AgdaBound{A′≡B}\<%
\end{code}
\end{fence}

Let \texttt{⊢M} be evidence that \texttt{Γ\ ⊢\ M\ ↑\ A} holds, and
\texttt{A≢B} be evidence that \texttt{A\ ≢\ B}. Given evidence that
\texttt{Γ\ ⊢\ (M\ ↑)\ ↓\ B} holds, we must demonstrate a contradiction.
The evidence must take the form \texttt{⊢↑\ ⊢M′\ A′≡B}, where
\texttt{⊢M′} is evidence that \texttt{Γ\ ⊢\ M\ ↑\ A′} and \texttt{A′≡B}
is evidence that \texttt{A′≡B}. By \texttt{uniq-↑} applied to
\texttt{⊢M} and \texttt{⊢M′} we know that \texttt{A\ ≡\ A′}, which means
that \texttt{A≢B} and \texttt{A′≡B} yield a contradiction. Without the
\texttt{rewrite} clause, Agda would not allow us to derive a
contradiction between \texttt{A≢B} and \texttt{A′≡B}, since one concerns
type \texttt{A} and the other type \texttt{A′}.

\hypertarget{synthesize-and-inherit-types}{%
\section{Synthesize and inherit
types}\label{synthesize-and-inherit-types}}

The table has been set and we are ready for the main course. We define
two mutually recursive functions, one for synthesis and one for
inheritance. Synthesis is given a context \texttt{Γ} and a synthesis
term \texttt{M} and either returns a type \texttt{A} and evidence that
\texttt{Γ\ ⊢\ M\ ↑\ A}, or its negation. Inheritance is given a context
\texttt{Γ}, an inheritance term \texttt{M}, and a type \texttt{A} and
either returns evidence that \texttt{Γ\ ⊢\ M\ ↓\ A}, or its negation:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Context}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{M}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Term⁺}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaComment{-----------------------}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{∃[}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↑}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{))}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Context}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{M}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Term⁻}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaComment{---------------}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

We first consider the code for synthesis:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{lookup}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}%
\>[10]\AgdaBound{¬∃}%
\>[26]\AgdaSymbol{=}%
\>[29]\AgdaInductiveConstructor{no}%
\>[33]\AgdaSymbol{(λ\{}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaBound{∋x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬∃}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{∋x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{∋x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}%
\>[26]\AgdaSymbol{=}%
\>[29]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaBound{∋x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\<%
\\
\>[0]\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{L}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}%
\>[10]\AgdaBound{¬∃}%
\>[26]\AgdaSymbol{=}%
\>[29]\AgdaInductiveConstructor{no}%
\>[33]\AgdaSymbol{(λ\{}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{⊢L}%
\>[47]\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[52]\AgdaOperator{\AgdaInductiveConstructor{⟩}}%
\>[55]\AgdaSymbol{→}%
\>[58]\AgdaBound{¬∃}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}%
\>[20]\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}%
\>[26]\AgdaSymbol{=}%
\>[29]\AgdaInductiveConstructor{no}%
\>[33]\AgdaSymbol{(λ\{}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{⊢L′}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[52]\AgdaOperator{\AgdaInductiveConstructor{⟩}}%
\>[55]\AgdaSymbol{→}%
\>[58]\AgdaFunction{ℕ≢⇒}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{uniq-↑}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaBound{⊢L′}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[7]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}%
\>[13]\AgdaBound{¬⊢M}%
\>[26]\AgdaSymbol{=}%
\>[29]\AgdaInductiveConstructor{no}%
\>[33]\AgdaSymbol{(}\AgdaFunction{¬arg}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaBound{¬⊢M}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[7]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{⊢M}%
\>[26]\AgdaSymbol{=}%
\>[29]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\<%
\\
\>[0]\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↓}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}%
\>[10]\AgdaBound{¬⊢M}%
\>[26]\AgdaSymbol{=}%
\>[29]\AgdaInductiveConstructor{no}%
\>[33]\AgdaSymbol{(λ\{}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢↓}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}%
\>[52]\AgdaSymbol{→}%
\>[55]\AgdaBound{¬⊢M}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{⊢M}%
\>[26]\AgdaSymbol{=}%
\>[29]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢↓}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\<%
\end{code}
\end{fence}

There are three cases:

\begin{itemize}
\item
  If the term is a variable \texttt{\textasciigrave{}\ x}, we use lookup
  as defined above:

  \begin{itemize}
  \item
    If it fails, then \texttt{¬∃} is evidence that there is no
    \texttt{A} such that \texttt{Γ\ ∋\ x\ ⦂\ A} holds. Evidence that
    \texttt{Γ\ ⊢\ \textasciigrave{}\ x\ ↑\ A} holds must have the form
    \texttt{⊢\textasciigrave{}\ ∋x}, where \texttt{∋x} is evidence that
    \texttt{Γ\ ∋\ x\ ⦂\ A}, which yields a contradiction.
  \item
    If it succeeds, then \texttt{∋x} is evidence that
    \texttt{Γ\ ∋\ x\ ⦂\ A}, and hence \texttt{⊢′\ ∋x} is evidence that
    \texttt{Γ\ ⊢\ \textasciigrave{}\ x\ ↑\ A}.
  \end{itemize}
\item
  If the term is an application \texttt{L\ ·\ M}, we recurse on the
  function \texttt{L}:

  \begin{itemize}
  \item
    If it fails, then \texttt{¬∃} is evidence that there is no type such
    that \texttt{Γ\ ⊢\ L\ ↑\ \_} holds. Evidence that
    \texttt{Γ\ ⊢\ L\ ·\ M\ ↑\ \_} holds must have the form
    \texttt{⊢L\ ·\ \_}, where \texttt{⊢L} is evidence that
    \texttt{Γ\ ⊢\ L\ ↑\ \_}, which yields a contradiction.
  \item
    If it succeeds, there are two possibilities:

    \begin{itemize}
    \item
      One is that \texttt{⊢L} is evidence that
      \texttt{Γ\ ⊢\ L\ ⦂\ \textasciigrave{}ℕ}. Evidence that
      \texttt{Γ\ ⊢\ L\ ·\ M\ ↑\ \_} holds must have the form
      \texttt{⊢L′\ ·\ \_} where \texttt{⊢L′} is evidence that
      \texttt{Γ\ ⊢\ L\ ↑\ A\ ⇒\ B} for some types \texttt{A} and
      \texttt{B}. Applying \texttt{uniq-↑} to \texttt{⊢L} and
      \texttt{⊢L′} yields a contradiction, since
      \texttt{\textasciigrave{}ℕ} cannot equal \texttt{A\ ⇒\ B}.
    \item
      The other is that \texttt{⊢L} is evidence that
      \texttt{Γ\ ⊢\ L\ ↑\ A\ ⇒\ B}, in which case we recurse on the
      argument \texttt{M}:

      \begin{itemize}
      \item
        If it fails, then \texttt{¬⊢M} is evidence that
        \texttt{Γ\ ⊢\ M\ ↓\ A} does not hold. By \texttt{¬arg} applied
        to \texttt{⊢L} and \texttt{¬⊢M}, it follows that
        \texttt{Γ\ ⊢\ L\ ·\ M\ ↑\ B} cannot hold.
      \item
        If it succeeds, then \texttt{⊢M} is evidence that
        \texttt{Γ\ ⊢\ M\ ↓\ A}, and \texttt{⊢L\ ·\ ⊢M} provides evidence
        that \texttt{Γ\ ⊢\ L\ ·\ M\ ↑\ B}.
      \end{itemize}
    \end{itemize}
  \end{itemize}
\item
  If the term is a switch \texttt{M\ ↓\ A} from synthesised to
  inherited, we recurse on the subterm \texttt{M}, supplying type
  \texttt{A} by inheritance:

  \begin{itemize}
  \item
    If it fails, then \texttt{¬⊢M} is evidence that
    \texttt{Γ\ ⊢\ M\ ↓\ A} does not hold. Evidence that
    \texttt{Γ\ ⊢\ (M\ ↓\ A)\ ↑\ A} holds must have the form
    \texttt{⊢↓\ ⊢M} where \texttt{⊢M} is evidence that
    \texttt{Γ\ ⊢\ M\ ↓\ A} holds, which yields a contradiction.
  \item
    If it succeeds, then \texttt{⊢M} is evidence that
    \texttt{Γ\ ⊢\ M\ ↓\ A}, and \texttt{⊢↓\ ⊢M} provides evidence that
    \texttt{Γ\ ⊢\ (M\ ↓\ A)\ ↑\ A}.
  \end{itemize}
\end{itemize}

We next consider the code for inheritance:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{ƛ}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{N}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}%
\>[35]\AgdaSymbol{(λ())}\<%
\\
\>[0]\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{ƛ}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{N}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⦂}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬⊢N}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}%
\>[35]\AgdaSymbol{(λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢ƛ}\AgdaSpace{}%
\AgdaBound{⊢N}\AgdaSymbol{)}%
\>[48]\AgdaSymbol{→}%
\>[51]\AgdaBound{¬⊢N}\AgdaSpace{}%
\AgdaBound{⊢N}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{⊢N}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢ƛ}\AgdaSpace{}%
\AgdaBound{⊢N}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaInductiveConstructor{`zero}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢zero}\<%
\\
\>[0]\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaInductiveConstructor{`zero}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}%
\>[35]\AgdaSymbol{(λ())}\<%
\\
\>[0]\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`suc}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬⊢M}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}%
\>[35]\AgdaSymbol{(λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢suc}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSymbol{)}%
\>[50]\AgdaSymbol{→}%
\>[53]\AgdaBound{¬⊢M}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{⊢M}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢suc}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`suc}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}%
\>[35]\AgdaSymbol{(λ())}\<%
\\
\>[0]\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`case}}\AgdaSpace{}%
\AgdaBound{L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[zero⇒}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{|suc}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{L}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬∃}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}%
\>[35]\AgdaSymbol{(λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢case}\AgdaSpace{}%
\AgdaBound{⊢L}%
\>[50]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬∃}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\AgdaSymbol{\})}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}%
\>[35]\AgdaSymbol{(λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢case}\AgdaSpace{}%
\AgdaBound{⊢L′}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{ℕ≢⇒}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{uniq-↑}\AgdaSpace{}%
\AgdaBound{⊢L′}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}%
\>[20]\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[7]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬⊢M}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}%
\>[35]\AgdaSymbol{(λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢case}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬⊢M}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[7]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⦂}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[10]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬⊢N}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}%
\>[35]\AgdaSymbol{(λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢case}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaBound{⊢N}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬⊢N}\AgdaSpace{}%
\AgdaBound{⊢N}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[10]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{⊢N}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢case}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaBound{⊢N}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{μ}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{N}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⦂}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬⊢N}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}%
\>[35]\AgdaSymbol{(λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢μ}\AgdaSpace{}%
\AgdaBound{⊢N}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬⊢N}\AgdaSpace{}%
\AgdaBound{⊢N}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{⊢N}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢μ}\AgdaSpace{}%
\AgdaBound{⊢N}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{inherit}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{M}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}%
\>[10]\AgdaBound{¬∃}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}%
\>[35]\AgdaSymbol{(λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬∃}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\\
\>[0]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≟Tp}}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[6]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}%
\>[12]\AgdaBound{A≢B}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{no}%
\>[35]\AgdaSymbol{(}\AgdaFunction{¬switch}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaBound{A≢B}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[6]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{A≡B}%
\>[28]\AgdaSymbol{=}%
\>[31]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaBound{A≡B}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

We consider only the cases for abstraction and and for switching from
inherited to synthesized:

\begin{itemize}
\item
  If the term is an abstraction \texttt{ƛ\ x\ ⇒\ N} and the inherited
  type is \texttt{\textasciigrave{}ℕ}, then it is trivial that
  \texttt{Γ\ ⊢\ (ƛ\ x\ ⇒\ N)\ ↓\ \textasciigrave{}ℕ} cannot hold.
\item
  If the term is an abstraction \texttt{ƛ\ x\ ⇒\ N} and the inherited
  type is \texttt{A\ ⇒\ B}, then we recurse with context
  \texttt{Γ\ ,\ x\ ⦂\ A} on subterm \texttt{N} inheriting type
  \texttt{B}:

  \begin{itemize}
  \item
    If it fails, then \texttt{¬⊢N} is evidence that
    \texttt{Γ\ ,\ x\ ⦂\ A\ ⊢\ N\ ↓\ B} does not hold. Evidence that
    \texttt{Γ\ ⊢\ (ƛ\ x\ ⇒\ N)\ ↓\ A\ ⇒\ B} holds must have the form
    \texttt{⊢ƛ\ ⊢N} where \texttt{⊢N} is evidence that
    \texttt{Γ\ ,\ x\ ⦂\ A\ ⊢\ N\ ↓\ B}, which yields a contradiction.
  \item
    If it succeeds, then \texttt{⊢N} is evidence that
    \texttt{Γ\ ,\ x\ ⦂\ A\ ⊢\ N\ ↓\ B} holds, and \texttt{⊢ƛ\ ⊢N}
    provides evidence that \texttt{Γ\ ⊢\ (ƛ\ x\ ⇒\ N)\ ↓\ A\ ⇒\ B}.
  \end{itemize}
\item
  If the term is a switch \texttt{M\ ↑} from inherited to synthesised,
  we recurse on the subterm \texttt{M}:

  \begin{itemize}
  \item
    If it fails, then \texttt{¬∃} is evidence there is no \texttt{A}
    such that \texttt{Γ\ ⊢\ M\ ↑\ A} holds. Evidence that
    \texttt{Γ\ ⊢\ (M\ ↑)\ ↓\ B} holds must have the form
    \texttt{⊢↑\ ⊢M\ \_} where \texttt{⊢M} is evidence that
    \texttt{Γ\ ⊢\ M\ ↑\ \_}, which yields a contradiction.
  \item
    If it succeeds, then \texttt{⊢M} is evidence that
    \texttt{Γ\ ⊢\ M\ ↑\ A} holds. We apply \texttt{\_≟Tp\_} do decide
    whether \texttt{A} and \texttt{B} are equal:

    \begin{itemize}
    \item
      If it fails, then \texttt{A≢B} is evidence that \texttt{A\ ≢\ B}.
      By \texttt{¬switch} applied to \texttt{⊢M} and \texttt{A≢B} it
      follow that \texttt{Γ\ ⊢\ (M\ ↑)\ ↓\ B} cannot hold.
    \item
      If it succeeds, then \texttt{A≡B} is evidence that
      \texttt{A\ ≡\ B}, and \texttt{⊢↑\ ⊢M\ A≡B} provides evidence that
      \texttt{Γ\ ⊢\ (M\ ↑)\ ↓\ B}.
    \end{itemize}
  \end{itemize}
\end{itemize}

The remaining cases are similar, and their code can pretty much be read
directly from the corresponding typing rules.

\hypertarget{testing-the-example-terms}{%
\section{Testing the example terms}\label{testing-the-example-terms}}

First, we copy a function introduced earlier that makes it easy to
compute the evidence that two variable names are distinct:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≠\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Id}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≢}}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
\>[0]\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaBound{y}%
\>[7]\AgdaKeyword{with}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≟}}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[10]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}%
\>[16]\AgdaBound{x≢y}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaBound{x≢y}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[10]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaFunction{⊥-elim}\AgdaSpace{}%
\AgdaPostulate{impossible}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{where}\AgdaSpace{}%
\AgdaKeyword{postulate}\AgdaSpace{}%
\AgdaPostulate{impossible}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{⊥}\<%
\end{code}
\end{fence}

Here is the result of typing two plus two on naturals:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{⊢2+2}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaFunction{2+2}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↑}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\<%
\\
\>[0]\AgdaFunction{⊢2+2}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢↓}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[3]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢μ}\<%
\\
\>[3][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢ƛ}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[5]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢ƛ}\<%
\\
\>[5][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢case}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"m"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"n"}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\<%
\\
\>[6][@{}l@{\AgdaIndent{0}}]%
\>[7]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢suc}\<%
\\
\>[7][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢↑}\<%
\\
\>[8][@{}l@{\AgdaIndent{0}}]%
\>[9]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\<%
\\
\>[9][@{}l@{\AgdaIndent{0}}]%
\>[10]\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"p"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"m"}\AgdaSymbol{)}\<%
\\
\>[10][@{}l@{\AgdaIndent{0}}]%
\>[11]\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"p"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"n"}\AgdaSymbol{)}\<%
\\
\>[11][@{}l@{\AgdaIndent{0}}]%
\>[12]\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"p"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"m"}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{)))}\<%
\\
%
\>[10]\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
%
\>[10]\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"n"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"m"}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\<%
\\
%
\>[9]\AgdaInductiveConstructor{refl}\AgdaSymbol{))))))}\<%
\\
%
\>[3]\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢suc}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢zero}\AgdaSymbol{)}\<%
\\
%
\>[3]\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢suc}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢zero}\AgdaSymbol{))}\<%
\end{code}
\end{fence}

We confirm that synthesis on the relevant term returns natural as the
type and the above derivation:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSpace{}%
\AgdaFunction{2+2}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{⊢2+2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

Indeed, the above derivation was computed by evaluating the term on the
left, with minor editing of the result. The only editing required was to
replace Agda's representation of the evidence that two strings are
unequal (which it cannot print nor read) by equivalent calls to
\texttt{\_≠\_}.

Here is the result of typing two plus two with Church numerals:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{⊢2+2ᶜ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaFunction{2+2ᶜ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↑}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\<%
\\
\>[0]\AgdaFunction{⊢2+2ᶜ}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{⊢↓}\<%
\\
%
\>[2]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢ƛ}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[3]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢ƛ}\<%
\\
\>[3][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢ƛ}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[5]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢ƛ}\<%
\\
\>[5][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢↑}\<%
\\
\>[6][@{}l@{\AgdaIndent{0}}]%
\>[7]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\<%
\\
\>[7][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"m"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"z"}\AgdaSymbol{)}\<%
\\
\>[8][@{}l@{\AgdaIndent{0}}]%
\>[9]\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"m"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"s"}\AgdaSymbol{)}\<%
\\
\>[9][@{}l@{\AgdaIndent{0}}]%
\>[10]\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"m"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"n"}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{)))}\<%
\\
%
\>[8]\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"s"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"z"}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
%
\>[8]\AgdaOperator{\AgdaInductiveConstructor{·}}\<%
\\
%
\>[8]\AgdaInductiveConstructor{⊢↑}\<%
\\
%
\>[8]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\<%
\\
\>[8][@{}l@{\AgdaIndent{0}}]%
\>[9]\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"n"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"z"}\AgdaSymbol{)}\<%
\\
\>[9][@{}l@{\AgdaIndent{0}}]%
\>[10]\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"n"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"s"}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{))}\<%
\\
%
\>[9]\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"s"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"z"}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
%
\>[9]\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\<%
\\
%
\>[8]\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\<%
\\
%
\>[7]\AgdaInductiveConstructor{refl}\AgdaSymbol{)))))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{·}}\<%
\\
%
\>[2]\AgdaInductiveConstructor{⊢ƛ}\<%
\\
%
\>[2]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢ƛ}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[3]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢↑}\<%
\\
\>[3][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"s"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"z"}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[5]\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"s"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"z"}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\<%
\\
%
\>[5]\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaInductiveConstructor{refl}\AgdaSymbol{))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{·}}\<%
\\
%
\>[2]\AgdaInductiveConstructor{⊢ƛ}\<%
\\
%
\>[2]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢ƛ}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[3]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢↑}\<%
\\
\>[3][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"s"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"z"}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[5]\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaString{"s"}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≠}}\AgdaSpace{}%
\AgdaString{"z"}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\<%
\\
%
\>[5]\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaInductiveConstructor{refl}\AgdaSymbol{))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢ƛ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢zero}\<%
\end{code}
\end{fence}

We confirm that synthesis on the relevant term returns natural as the
type and the above derivation:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSpace{}%
\AgdaFunction{2+2ᶜ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{⊢2+2ᶜ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

Again, the above derivation was computed by evaluating the term on the
left and editing.

\hypertarget{testing-the-error-cases}{%
\section{Testing the error cases}\label{testing-the-error-cases}}

It is important not just to check that code works as intended, but also
that it fails as intended. Here are checks for several possible errors:

Unbound variable:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaOperator{\AgdaInductiveConstructor{ƛ}}\AgdaSpace{}%
\AgdaString{"x"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"y"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↓}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

Argument in application is ill typed:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{plus}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{sucᶜ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

Function in application is ill typed:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{plus}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{sucᶜ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{two}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

Function in application has type natural:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaFunction{two}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↓}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{two}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

Abstraction inherits type natural:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{twoᶜ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↓}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

Zero inherits a function type:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`zero}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↓}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

Successor inherits a function type:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{two}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↓}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

Successor of an ill-typed term:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{`suc}}\AgdaSpace{}%
\AgdaFunction{twoᶜ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↓}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

Case of a term with a function type:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[1596I]\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\<%
\\
\>[1596I][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaSymbol{((}\AgdaOperator{\AgdaInductiveConstructor{`case}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{twoᶜ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↓}}\AgdaSpace{}%
\AgdaFunction{Ch}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[zero⇒}}\AgdaSpace{}%
\AgdaInductiveConstructor{`zero}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{|suc}}\AgdaSpace{}%
\AgdaString{"x"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"x"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↓}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

Case of an ill-typed term:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[1619I]\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\<%
\\
\>[1619I][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaSymbol{((}\AgdaOperator{\AgdaInductiveConstructor{`case}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{twoᶜ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↓}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[zero⇒}}\AgdaSpace{}%
\AgdaInductiveConstructor{`zero}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{|suc}}\AgdaSpace{}%
\AgdaString{"x"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"x"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↓}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

Inherited and synthesised types disagree in a switch:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{synthesize}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSpace{}%
\AgdaSymbol{(((}\AgdaOperator{\AgdaInductiveConstructor{ƛ}}\AgdaSpace{}%
\AgdaString{"x"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`}}\AgdaSpace{}%
\AgdaString{"x"}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↑}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{↓}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSymbol{)))}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

\hypertarget{erasure}{%
\section{Erasure}\label{erasure}}

From the evidence that a decorated term has the correct type it is easy
to extract the corresponding intrinsically-typed term. We use the name
\texttt{DB} to refer to the code in Chapter
\protect\hyperlink{DeBruijn}{DeBruijn}. It is easy to define an
\emph{erasure} function that takes an extrinsic type judgment into the
corresponding intrinsically-typed term.

First, we give code to erase a type:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{∥\AgdaUnderscore{}∥Tp}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{DB.Type}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaInductiveConstructor{`ℕ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥Tp}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaInductiveConstructor{DB.`ℕ}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥Tp}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥Tp}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{DB.⇒}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥Tp}}\<%
\end{code}
\end{fence}

It simply renames to the corresponding constructors in module
\texttt{DB}.

Next, we give the code to erase a context:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{∥\AgdaUnderscore{}∥Cx}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Context}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{DB.Context}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaInductiveConstructor{∅}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥Cx}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaInductiveConstructor{DB.∅}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⦂}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥Cx}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥Cx}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{DB.,}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥Tp}}\<%
\end{code}
\end{fence}

It simply drops the variable names.

Next, we give the code to erase a lookup judgment:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{∥\AgdaUnderscore{}∥∋}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{∋}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⦂}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥Cx}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{DB.∋}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥Tp}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥∋}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaInductiveConstructor{DB.Z}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaBound{x≢}\AgdaSpace{}%
\AgdaBound{∋x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥∋}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaOperator{\AgdaInductiveConstructor{DB.S}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{∋x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥∋}}\<%
\end{code}
\end{fence}

It simply drops the evidence that variable names are distinct.

Finally, we give the code to erase a typing judgment. Just as there are
two mutually recursive typing judgments, there are two mutually
recursive erasure functions:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{∥\AgdaUnderscore{}∥⁺}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↑}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥Cx}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{DB.⊢}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥Tp}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{∥\AgdaUnderscore{}∥⁻}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊢}}\AgdaSpace{}%
\AgdaBound{M}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{↓}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{Γ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥Cx}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{DB.⊢}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥Tp}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢`}\AgdaSpace{}%
\AgdaBound{⊢x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁺}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaOperator{\AgdaInductiveConstructor{DB.`}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{⊢x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥∋}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁺}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁺}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{DB.·}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁻}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢↓}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁺}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁻}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢ƛ}\AgdaSpace{}%
\AgdaBound{⊢N}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁻}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaOperator{\AgdaInductiveConstructor{DB.ƛ}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{⊢N}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁻}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢zero}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁻}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaInductiveConstructor{DB.`zero}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢suc}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁻}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaOperator{\AgdaInductiveConstructor{DB.`suc}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁻}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢case}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaBound{⊢N}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁻}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaInductiveConstructor{DB.case}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{⊢L}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁺}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁻}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{⊢N}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁻}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢μ}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁻}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaOperator{\AgdaInductiveConstructor{DB.μ}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁻}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaInductiveConstructor{⊢↑}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁻}}%
\>[21]\AgdaSymbol{=}%
\>[24]\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaBound{⊢M}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁺}}\<%
\end{code}
\end{fence}

Erasure replaces constructors for each typing judgment by the
corresponding term constructor from \texttt{DB}. The constructors that
correspond to switching from synthesized to inherited or vice versa are
dropped.

We confirm that the erasure of the type derivations in this chapter
yield the corresponding intrinsically-typed terms from the earlier
chapter:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaFunction{⊢2+2}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁺}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{DB.2+2}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥}}\AgdaSpace{}%
\AgdaFunction{⊢2+2ᶜ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∥⁺}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{DB.2+2ᶜ}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

Thus, we have confirmed that bidirectional type inference converts
decorated versions of the lambda terms from Chapter
\protect\hyperlink{Lambda}{Lambda} to the intrinsically-typed terms of
Chapter \protect\hyperlink{DeBruijn}{DeBruijn}.

\hypertarget{exercise-inference-multiplication-recommended}{%
\subsubsection{\texorpdfstring{Exercise
\texttt{inference-multiplication}
(recommended)}{Exercise inference-multiplication (recommended)}}\label{exercise-inference-multiplication-recommended}}

Apply inference to your decorated definition of multiplication from
exercise
\protect\hyperlink{Inference-bidirectional-mul}{\texttt{bidirectional-mul}},
and show that erasure of the inferred typing yields your definition of
multiplication from Chapter \protect\hyperlink{DeBruijn}{DeBruijn}.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-inference-products-recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{inference-products}
(recommended)}{Exercise inference-products (recommended)}}\label{exercise-inference-products-recommended}}

Using your rules from exercise
\protect\hyperlink{Inference-bidirectional-products}{\texttt{bidirectional-products}},
extend bidirectional inference to include products.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-inference-rest-stretch}{%
\subsubsection{\texorpdfstring{Exercise \texttt{inference-rest}
(stretch)}{Exercise inference-rest (stretch)}}\label{exercise-inference-rest-stretch}}

Extend the bidirectional type rules to include the rest of the
constructs from Chapter \protect\hyperlink{More}{More}.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{bidirectional-inference-in-agda}{%
\section{Bidirectional inference in
Agda}\label{bidirectional-inference-in-agda}}

Agda itself uses bidirectional inference. This explains why constructors
can be overloaded while other defined names cannot --- here by
\emph{overloaded} we mean that the same name can be used for
constructors of different types. Constructors are typed by inheritance,
and so the name is available when resolving the constructor, whereas
variables are typed by synthesis, and so each variable must have a
unique type.

Most top-level definitions in Agda are of functions, which are typed by
inheritance, which is why Agda requires a type declaration for those
definitions. A definition with a right-hand side that is a term typed by
synthesis, such as an application, does not require a type declaration.

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{answer}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaNumber{6}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{*}}\AgdaSpace{}%
\AgdaNumber{7}\<%
\end{code}
\end{fence}

\hypertarget{unicode}{%
\section{Unicode}\label{unicode}}

This chapter uses the following unicode:

\begin{myDisplay}
↓  U+2193:  DOWNWARDS ARROW (\d)
↑  U+2191:  UPWARDS ARROW (\u)
∥  U+2225:  PARALLEL TO (\||)
\end{myDisplay}

