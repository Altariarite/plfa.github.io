\hypertarget{Decidable}{%
\chapter{Decidable: Booleans and decision procedures}\label{Decidable}}

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{plfa.part1.Decidable}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\end{code}
\end{fence}

We have a choice as to how to represent relations: as an inductive data
type of \emph{evidence} that the relation holds, or as a function that
\emph{computes} whether the relation holds. Here we explore the relation
between these choices. We first explore the familiar notion of
\emph{booleans}, but later discover that these are best avoided in
favour of a new notion of \emph{decidable}.

\hypertarget{imports}{%
\section{Imports}\label{imports}}

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary.PropositionalEquality}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Eq}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Eq}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Eq.≡-Reasoning}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{ℕ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}×\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨\AgdaUnderscore{},\AgdaUnderscore{}⟩}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Sum}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}⊎\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{¬\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary.Negation}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{()}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{contradiction}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaFunction{¬¬-intro}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Unit}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{⊤}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Empty}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{⊥}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{⊥-elim}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{plfa.part1.Relations}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}<\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{z<s}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{s<s}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{plfa.part1.Isomorphism}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaRecord{\AgdaUnderscore{}⇔\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

\hypertarget{evidence-vs-computation}{%
\section{Evidence vs Computation}\label{evidence-vs-computation}}

Recall that Chapter \protect\hyperlink{Relations}{Relations} defined
comparison as an inductive datatype, which provides \emph{evidence} that
one number is less than or equal to another:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≤\AgdaUnderscore{}}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≤\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{z≤n}%
\>[71I]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[71I]%
\>[6]\AgdaComment{--------}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}%
\>[85I]\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[.][@{}l@{}]\<[85I]%
\>[6]\AgdaComment{-------------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\<%
\end{code}
\end{fence}

For example, we can provide evidence that \texttt{2\ ≤\ 4}, and show
there is no possible evidence that \texttt{4\ ≤\ 2}:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{2≤4}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaNumber{4}\<%
\\
\>[0]\AgdaFunction{2≤4}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{¬4≤2}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{¬}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{¬4≤2}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{()))}\<%
\end{code}
\end{fence}

The occurrence of \texttt{()} attests to the fact that there is no
possible evidence for \texttt{2\ ≤\ 0}, which \texttt{z≤n} cannot match
(because \texttt{2} is not \texttt{zero}) and \texttt{s≤s} cannot match
(because \texttt{0} cannot match \texttt{suc\ n}).

An alternative, which may seem more familiar, is to define a type of
booleans:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Bool}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{true}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Bool}\<%
\\
%
\>[2]\AgdaInductiveConstructor{false}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Bool}\<%
\end{code}
\end{fence}

Given booleans, we can define a function of two numbers that
\emph{computes} to \texttt{true} if the comparison holds and to
\texttt{false} otherwise:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≤ᵇ\AgdaUnderscore{}}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≤ᵇ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bool}\<%
\\
\>[0]\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ}}\AgdaSpace{}%
\AgdaBound{n}%
\>[16]\AgdaSymbol{=}%
\>[19]\AgdaInductiveConstructor{true}\<%
\\
\>[0]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ}}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}%
\>[16]\AgdaSymbol{=}%
\>[19]\AgdaInductiveConstructor{false}\<%
\\
\>[0]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}%
\>[16]\AgdaSymbol{=}%
\>[19]\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ}}\AgdaSpace{}%
\AgdaBound{n}\<%
\end{code}
\end{fence}

The first and last clauses of this definition resemble the two
constructors of the corresponding inductive datatype, while the middle
clause arises because there is no possible evidence that
\texttt{suc\ m\ ≤\ zero} for any \texttt{m}. For example, we can compute
that \texttt{2\ ≤ᵇ\ 4} holds, and we can compute that \texttt{4\ ≤ᵇ\ 2}
does not hold:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}%
\>[141I]\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[141I]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ}}\AgdaSpace{}%
\AgdaNumber{4}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ}}\AgdaSpace{}%
\AgdaNumber{3}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ}}\AgdaSpace{}%
\AgdaNumber{2}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{true}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}%
\>[154I]\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[154I]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ}}\AgdaSpace{}%
\AgdaNumber{2}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ}}\AgdaSpace{}%
\AgdaNumber{1}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ}}\AgdaSpace{}%
\AgdaNumber{0}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{false}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

In the first case, it takes two steps to reduce the first argument to
zero, and one more step to compute true, corresponding to the two uses
of \texttt{s≤s} and the one use of \texttt{z≤n} when providing evidence
that \texttt{2\ ≤\ 4}. In the second case, it takes two steps to reduce
the second argument to zero, and one more step to compute false,
corresponding to the two uses of \texttt{s≤s} and the one use of
\texttt{()} when showing there can be no evidence that \texttt{4\ ≤\ 2}.

\hypertarget{relating-evidence-and-computation}{%
\section{Relating evidence and
computation}\label{relating-evidence-and-computation}}

We would hope to be able to show these two approaches are related, and
indeed we can. First, we define a function that lets us map from the
computation world to the evidence world:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{T}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Bool}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaFunction{T}\AgdaSpace{}%
\AgdaInductiveConstructor{true}%
\>[9]\AgdaSymbol{=}%
\>[12]\AgdaRecord{⊤}\<%
\\
\>[0]\AgdaFunction{T}\AgdaSpace{}%
\AgdaInductiveConstructor{false}%
\>[9]\AgdaSymbol{=}%
\>[12]\AgdaDatatype{⊥}\<%
\end{code}
\end{fence}

Recall that \texttt{⊤} is the unit type which contains the single
element \texttt{tt}, and the \texttt{⊥} is the empty type which contains
no values. (Also note that \texttt{T} is a capital letter t, and
distinct from \texttt{⊤}.) If \texttt{b} is of type \texttt{Bool}, then
\texttt{tt} provides evidence that \texttt{T\ b} holds if \texttt{b} is
true, while there is no possible evidence that \texttt{T\ b} holds if
\texttt{b} is false.

Another way to put this is that \texttt{T\ b} is inhabited exactly when
\texttt{b\ ≡\ true} is inhabited. In the forward direction, we need to
do a case analysis on the boolean \texttt{b}:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{T→≡}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Bool}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{T}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\<%
\\
\>[0]\AgdaFunction{T→≡}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}%
\>[14]\AgdaSymbol{=}%
\>[17]\AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaFunction{T→≡}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\AgdaSpace{}%
\AgdaSymbol{()}\<%
\end{code}
\end{fence}

If \texttt{b} is true then \texttt{T\ b} is inhabited by \texttt{tt} and
\texttt{b\ ≡\ true} is inhabited by \texttt{refl}, while if \texttt{b}
is false then \texttt{T\ b} in uninhabited.

In the reverse direction, there is no need for a case analysis on the
boolean \texttt{b}:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{≡→T}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Bool}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{T}\AgdaSpace{}%
\AgdaBound{b}\<%
\\
\>[0]\AgdaFunction{≡→T}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}%
\>[10]\AgdaSymbol{=}%
\>[13]\AgdaInductiveConstructor{tt}\<%
\end{code}
\end{fence}

If \texttt{b\ ≡\ true} is inhabited by \texttt{refl} we know that
\texttt{b} is \texttt{true} and hence \texttt{T\ b} is inhabited by
\texttt{tt}.

Now we can show that \texttt{T\ (m\ ≤ᵇ\ n)} is inhabited exactly when
\texttt{m\ ≤\ n} is inhabited.

In the forward direction, we consider the three clauses in the
definition of \texttt{\_≤ᵇ\_}:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{≤ᵇ→≤}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{T}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[0]\AgdaFunction{≤ᵇ→≤}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}%
\>[13]\AgdaBound{n}%
\>[21]\AgdaInductiveConstructor{tt}%
\>[25]\AgdaSymbol{=}%
\>[28]\AgdaInductiveConstructor{z≤n}\<%
\\
\>[0]\AgdaFunction{≤ᵇ→≤}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}%
\>[21]\AgdaSymbol{()}\<%
\\
\>[0]\AgdaFunction{≤ᵇ→≤}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{t}%
\>[25]\AgdaSymbol{=}%
\>[28]\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{≤ᵇ→≤}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{t}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

In the first clause, we immediately have that \texttt{zero\ ≤ᵇ\ n} is
true, so \texttt{T\ (m\ ≤ᵇ\ n)} is evidenced by \texttt{tt}, and
correspondingly \texttt{m\ ≤\ n} is evidenced by \texttt{z≤n}. In the
middle clause, we immediately have that \texttt{suc\ m\ ≤ᵇ\ zero} is
false, and hence \texttt{T\ (m\ ≤ᵇ\ n)} is empty, so we need not provide
evidence that \texttt{m\ ≤\ n}, which is just as well since there is no
such evidence. In the last clause, we have that
\texttt{suc\ m\ ≤ᵇ\ suc\ n} recurses to \texttt{m\ ≤ᵇ\ n}. We let
\texttt{t} be the evidence of \texttt{T\ (suc\ m\ ≤ᵇ\ suc\ n)} if it
exists, which, by definition of \texttt{\_≤ᵇ\_}, will also be evidence
of \texttt{T\ (m\ ≤ᵇ\ n)}. We recursively invoke the function to get
evidence that \texttt{m\ ≤\ n}, which \texttt{s≤s} converts to evidence
that \texttt{suc\ m\ ≤\ suc\ n}.

In the reverse direction, we consider the possible forms of evidence
that \texttt{m\ ≤\ n}:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{≤→≤ᵇ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{T}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{≤→≤ᵇ}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}%
\>[16]\AgdaSymbol{=}%
\>[19]\AgdaInductiveConstructor{tt}\<%
\\
\>[0]\AgdaFunction{≤→≤ᵇ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSymbol{)}%
\>[16]\AgdaSymbol{=}%
\>[19]\AgdaFunction{≤→≤ᵇ}\AgdaSpace{}%
\AgdaBound{m≤n}\<%
\end{code}
\end{fence}

If the evidence is \texttt{z≤n} then we immediately have that
\texttt{zero\ ≤ᵇ\ n} is true, so \texttt{T\ (m\ ≤ᵇ\ n)} is evidenced by
\texttt{tt}. If the evidence is \texttt{s≤s} applied to \texttt{m≤n},
then \texttt{suc\ m\ ≤ᵇ\ suc\ n} reduces to \texttt{m\ ≤ᵇ\ n}, and we
may recursively invoke the function to produce evidence that
\texttt{T\ (m\ ≤ᵇ\ n)}.

The forward proof has one more clause than the reverse proof, precisely
because in the forward proof we need clauses corresponding to the
comparison yielding both true and false, while in the reverse proof we
only need clauses corresponding to the case where there is evidence that
the comparison holds. This is exactly why we tend to prefer the evidence
formulation to the computation formulation, because it allows us to do
less work: we consider only cases where the relation holds, and can
ignore those where it does not.

On the other hand, sometimes the computation formulation may be just
what we want. Given a non-obvious relation over large values, it might
be handy to have the computer work out the answer for us. Fortunately,
rather than choosing between \emph{evidence} and \emph{computation},
there is a way to get the benefits of both.

\hypertarget{the-best-of-both-worlds}{%
\section{The best of both worlds}\label{the-best-of-both-worlds}}

A function that returns a boolean returns exactly a single bit of
information: does the relation hold or does it not? Conversely, the
evidence approach tells us exactly why the relation holds, but we are
responsible for generating the evidence. But it is easy to define a type
that combines the benefits of both approaches. It is called
\texttt{Dec\ A}, where \texttt{Dec} is short for \emph{decidable}:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[10]\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\>[2]\AgdaInductiveConstructor{no}%
\>[6]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{¬}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{A}\<%
\end{code}
\end{fence}

Like booleans, the type has two constructors. A value of type
\texttt{Dec\ A} is either of the form \texttt{yes\ x}, where \texttt{x}
provides evidence that \texttt{A} holds, or of the form \texttt{no\ ¬x},
where \texttt{¬x} provides evidence that \texttt{A} cannot hold (that
is, \texttt{¬x} is a function which given evidence of \texttt{A} yields
a contradiction).

For example, we define a function \texttt{\_≤?\_} which given two
numbers decides whether one is less than or equal to the other, and
provides evidence to justify its conclusion.

First, we introduce two functions useful for constructing evidence that
an inequality does not hold:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{¬s≤z}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{¬}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{¬s≤z}\AgdaSpace{}%
\AgdaSymbol{()}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{¬s≤s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{¬}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{¬}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{¬s≤s}\AgdaSpace{}%
\AgdaBound{¬m≤n}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{¬m≤n}\AgdaSpace{}%
\AgdaBound{m≤n}\<%
\end{code}
\end{fence}

The first of these asserts that \texttt{¬\ (suc\ m\ ≤\ zero)}, and
follows by absurdity, since any evidence of inequality has the form
\texttt{zero\ ≤\ n} or \texttt{suc\ m\ ≤\ suc\ n}, neither of which
match \texttt{suc\ m\ ≤\ zero}. The second of these takes evidence
\texttt{¬m≤n} of \texttt{¬\ (m\ ≤\ n)} and returns a proof of
\texttt{¬\ (suc\ m\ ≤\ suc\ n)}. Any evidence of
\texttt{suc\ m\ ≤\ suc\ n} must have the form \texttt{s≤s\ m≤n} where
\texttt{m≤n} is evidence that \texttt{m\ ≤\ n}. Hence, we have a
contradiction, evidenced by \texttt{¬m≤n\ m≤n}.

Using these, it is straightforward to decide an inequality:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≤?\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaInductiveConstructor{zero}%
\>[6]\AgdaOperator{\AgdaFunction{≤?}}\AgdaSpace{}%
\AgdaBound{n}%
\>[29]\AgdaSymbol{=}%
\>[32]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\<%
\\
\>[0]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤?}}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}%
\>[29]\AgdaSymbol{=}%
\>[32]\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaFunction{¬s≤z}\<%
\\
\>[0]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤?}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤?}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[18]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{m≤n}%
\>[29]\AgdaSymbol{=}%
\>[32]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[18]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬m≤n}%
\>[29]\AgdaSymbol{=}%
\>[32]\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{¬s≤s}\AgdaSpace{}%
\AgdaBound{¬m≤n}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

As with \texttt{\_≤ᵇ\_}, the definition has three clauses. In the first
clause, it is immediate that \texttt{zero\ ≤\ n} holds, and it is
evidenced by \texttt{z≤n}. In the second clause, it is immediate that
\texttt{suc\ m\ ≤\ zero} does not hold, and it is evidenced by
\texttt{¬s≤z}. In the third clause, to decide whether
\texttt{suc\ m\ ≤\ suc\ n} holds we recursively invoke
\texttt{m\ ≤?\ n}. There are two possibilities. In the \texttt{yes} case
it returns evidence \texttt{m≤n} that \texttt{m\ ≤\ n}, and
\texttt{s≤s\ m≤n} provides evidence that \texttt{suc\ m\ ≤\ suc\ n}. In
the \texttt{no} case it returns evidence \texttt{¬m≤n} that
\texttt{¬\ (m\ ≤\ n)}, and \texttt{¬s≤s\ ¬m≤n} provides evidence that
\texttt{¬\ (suc\ m\ ≤\ suc\ n)}.

When we wrote \texttt{\_≤ᵇ\_}, we had to write two other functions,
\texttt{≤ᵇ→≤} and \texttt{≤→≤ᵇ}, in order to show that it was correct.
In contrast, the definition of \texttt{\_≤?\_} proves itself correct, as
attested to by its type. The code of \texttt{\_≤?\_} is far more compact
than the combined code of \texttt{\_≤ᵇ\_}, \texttt{≤ᵇ→≤}, and
\texttt{≤→≤ᵇ}. As we will later show, if you really want the latter
three, it is easy to derive them from \texttt{\_≤?\_}.

We can use our new function to \emph{compute} the \emph{evidence} that
earlier we had to think up on our own:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤?}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\AgdaSymbol{))}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤?}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{¬s≤s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{¬s≤s}\AgdaSpace{}%
\AgdaFunction{¬s≤z}\AgdaSymbol{))}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

You can check that Agda will indeed compute these values. Typing
\texttt{C-c\ C-n} and providing \texttt{2\ ≤?\ 4} or \texttt{4\ ≤?\ 2}
as the requested expression causes Agda to print the values given above.

(A subtlety: if we do not define \texttt{¬s≤z} and \texttt{¬s≤s} as
top-level functions, but instead use inline anonymous functions then
Agda may have trouble normalising evidence of negation.)

\hypertarget{exercise-__-recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{\_\textless{}?\_}
(recommended)}{Exercise \_\textless?\_ (recommended)}}\label{exercise-__-recommended}}

Analogous to the function above, define a function to decide strict
inequality:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaPostulate{\AgdaUnderscore{}<?\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{<}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-_ux2115_-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{\_≡ℕ?\_}
(practice)}{Exercise \_≡ℕ?\_ (practice)}}\label{exercise-_ux2115_-practice}}

Define a function to decide whether two naturals are equal:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaPostulate{\AgdaUnderscore{}≡ℕ?\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{decidables-from-booleans-and-booleans-from-decidables}{%
\section{Decidables from booleans, and booleans from
decidables}\label{decidables-from-booleans-and-booleans-from-decidables}}

Curious readers might wonder if we could reuse the definition of
\texttt{m\ ≤ᵇ\ n}, together with the proofs that it is equivalent to
\texttt{m\ ≤\ n}, to show decidability. Indeed, we can do so as follows:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≤?′\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤?′}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaFunction{≤ᵇ→≤}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaFunction{≤→≤ᵇ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{n}\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[11]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{true}%
\>[20]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaBound{p}%
\>[31]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[46]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{p}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[11]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{false}%
\>[20]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[31]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaBound{¬p}%
\>[46]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬p}\<%
\end{code}
\end{fence}

If \texttt{m\ ≤ᵇ\ n} is true then \texttt{≤ᵇ→≤} yields a proof that
\texttt{m\ ≤\ n} holds, while if it is false then \texttt{≤→≤ᵇ} takes a
proof that \texttt{m\ ≤\ n} holds into a contradiction.

The triple binding of the \texttt{with} clause in this proof is
essential. If instead we wrote:

\begin{myDisplay}
_≤?″_ : ∀ (m n : ℕ) → Dec (m ≤ n)
m ≤?″ n with m ≤ᵇ n
... | true   =  yes (≤ᵇ→≤ m n tt)
... | false  =  no (≤→≤ᵇ {m} {n})
\end{myDisplay}

then Agda would make two complaints, one for each clause:

\begin{myDisplay}
⊤ !=< (T (m ≤ᵇ n)) of type Set
when checking that the expression tt has type T (m ≤ᵇ n)

T (m ≤ᵇ n) !=< ⊥ of type Set
when checking that the expression ≤→≤ᵇ {m} {n} has type ¬ m ≤ n
\end{myDisplay}

Putting the expressions into the \texttt{with} clause permits Agda to
exploit the fact that \texttt{T\ (m\ ≤ᵇ\ n)} is \texttt{⊤} when
\texttt{m\ ≤ᵇ\ n} is true, and that \texttt{T\ (m\ ≤ᵇ\ n)} is \texttt{⊥}
when \texttt{m\ ≤ᵇ\ n} is false.

However, overall it is simpler to just define \texttt{\_≤?\_} directly,
as in the previous section. If one really wants \texttt{\_≤ᵇ\_}, then it
and its properties are easily derived from \texttt{\_≤?\_}, as we will
now show.

Erasure takes a decidable value to a boolean:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{⌊\AgdaUnderscore{}⌋}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bool}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}%
\>[11]\AgdaSymbol{=}%
\>[14]\AgdaInductiveConstructor{true}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}%
\>[11]\AgdaSymbol{=}%
\>[14]\AgdaInductiveConstructor{false}\<%
\end{code}
\end{fence}

Using erasure, we can easily derive \texttt{\_≤ᵇ\_} from
\texttt{\_≤?\_}:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≤ᵇ′\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bool}\<%
\\
\>[0]\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ′}}\AgdaSpace{}%
\AgdaBound{n}%
\>[9]\AgdaSymbol{=}%
\>[12]\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤?}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\<%
\end{code}
\end{fence}

Further, if \texttt{D} is a value of type \texttt{Dec\ A}, then
\texttt{T\ ⌊\ D\ ⌋} is inhabited exactly when \texttt{A} is inhabited:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{toWitness}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{D}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{T}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaBound{D}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaFunction{toWitness}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}%
\>[26]\AgdaSymbol{=}%
\>[29]\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{toWitness}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬x}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{()}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{fromWitness}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{D}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{T}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaBound{D}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\<%
\\
\>[0]\AgdaFunction{fromWitness}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[27]\AgdaSymbol{=}%
\>[30]\AgdaInductiveConstructor{tt}\<%
\\
\>[0]\AgdaFunction{fromWitness}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬x}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{x}%
\>[27]\AgdaSymbol{=}%
\>[30]\AgdaBound{¬x}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}
\end{fence}

Using these, we can easily derive that \texttt{T\ (m\ ≤ᵇ′\ n)} is
inhabited exactly when \texttt{m\ ≤\ n} is inhabited:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{≤ᵇ′→≤}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{T}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ′}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[0]\AgdaFunction{≤ᵇ′→≤}%
\>[7]\AgdaSymbol{=}%
\>[10]\AgdaFunction{toWitness}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{≤→≤ᵇ′}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{T}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤ᵇ′}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{≤→≤ᵇ′}%
\>[7]\AgdaSymbol{=}%
\>[10]\AgdaFunction{fromWitness}\<%
\end{code}
\end{fence}

In summary, it is usually best to eschew booleans and rely on
decidables. If you need booleans, they and their properties are easily
derived from the corresponding decidables.

\hypertarget{logical-connectives}{%
\section{Logical connectives}\label{logical-connectives}}

Most readers will be familiar with the logical connectives for booleans.
Each of these extends to decidables.

The conjunction of two booleans is true if both are true, and false if
either is false:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{6}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∧\AgdaUnderscore{}}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∧\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Bool}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bool}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bool}\<%
\\
\>[0]\AgdaInductiveConstructor{true}%
\>[6]\AgdaOperator{\AgdaFunction{∧}}\AgdaSpace{}%
\AgdaInductiveConstructor{true}%
\>[14]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\<%
\\
\>[0]\AgdaInductiveConstructor{false}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∧}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[14]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\<%
\\
\>[0]\AgdaCatchallClause{\AgdaSymbol{\AgdaUnderscore{}}}%
\>[6]\AgdaCatchallClause{\AgdaOperator{\AgdaFunction{∧}}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaInductiveConstructor{false}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\<%
\end{code}
\end{fence}

In Emacs, the left-hand side of the third equation displays in grey,
indicating that the order of the equations determines which of the
second or the third can match. However, regardless of which matches the
answer is the same.

Correspondingly, given two decidable propositions, we can decide their
conjunction:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{6}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}×-dec\AgdaUnderscore{}}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}×-dec\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×-dec}}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\<%
\\
\>[0]\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×-dec}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ\{}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬x}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaCatchallClause{\AgdaSymbol{\AgdaUnderscore{}}}%
\>[6]\AgdaCatchallClause{\AgdaOperator{\AgdaFunction{×-dec}}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaInductiveConstructor{no}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaBound{¬y}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ\{}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬y}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}
\end{fence}

The conjunction of two propositions holds if they both hold, and its
negation holds if the negation of either holds. If both hold, then we
pair the evidence for each to yield evidence of the conjunct. If the
negation of either holds, assuming the conjunct will lead to a
contradiction.

Again in Emacs, the left-hand side of the third equation displays in
grey, indicating that the order of the equations determines which of the
second or the third can match. This time the answer is different
depending on which matches; if both conjuncts fail to hold we pick the
first to yield the contradiction, but it would be equally valid to pick
the second.

The disjunction of two booleans is true if either is true, and false if
both are false:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∨\AgdaUnderscore{}}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∨\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Bool}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bool}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bool}\<%
\\
\>[0]\AgdaInductiveConstructor{true}%
\>[6]\AgdaOperator{\AgdaFunction{∨}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[15]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\<%
\\
\>[0]\AgdaCatchallClause{\AgdaSymbol{\AgdaUnderscore{}}}%
\>[6]\AgdaCatchallClause{\AgdaOperator{\AgdaFunction{∨}}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaInductiveConstructor{true}}%
\>[15]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\<%
\\
\>[0]\AgdaInductiveConstructor{false}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∨}}\AgdaSpace{}%
\AgdaInductiveConstructor{false}%
\>[15]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\<%
\end{code}
\end{fence}

In Emacs, the left-hand side of the second equation displays in grey,
indicating that the order of the equations determines which of the first
or the second can match. However, regardless of which matches the answer
is the same.

Correspondingly, given two decidable propositions, we can decide their
disjunction:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊎-dec\AgdaUnderscore{}}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊎-dec\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊎-dec}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaCatchallClause{\AgdaSymbol{\AgdaUnderscore{}}}%
\>[6]\AgdaCatchallClause{\AgdaOperator{\AgdaFunction{⊎-dec}}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaInductiveConstructor{yes}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaBound{y}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊎-dec}}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬x}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬y}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}
\end{fence}

The disjunction of two propositions holds if either holds, and its
negation holds if the negation of both hold. If either holds, we inject
the evidence to yield evidence of the disjunct. If the negation of both
hold, assuming either disjunct will lead to a contradiction.

Again in Emacs, the left-hand side of the second equation displays in
grey, indicating that the order of the equations determines which of the
first or the second can match. This time the answer is different
depending on which matches; if both disjuncts hold we pick the first,
but it would be equally valid to pick the second.

The negation of a boolean is false if its argument is true, and vice
versa:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{not}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Bool}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bool}\<%
\\
\>[0]\AgdaFunction{not}\AgdaSpace{}%
\AgdaInductiveConstructor{true}%
\>[10]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\<%
\\
\>[0]\AgdaFunction{not}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\<%
\end{code}
\end{fence}

Correspondingly, given a decidable proposition, we can decide its
negation:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{¬?}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{¬}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{¬?}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}%
\>[12]\AgdaSymbol{=}%
\>[15]\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{¬¬-intro}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{¬?}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬x}\AgdaSymbol{)}%
\>[12]\AgdaSymbol{=}%
\>[15]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{¬x}\<%
\end{code}
\end{fence}

We simply swap yes and no. In the first equation, the right-hand side
asserts that the negation of \texttt{¬\ A} holds, in other words, that
\texttt{¬\ ¬\ A} holds, which is an easy consequence of the fact that
\texttt{A} holds.

There is also a slightly less familiar connective, corresponding to
implication:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊃\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Bool}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bool}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bool}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}%
\>[6]\AgdaOperator{\AgdaFunction{⊃}}\AgdaSpace{}%
\AgdaInductiveConstructor{true}%
\>[15]\AgdaSymbol{=}%
\>[18]\AgdaInductiveConstructor{true}\<%
\\
\>[0]\AgdaCatchallClause{\AgdaInductiveConstructor{false}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaOperator{\AgdaFunction{⊃}}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaSymbol{\AgdaUnderscore{}}}%
\>[15]\AgdaSymbol{=}%
\>[18]\AgdaInductiveConstructor{true}\<%
\\
\>[0]\AgdaInductiveConstructor{true}%
\>[6]\AgdaOperator{\AgdaFunction{⊃}}\AgdaSpace{}%
\AgdaInductiveConstructor{false}%
\>[15]\AgdaSymbol{=}%
\>[18]\AgdaInductiveConstructor{false}\<%
\end{code}
\end{fence}

One boolean implies another if whenever the first is true then the
second is true. Hence, the implication of two booleans is true if the
second is true or the first is false, and false if the first is true and
the second is false. In Emacs, the left-hand side of the second equation
displays in grey, indicating that the order of the equations determines
which of the first or the second can match. However, regardless of which
matches the answer is the same.

Correspondingly, given two decidable propositions, we can decide if the
first implies the second:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}→-dec\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}%
\>[6]\AgdaOperator{\AgdaFunction{→-dec}}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{y}%
\>[19]\AgdaSymbol{=}%
\>[22]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaCatchallClause{\AgdaInductiveConstructor{no}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaBound{¬x}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaOperator{\AgdaFunction{→-dec}}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaSymbol{\AgdaUnderscore{}}}%
\>[19]\AgdaSymbol{=}%
\>[22]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⊥-elim}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{¬x}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{))}\<%
\\
\>[0]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{→-dec}}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬y}%
\>[19]\AgdaSymbol{=}%
\>[22]\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬y}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{))}\<%
\end{code}
\end{fence}

The implication holds if either the second holds or the negation of the
first holds, and its negation holds if the first holds and the negation
of the second holds. Evidence for the implication is a function from
evidence of the first to evidence of the second. If the second holds,
the function returns the evidence for it. If the negation of the first
holds, the function takes the evidence of the first and derives a
contradiction. If the first holds and the negation of the second holds,
given evidence of the implication we must derive a contradiction; we
apply the evidence of the implication \texttt{f} to the evidence of the
first \texttt{x}, yielding a contradiction with the evidence \texttt{¬y}
of the negation of the second.

Again in Emacs, the left-hand side of the second equation displays in
grey, indicating that the order of the equations determines which of the
first or the second can match. This time the answer is different
depending on which matches; but either is equally valid.

\hypertarget{exercise-erasure-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{erasure}
(practice)}{Exercise erasure (practice)}}\label{exercise-erasure-practice}}

Show that erasure relates corresponding boolean and decidable
operations:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{∧-×}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∧}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×-dec}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\<%
\\
%
\>[2]\AgdaPostulate{∨-⊎}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∨}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊎-dec}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\<%
\\
%
\>[2]\AgdaPostulate{not-¬}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{not}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaFunction{¬?}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\<%
\end{code}
\end{fence}

\hypertarget{exercise-iff-erasure-recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{iff-erasure}
(recommended)}{Exercise iff-erasure (recommended)}}\label{exercise-iff-erasure-recommended}}

Give analogues of the \texttt{\_⇔\_} operation from Chapter
\protect\hyperlink{Isomorphism-iff}{Isomorphism}, operation on booleans
and decidables, and also show the corresponding erasure:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaPostulate{\AgdaUnderscore{}iff\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Bool}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bool}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bool}\<%
\\
%
\>[2]\AgdaOperator{\AgdaPostulate{\AgdaUnderscore{}⇔-dec\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⇔}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaPostulate{iff-⇔}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\AgdaSpace{}%
\AgdaOperator{\AgdaPostulate{iff}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaPostulate{⇔-dec}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\<%
\end{code}
\end{fence}

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{Decidable-proof-by-reflection}{%
\section{Proof by reflection}\label{Decidable-proof-by-reflection}}

Let's revisit our definition of monus from Chapter
\protect\hyperlink{Naturals}{Naturals}. If we subtract a larger number
from a smaller number, we take the result to be zero. We had to do
something, after all. What could we have done differently? We could have
defined a \emph{guarded} version of minus, a function which subtracts
\texttt{n} from \texttt{m} only if \texttt{n\ ≤\ m}:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{minus}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{n≤m}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
\>[0]\AgdaFunction{minus}\AgdaSpace{}%
\AgdaBound{m}%
\>[14]\AgdaInductiveConstructor{zero}%
\>[22]\AgdaSymbol{\AgdaUnderscore{}}%
\>[32]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{m}\<%
\\
\>[0]\AgdaFunction{minus}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{n≤m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{minus}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{n≤m}\<%
\end{code}
\end{fence}

Unfortunately, it is painful to use, since we have to explicitly provide
the proof that \texttt{n\ ≤\ m}:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{minus}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\AgdaSymbol{)))}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaNumber{2}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

We cannot solve this problem in general, but in the scenario above, we
happen to know the two numbers \emph{statically}. In that case, we can
use a technique called \emph{proof by reflection}. Essentially, we can
ask Agda to run the decidable equality \texttt{n\ ≤?\ m} while type
checking, and make sure that \texttt{n\ ≤\ m}!

We do this by using a feature of implicits. Agda will fill in an
implicit of a record type if it can fill in all its fields. So Agda will
\emph{always} manage to fill in an implicit of an \emph{empty} record
type, since there aren't any fields after all. This is why \texttt{⊤} is
defined as an empty record.

The trick is to have an implicit argument of the type
\texttt{T\ ⌊\ n\ ≤?\ m\ ⌋}. Let's go through what this means
step-by-step. First, we run the decision procedure, \texttt{n\ ≤?\ m}.
This provides us with evidence whether \texttt{n\ ≤\ m} holds or not. We
erase the evidence to a boolean. Finally, we apply \texttt{T}. Recall
that \texttt{T} maps booleans into the world of evidence: \texttt{true}
becomes the unit type \texttt{⊤}, and \texttt{false} becomes the empty
type \texttt{⊥}. Operationally, an implicit argument of this type works
as a guard.

\begin{itemize}
\tightlist
\item
  If \texttt{n\ ≤\ m} holds, the type of the implicit value reduces to
  \texttt{⊤}. Agda then happily provides the implicit value.
\item
  Otherwise, the type reduces to \texttt{⊥}, which Agda has no chance of
  providing, so it will throw an error. For instance, if we call
  \texttt{3\ -\ 5} we get \texttt{\_n≤m\_254\ :\ ⊥}.
\end{itemize}

We obtain the witness for \texttt{n\ ≤\ m} using \texttt{toWitness},
which we defined earlier:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}-\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{n≤m}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{T}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≤?}}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}-\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{n≤m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{minus}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{toWitness}\AgdaSpace{}%
\AgdaBound{n≤m}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

We can safely use \texttt{\_-\_} as long as we statically know the two
numbers:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{-}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaNumber{2}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

It turns out that this idiom is very common. The standard library
defines a synonym for \texttt{T\ ⌊\ ?\ ⌋} called \texttt{True}:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{True}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Q}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Dec}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaFunction{True}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{T}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌊}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⌋}}\<%
\end{code}
\end{fence}

\hypertarget{exercise-false}{%
\subsubsection{\texorpdfstring{Exercise
\texttt{False}}{Exercise False}}\label{exercise-false}}

Give analogues of \texttt{True}, \texttt{toWitness}, and
\texttt{fromWitness} which work with \emph{negated} properties. Call
these \texttt{False}, \texttt{toWitnessFalse}, and
\texttt{fromWitnessFalse}.

\hypertarget{standard-library}{%
\section{Standard Library}\label{standard-library}}

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Bool.Base}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{Bool}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{T}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∧\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∨\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{not}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≤?\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{Dec}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary.Decidable}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{⌊\AgdaUnderscore{}⌋}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{True}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{toWitness}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{fromWitness}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary.Negation}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{¬?}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary.Product}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}×-dec\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary.Sum}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊎-dec\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Decidable}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

\hypertarget{unicode}{%
\section{Unicode}\label{unicode}}

\begin{myDisplay}
∧  U+2227  LOGICAL AND (\and, \wedge)
∨  U+2228  LOGICAL OR (\or, \vee)
⊃  U+2283  SUPERSET OF (\sup)
ᵇ  U+1D47  MODIFIER LETTER SMALL B  (\^b)
⌊  U+230A  LEFT FLOOR (\clL)
⌋  U+230B  RIGHT FLOOR (\clR)
\end{myDisplay}

