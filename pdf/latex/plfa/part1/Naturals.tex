\hypertarget{Naturals}{%
\chapter{Naturals: Natural numbers}\label{Naturals}}

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{plfa.part1.Naturals}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\end{code}
\end{fence}

The night sky holds more stars than I can count, though fewer than five
thousand are visible to the naked eye. The observable universe contains
about seventy sextillion stars.

But the number of stars is finite, while natural numbers are infinite.
Count all the stars, and you will still have as many natural numbers
left over as you started with.

\hypertarget{the-naturals-are-an-inductive-datatype}{%
\section{The naturals are an inductive
datatype}\label{the-naturals-are-an-inductive-datatype}}

Everyone is familiar with the natural numbers

\begin{myDisplay}
0
1
2
3
...
\end{myDisplay}

and so on. We write \texttt{ℕ} for the \emph{type} of natural numbers,
and say that \texttt{0}, \texttt{1}, \texttt{2}, \texttt{3}, and so on
are \emph{values} of type \texttt{ℕ}, indicated by writing
\texttt{0\ :\ ℕ}, \texttt{1\ :\ ℕ}, \texttt{2\ :\ ℕ}, \texttt{3\ :\ ℕ},
and so on.

The set of natural numbers is infinite, yet we can write down its
definition in just a few lines. Here is the definition as a pair of
inference rules:

\begin{myDisplay}
--------
zero : ℕ

m : ℕ
---------
suc m : ℕ
\end{myDisplay}

And here is the definition in Agda:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\>[2]\AgdaInductiveConstructor{suc}%
\>[7]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\end{code}
\end{fence}

Here \texttt{ℕ} is the name of the \emph{datatype} we are defining, and
\texttt{zero} and \texttt{suc} (short for \emph{successor}) are the
\emph{constructors} of the datatype.

Both definitions above tell us the same two things:

\begin{itemize}
\tightlist
\item
  \emph{Base case}: \texttt{zero} is a natural number.
\item
  \emph{Inductive case}: if \texttt{m} is a natural number, then
  \texttt{suc\ m} is also a natural number.
\end{itemize}

Further, these two rules give the \emph{only} ways of creating natural
numbers. Hence, the possible natural numbers are:

\begin{myDisplay}
zero
suc zero
suc (suc zero)
suc (suc (suc zero))
...
\end{myDisplay}

We write \texttt{0} as shorthand for \texttt{zero}; and \texttt{1} is
shorthand for \texttt{suc\ zero}, the successor of zero, that is, the
natural that comes after zero; and \texttt{2} is shorthand for
\texttt{suc\ (suc\ zero)}, which is the same as \texttt{suc\ 1}, the
successor of one; and \texttt{3} is shorthand for the successor of two;
and so on.

\hypertarget{Naturals-seven}{%
\subsubsection{\texorpdfstring{Exercise \texttt{seven}
(practice)}{Exercise seven (practice)}}\label{Naturals-seven}}

Write out \texttt{7} in longhand.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{unpacking-the-inference-rules}{%
\section{Unpacking the inference
rules}\label{unpacking-the-inference-rules}}

Let's unpack the inference rules. Each inference rule consists of zero
or more \emph{judgments} written above a horizontal line, called the
\emph{hypotheses}, and a single judgment written below, called the
\emph{conclusion}. The first rule is the base case. It has no
hypotheses, and the conclusion asserts that \texttt{zero} is a natural.
The second rule is the inductive case. It has one hypothesis, which
assumes that \texttt{m} is a natural, and the conclusion asserts that
\texttt{suc\ m} is a also a natural.

\hypertarget{unpacking-the-agda-definition}{%
\section{Unpacking the Agda
definition}\label{unpacking-the-agda-definition}}

Let's unpack the Agda definition. The keyword \texttt{data} tells us
this is an inductive definition, that is, that we are defining a new
datatype with constructors. The phrase

\begin{myDisplay}
ℕ : Set
\end{myDisplay}

tells us that \texttt{ℕ} is the name of the new datatype, and that it is
a \texttt{Set}, which is the way in Agda of saying that it is a type.
The keyword \texttt{where} separates the declaration of the datatype
from the declaration of its constructors. Each constructor is declared
on a separate line, which is indented to indicate that it belongs to the
corresponding \texttt{data} declaration. The lines

\begin{myDisplay}
zero : ℕ
suc  : ℕ → ℕ
\end{myDisplay}

give \emph{signatures} specifying the types of the constructors
\texttt{zero} and \texttt{suc}. They tell us that \texttt{zero} is a
natural number and that \texttt{suc} takes a natural number as argument
and returns a natural number.

You may have noticed that \texttt{ℕ} and \texttt{→} don't appear on your
keyboard. They are symbols in \emph{unicode}. At the end of each chapter
is a list of all unicode symbols introduced in the chapter, including
instructions on how to type them in the Emacs text editor. Here
\emph{type} refers to typing with fingers as opposed to data types!

\hypertarget{the-story-of-creation}{%
\section{The story of creation}\label{the-story-of-creation}}

Let's look again at the rules that define the natural numbers:

\begin{itemize}
\tightlist
\item
  \emph{Base case}: \texttt{zero} is a natural number.
\item
  \emph{Inductive case}: if \texttt{m} is a natural number, then
  \texttt{suc\ m} is also a natural number.
\end{itemize}

Hold on! The second line defines natural numbers in terms of natural
numbers. How can that possibly be allowed? Isn't this as useless a
definition as ``Brexit means Brexit''?

In fact, it is possible to assign our definition a meaning without
resorting to unpermitted circularities. Furthermore, we can do so while
only working with \emph{finite} sets and never referring to the
\emph{infinite} set of natural numbers.

We will think of it as a creation story. To start with, we know about no
natural numbers at all:

\begin{myDisplay}
-- In the beginning, there are no natural numbers.
\end{myDisplay}

Now, we apply the rules to all the natural numbers we know about. The
base case tells us that \texttt{zero} is a natural number, so we add it
to the set of known natural numbers. The inductive case tells us that if
\texttt{m} is a natural number (on the day before today) then
\texttt{suc\ m} is also a natural number (today). We didn't know about
any natural numbers before today, so the inductive case doesn't apply:

\begin{myDisplay}
-- On the first day, there is one natural number.
zero : ℕ
\end{myDisplay}

Then we repeat the process. On the next day we know about all the
numbers from the day before, plus any numbers added by the rules. The
base case tells us that \texttt{zero} is a natural number, but we
already knew that. But now the inductive case tells us that since
\texttt{zero} was a natural number yesterday, then \texttt{suc\ zero} is
a natural number today:

\begin{myDisplay}
-- On the second day, there are two natural numbers.
zero : ℕ
suc zero : ℕ
\end{myDisplay}

And we repeat the process again. Now the inductive case tells us that
since \texttt{zero} and \texttt{suc\ zero} are both natural numbers,
then \texttt{suc\ zero} and \texttt{suc\ (suc\ zero)} are natural
numbers. We already knew about the first of these, but the second is
new:

\begin{myDisplay}
-- On the third day, there are three natural numbers.
zero : ℕ
suc zero : ℕ
suc (suc zero) : ℕ
\end{myDisplay}

You've got the hang of it by now:

\begin{myDisplay}
-- On the fourth day, there are four natural numbers.
zero : ℕ
suc zero : ℕ
suc (suc zero) : ℕ
suc (suc (suc zero)) : ℕ
\end{myDisplay}

The process continues. On the \emph{n}'th day there will be \emph{n}
distinct natural numbers. Every natural number will appear on some given
day. In particular, the number \emph{n} first appears on day \emph{n+1}.
And we never actually define the set of numbers in terms of itself.
Instead, we define the set of numbers on day \emph{n+1} in terms of the
set of numbers on day \emph{n}.

A process like this one is called \emph{inductive}. We start with
nothing, and build up a potentially infinite set by applying rules that
convert one finite set into another finite set.

The rule defining zero is called a \emph{base case}, because it
introduces a natural number even when we know no other natural numbers.
The rule defining successor is called an \emph{inductive case}, because
it introduces more natural numbers once we already know some. Note the
crucial role of the base case. If we only had inductive rules, then we
would have no numbers in the beginning, and still no numbers on the
second day, and on the third, and so on. An inductive definition lacking
a base case is useless, as in the phrase ``Brexit means Brexit''.

\hypertarget{philosophy-and-history}{%
\section{Philosophy and history}\label{philosophy-and-history}}

A philosopher might observe that our reference to the first day, second
day, and so on, implicitly involves an understanding of natural numbers.
In this sense, our definition might indeed be regarded as in some sense
circular, but we need not let this disturb us. Everyone possesses a good
informal understanding of the natural numbers, which we may take as a
foundation for their formal description.

While the natural numbers have been understood for as long as people can
count, the inductive definition of the natural numbers is relatively
recent. It can be traced back to Richard Dedekind's paper ``\emph{Was
sind und was sollen die Zahlen?}'' (What are and what should be the
numbers?), published in 1888, and Giuseppe Peano's book
``\emph{Arithmetices principia, nova methodo exposita}'' (The principles
of arithmetic presented by a new method), published the following year.

\hypertarget{a-pragma}{%
\section{A pragma}\label{a-pragma}}

In Agda, any text following \texttt{-\/-} or enclosed between
\texttt{\{-} and \texttt{-\}} is considered a \emph{comment}. Comments
have no effect on the code, with the exception of one special kind of
comment, called a \emph{pragma}, which is enclosed between
\texttt{\{-\#} and \texttt{\#-\}}.

Including the line

\begin{fence}
\begin{code}%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{BUILTIN}\AgdaSpace{}%
\AgdaKeyword{NATURAL}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\end{code}
\end{fence}

tells Agda that \texttt{ℕ} corresponds to the natural numbers, and hence
one is permitted to type \texttt{0} as shorthand for \texttt{zero},
\texttt{1} as shorthand for \texttt{suc\ zero}, \texttt{2} as shorthand
for \texttt{suc\ (suc\ zero)}, and so on. The pragma must be given a
previously declared type (in this case \texttt{ℕ}) with precisely two
constructors, one with no arguments (in this case \texttt{zero}), and
one with a single argument of the given type (in this case
\texttt{suc}).

As well as enabling the above shorthand, the pragma also enables a more
efficient internal representation of naturals using the Haskell type for
arbitrary-precision integers. Representing the natural \emph{n} with
\texttt{zero} and \texttt{suc} requires space proportional to \emph{n},
whereas representing it as an arbitrary-precision integer in Haskell
only requires space proportional to the logarithm of \emph{n}.

\hypertarget{imports}{%
\section{Imports}\label{imports}}

Shortly we will want to write some equations that hold between terms
involving natural numbers. To support doing so, we import the definition
of equality and notations for reasoning about it from the Agda standard
library:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary.PropositionalEquality}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Eq}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Eq}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Eq.≡-Reasoning}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{begin\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≡⟨⟩\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∎}}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

The first line brings the standard library module that defines equality
into scope and gives it the name \texttt{Eq}. The second line opens that
module, that is, adds all the names specified in the \texttt{using}
clause into the current scope. In this case the names added are
\texttt{\_≡\_}, the equality operator, and \texttt{refl}, the name for
evidence that two terms are equal. The third line takes a module that
specifies operators to support reasoning about equivalence, and adds all
the names specified in the \texttt{using} clause into the current scope.
In this case, the names added are \texttt{begin\_}, \texttt{\_≡⟨⟩\_},
and \texttt{\_∎}. We will see how these are used below. We take these as
givens for now, but will see how they are defined in Chapter
\protect\hyperlink{Equality}{Equality}.

Agda uses underbars to indicate where terms appear in infix or mixfix
operators. Thus, \texttt{\_≡\_} and \texttt{\_≡⟨⟩\_} are infix (each
operator is written between two terms), while \texttt{begin\_} is prefix
(it is written before a term), and \texttt{\_∎} is postfix (it is
written after a term).

Parentheses and semicolons are among the few characters that cannot
appear in names, so we do not need extra spaces in the \texttt{using}
list.

\hypertarget{Naturals-plus}{%
\section{Operations on naturals are recursive
functions}\label{Naturals-plus}}

Now that we have the natural numbers, what can we do with them? For
instance, can we define arithmetic operations such as addition and
multiplication?

As a child I spent much time memorising tables of addition and
multiplication. At first the rules seemed tricky and I would often make
mistakes. It came as a shock to me to discover \emph{recursion}, a
simple technique by which every one of the infinite possible instances
of addition and multiplication can be specified in just a couple of
lines.

Here is the definition of addition in Agda:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
\>[0]\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

Let's unpack this definition. Addition is an infix operator. It is
written with underbars where the arguments go, hence its name is
\texttt{\_+\_}. The first line is a signature specifying the type of the
operator. The type \texttt{ℕ\ →\ ℕ\ →\ ℕ}, indicates that addition
accepts two naturals and returns a natural. Infix notation is just a
shorthand for application; the terms \texttt{m\ +\ n} and
\texttt{\_+\_\ m\ n} are equivalent.

The definition has a base case and an inductive case, corresponding to
those for the natural numbers. The base case says that adding zero to a
number, \texttt{zero\ +\ n}, returns that number, \texttt{n}. The
inductive case says that adding the successor of a number to another
number, \texttt{(suc\ m)\ +\ n}, returns the successor of adding the two
numbers, \texttt{suc\ (m\ +\ n)}. We say we use \emph{pattern matching}
when constructors appear on the left-hand side of an equation.

If we write \texttt{zero} as \texttt{0} and \texttt{suc\ m} as
\texttt{1\ +\ m}, the definition turns into two familiar equations:

\begin{myDisplay}
 0       + n  ≡  n
 (1 + m) + n  ≡  1 + (m + n)
\end{myDisplay}

The first follows because zero is an identity for addition, and the
second because addition is associative. In its most general form,
associativity is written

\begin{myDisplay}
 (m + n) + p  ≡  m + (n + p)
\end{myDisplay}

meaning that the location of parentheses is irrelevant. We get the
second equation from the third by taking \texttt{m} to be \texttt{1},
\texttt{n} to be \texttt{m}, and \texttt{p} to be \texttt{n}. We write
\texttt{=} for definitions, while we write \texttt{≡} for assertions
that two already defined things are the same.

The definition is \emph{recursive}, in that the last line defines
addition in terms of addition. As with the inductive definition of the
naturals, the apparent circularity is not a problem. It works because
addition of larger numbers is defined in terms of addition of smaller
numbers. Such a definition is called \emph{well founded}.

For example, let's add two and three:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaNumber{5}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}%
\>[51I]\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[51I]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaNumber{3}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}%
\>[9]\AgdaComment{-- is shorthand for}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{)))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}%
\>[9]\AgdaComment{-- inductive case}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{))))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}%
\>[9]\AgdaComment{-- inductive case}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{)))))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}%
\>[9]\AgdaComment{-- base case}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{))))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}%
\>[9]\AgdaComment{-- is longhand for}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{5}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

We can write the same derivation more compactly by only expanding
shorthand as needed:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaNumber{5}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}%
\>[86I]\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[86I]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaNumber{3}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSymbol{))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{5}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

The first line matches the inductive case by taking \texttt{m\ =\ 1} and
\texttt{n\ =\ 3}, the second line matches the inductive case by taking
\texttt{m\ =\ 0} and \texttt{n\ =\ 3}, and the third line matches the
base case by taking \texttt{n\ =\ 3}.

Both derivations consist of a signature (written with a colon,
\texttt{:}), giving a type, and a binding (written with an equal sign,
\texttt{=}), giving a term of the given type. Here we use the dummy name
\texttt{\_}. The dummy name can be reused, and is convenient for
examples. Names other than \texttt{\_} must be used only once in a
module.

Here the type is \texttt{2\ +\ 3\ ≡\ 5} and the term provides
\emph{evidence} for the corresponding equation, here written in tabular
form as a chain of equations. The chain starts with \texttt{begin} and
finishes with \texttt{∎} (pronounced ``qed'' or ``tombstone'', the
latter from its appearance), and consists of a series of terms separated
by \texttt{≡⟨⟩}.

In fact, both proofs are longer than need be, and Agda is satisfied with
the following:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaNumber{5}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

Agda knows how to compute the value of \texttt{2\ +\ 3}, and so can
immediately check it is the same as \texttt{5}. A binary relation is
said to be \emph{reflexive} if every value relates to itself. Evidence
that a value is equal to itself is written \texttt{refl}.

In the chains of equations, all Agda checks is that each term simplifies
to the same value. If we jumble the equations, omit lines, or add
extraneous lines it will still be accepted. It's up to us to write the
equations in an order that makes sense to the reader.

Here \texttt{2\ +\ 3\ ≡\ 5} is a type, and the chains of equations (and
also \texttt{refl}) are terms of the given type; alternatively, one can
think of each term as \emph{evidence} for the assertion
\texttt{2\ +\ 3\ ≡\ 5}. This duality of interpretation---of a type as a
proposition, and of a term as evidence---is central to how we formalise
concepts in Agda, and will be a running theme throughout this book.

Note that when we use the word \emph{evidence} it is nothing equivocal.
It is not like testimony in a court which must be weighed to determine
whether the witness is trustworthy. Rather, it is ironclad. The other
word for evidence, which we will use interchangeably, is \emph{proof}.

\hypertarget{Naturals-plus-example}{%
\subsubsection{\texorpdfstring{Exercise \texttt{+-example}
(practice)}{Exercise +-example (practice)}}\label{Naturals-plus-example}}

Compute \texttt{3\ +\ 4}, writing out your reasoning as a chain of
equations, using the equations for \texttt{+}.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{multiplication}{%
\section{Multiplication}\label{multiplication}}

Once we have defined addition, we can define multiplication as repeated
addition:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
\>[0]\AgdaInductiveConstructor{zero}%
\>[8]\AgdaOperator{\AgdaFunction{*}}\AgdaSpace{}%
\AgdaBound{n}%
\>[13]\AgdaSymbol{=}%
\>[16]\AgdaInductiveConstructor{zero}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{*}}\AgdaSpace{}%
\AgdaBound{n}%
\>[13]\AgdaSymbol{=}%
\>[16]\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{*}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

Computing \texttt{m\ *\ n} returns the sum of \texttt{m} copies of
\texttt{n}.

Again, rewriting turns the definition into two familiar equations:

\begin{myDisplay}
0       * n  ≡  0
(1 + m) * n  ≡  n + (m * n)
\end{myDisplay}

The first follows because zero times anything is zero, and the second
follows because multiplication distributes over addition. In its most
general form, distribution of multiplication over addition is written

\begin{myDisplay}
(m + n) * p  ≡  (m * p) + (n * p)
\end{myDisplay}

We get the second equation from the third by taking \texttt{m} to be
\texttt{1}, \texttt{n} to be \texttt{m}, and \texttt{p} to be
\texttt{n}, and then using the fact that one is an identity for
multiplication, so \texttt{1\ *\ n\ ≡\ n}.

Again, the definition is well founded in that multiplication of larger
numbers is defined in terms of multiplication of smaller numbers.

For example, let's multiply two and three:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}%
\>[120I]\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[120I]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{*}}\AgdaSpace{}%
\AgdaNumber{3}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}%
\>[9]\AgdaComment{-- inductive case}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{*}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}%
\>[9]\AgdaComment{-- inductive case}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{*}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSymbol{))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}%
\>[9]\AgdaComment{-- base case}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}%
\>[9]\AgdaComment{-- simplify}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{6}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

The first line matches the inductive case by taking \texttt{m\ =\ 1} and
\texttt{n\ =\ 3}, The second line matches the inductive case by taking
\texttt{m\ =\ 0} and \texttt{n\ =\ 3}, and the third line matches the
base case by taking \texttt{n\ =\ 3}. Here we have omitted the signature
declaring \texttt{\_\ :\ 2\ *\ 3\ ≡\ 6}, since it can easily be inferred
from the corresponding term.

\hypertarget{Naturals-times-example}{%
\subsubsection{\texorpdfstring{Exercise \texttt{*-example}
(practice)}{Exercise *-example (practice)}}\label{Naturals-times-example}}

Compute \texttt{3\ *\ 4}, writing out your reasoning as a chain of
equations, using the equations for \texttt{*}. (You do not need to step
through the evaluation of \texttt{+}.)

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{Naturals-power}{%
\subsubsection{\texorpdfstring{Exercise \texttt{\_\^{}\_}
(recommended)}{Exercise \_\^{}\_ (recommended)}}\label{Naturals-power}}

Define exponentiation, which is given by the following equations:

\begin{myDisplay}
m ^ 0        =  1
m ^ (1 + n)  =  m * (m ^ n)
\end{myDisplay}

Check that \texttt{3\ \^{}\ 4} is \texttt{81}.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{monus}{%
\section{Monus}\label{monus}}

We can also define subtraction. Since there are no negative natural
numbers, if we subtract a larger number from a smaller number we will
take the result to be zero. This adaption of subtraction to naturals is
called \emph{monus} (a twist on \emph{minus}).

Monus is our first use of a definition that uses pattern matching
against both arguments:

\begin{fence}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∸\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
\>[0]\AgdaBound{m}%
\>[6]\AgdaOperator{\AgdaFunction{∸}}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}%
\>[15]\AgdaSymbol{=}%
\>[18]\AgdaBound{m}\<%
\\
\>[0]\AgdaInductiveConstructor{zero}%
\>[6]\AgdaOperator{\AgdaFunction{∸}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}%
\>[15]\AgdaSymbol{=}%
\>[18]\AgdaInductiveConstructor{zero}\<%
\\
\>[0]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∸}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}%
\>[15]\AgdaSymbol{=}%
\>[18]\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∸}}\AgdaSpace{}%
\AgdaBound{n}\<%
\end{code}
\end{fence}

We can do a simple analysis to show that all the cases are covered.

\begin{itemize}
\tightlist
\item
  Consider the second argument.

  \begin{itemize}
  \tightlist
  \item
    If it is \texttt{zero}, then the first equation applies.
  \item
    If it is \texttt{suc\ n}, then consider the first argument.

    \begin{itemize}
    \tightlist
    \item
      If it is \texttt{zero}, then the second equation applies.
    \item
      If it is \texttt{suc\ m}, then the third equation applies.
    \end{itemize}
  \end{itemize}
\end{itemize}

Again, the recursive definition is well founded because monus on bigger
numbers is defined in terms of monus on smaller numbers.

For example, let's subtract two from three:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}%
\>[152I]\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[152I]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∸}}\AgdaSpace{}%
\AgdaNumber{2}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∸}}\AgdaSpace{}%
\AgdaNumber{1}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∸}}\AgdaSpace{}%
\AgdaNumber{0}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{1}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

We did not use the second equation at all, but it will be required if we
try to subtract a larger number from a smaller one:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}%
\>[159I]\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[159I]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∸}}\AgdaSpace{}%
\AgdaNumber{3}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∸}}\AgdaSpace{}%
\AgdaNumber{2}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∸}}\AgdaSpace{}%
\AgdaNumber{1}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{0}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

\hypertarget{Naturals-monus-examples}{%
\subsubsection{\texorpdfstring{Exercise \texttt{∸-example₁} and
\texttt{∸-example₂}
(recommended)}{Exercise ∸-example₁ and ∸-example₂ (recommended)}}\label{Naturals-monus-examples}}

Compute \texttt{5\ ∸\ 3} and \texttt{3\ ∸\ 5}, writing out your
reasoning as a chain of equations.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{precedence}{%
\section{Precedence}\label{precedence}}

We often use \emph{precedence} to avoid writing too many parentheses.
Application \emph{binds more tightly than} (or \emph{has precedence
over}) any operator, and so we may write \texttt{suc\ m\ +\ n} to mean
\texttt{(suc\ m)\ +\ n}. As another example, we say that multiplication
binds more tightly than addition, and so write \texttt{n\ +\ m\ *\ n} to
mean \texttt{n\ +\ (m\ *\ n)}. We also sometimes say that addition
\emph{associates to the left}, and so write \texttt{m\ +\ n\ +\ p} to
mean \texttt{(m\ +\ n)\ +\ p}.

In Agda the precedence and associativity of infix operators needs to be
declared:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{infixl}\AgdaSpace{}%
\AgdaNumber{6}%
\>[10]\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}%
\>[15]\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}∸\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaKeyword{infixl}\AgdaSpace{}%
\AgdaNumber{7}%
\>[10]\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*\AgdaUnderscore{}}}\<%
\end{code}
\end{fence}

This states operators \texttt{\_+\_} and \texttt{\_∸\_} have precedence
level 6, and operator \texttt{\_*\_} has precedence level 7. Addition
and monus bind less tightly than multiplication because they have lower
precedence. Writing \texttt{infixl} indicates that all three operators
associate to the left. One can also write \texttt{infixr} to indicate
that an operator associates to the right, or just \texttt{infix} to
indicate that parentheses are always required to disambiguate.

\hypertarget{currying}{%
\section{Currying}\label{currying}}

We have chosen to represent a function of two arguments in terms of a
function of the first argument that returns a function of the second
argument. This trick goes by the name \emph{currying}.

Agda, like other functional languages such as Haskell and ML, is
designed to make currying easy to use. Function arrows associate to the
right and application associates to the left

\texttt{ℕ\ →\ ℕ\ →\ ℕ} stands for \texttt{ℕ\ →\ (ℕ\ →\ ℕ)}

and

\texttt{\_+\_\ 2\ 3} stands for \texttt{(\_+\_\ 2)\ 3}.

The term \texttt{\_+\_\ 2} by itself stands for the function that adds
two to its argument, hence applying it to three yields five.

Currying is named for Haskell Curry, after whom the programming language
Haskell is also named. Curry's work dates to the 1930's. When I first
learned about currying, I was told it was misattributed, since the same
idea was previously proposed by Moses Schönfinkel in the 1920's. I was
told a joke: ``It should be called schönfinkeling, but currying is
tastier''. Only later did I learn that the explanation of the
misattribution was itself a misattribution. The idea actually appears in
the \emph{Begriffsschrift} of Gottlob Frege, published in 1879.

\hypertarget{the-story-of-creation-revisited}{%
\section{The story of creation,
revisited}\label{the-story-of-creation-revisited}}

Just as our inductive definition defines the naturals in terms of the
naturals, so does our recursive definition define addition in terms of
addition.

Again, it is possible to assign our definition a meaning without
resorting to unpermitted circularities. We do so by reducing our
definition to equivalent inference rules for judgments about equality:

\begin{myDisplay}
n : ℕ
--------------
zero + n  =  n

m + n  =  p
---------------------
(suc m) + n  =  suc p
\end{myDisplay}

Here we assume we have already defined the infinite set of natural
numbers, specifying the meaning of the judgment \texttt{n\ :\ ℕ}. The
first inference rule is the base case. It asserts that if \texttt{n} is
a natural number then adding zero to it gives \texttt{n}. The second
inference rule is the inductive case. It asserts that if adding
\texttt{m} and \texttt{n} gives \texttt{p}, then adding \texttt{suc\ m}
and \texttt{n} gives \texttt{suc\ p}.

Again we resort to a creation story, where this time we are concerned
with judgments about addition:

\begin{myDisplay}
-- In the beginning, we know nothing about addition.
\end{myDisplay}

Now, we apply the rules to all the judgment we know about. The base case
tells us that \texttt{zero\ +\ n\ =\ n} for every natural \texttt{n}, so
we add all those equations. The inductive case tells us that if
\texttt{m\ +\ n\ =\ p} (on the day before today) then
\texttt{suc\ m\ +\ n\ =\ suc\ p} (today). We didn't know any equations
about addition before today, so that rule doesn't give us any new
equations:

\begin{myDisplay}
-- On the first day, we know about addition of 0.
0 + 0 = 0     0 + 1 = 1    0 + 2 = 2     ...
\end{myDisplay}

Then we repeat the process, so on the next day we know about all the
equations from the day before, plus any equations added by the rules.
The base case tells us nothing new, but now the inductive case adds more
equations:

\begin{myDisplay}
-- On the second day, we know about addition of 0 and 1.
0 + 0 = 0     0 + 1 = 1     0 + 2 = 2     0 + 3 = 3     ...
1 + 0 = 1     1 + 1 = 2     1 + 2 = 3     1 + 3 = 4     ...
\end{myDisplay}

And we repeat the process again:

\begin{myDisplay}
-- On the third day, we know about addition of 0, 1, and 2.
0 + 0 = 0     0 + 1 = 1     0 + 2 = 2     0 + 3 = 3     ...
1 + 0 = 1     1 + 1 = 2     1 + 2 = 3     1 + 3 = 4     ...
2 + 0 = 2     2 + 1 = 3     2 + 2 = 4     2 + 3 = 5     ...
\end{myDisplay}

You've got the hang of it by now:

\begin{myDisplay}
-- On the fourth day, we know about addition of 0, 1, 2, and 3.
0 + 0 = 0     0 + 1 = 1     0 + 2 = 2     0 + 3 = 3     ...
1 + 0 = 1     1 + 1 = 2     1 + 2 = 3     1 + 3 = 4     ...
2 + 0 = 2     2 + 1 = 3     2 + 2 = 4     2 + 3 = 5     ...
3 + 0 = 3     3 + 1 = 4     3 + 2 = 5     3 + 3 = 6     ...
\end{myDisplay}

The process continues. On the \emph{m}'th day we will know all the
equations where the first number is less than \emph{m}.

As we can see, the reasoning that justifies inductive and recursive
definitions is quite similar. They might be considered two sides of the
same coin.

\hypertarget{Naturals-finite-creation}{%
\section{The story of creation,
finitely}\label{Naturals-finite-creation}}

The above story was told in a stratified way. First, we create the
infinite set of naturals. We take that set as given when creating
instances of addition, so even on day one we have an infinite set of
instances.

Instead, we could choose to create both the naturals and the instances
of addition at the same time. Then on any day there would be only a
finite set of instances:

\begin{myDisplay}
-- In the beginning, we know nothing.
\end{myDisplay}

Now, we apply the rules to all the judgment we know about. Only the base
case for naturals applies:

\begin{myDisplay}
-- On the first day, we know zero.
0 : ℕ
\end{myDisplay}

Again, we apply all the rules we know. This gives us a new natural, and
our first equation about addition.

\begin{myDisplay}
-- On the second day, we know one and all sums that yield zero.
0 : ℕ
1 : ℕ    0 + 0 = 0
\end{myDisplay}

Then we repeat the process. We get one more equation about addition from
the base case, and also get an equation from the inductive case, applied
to equation of the previous day:

\begin{myDisplay}
-- On the third day, we know two and all sums that yield one.
0 : ℕ
1 : ℕ    0 + 0 = 0
2 : ℕ    0 + 1 = 1   1 + 0 = 1
\end{myDisplay}

You've got the hang of it by now:

\begin{myDisplay}
-- On the fourth day, we know three and all sums that yield two.
0 : ℕ
1 : ℕ    0 + 0 = 0
2 : ℕ    0 + 1 = 1   1 + 0 = 1
3 : ℕ    0 + 2 = 2   1 + 1 = 2    2 + 0 = 2
\end{myDisplay}

On the \emph{n}'th day there will be \emph{n} distinct natural numbers,
and \emph{n × (n-1) / 2} equations about addition. The number \emph{n}
and all equations for addition of numbers less than \emph{n} first
appear by day \emph{n+1}. This gives an entirely finitist view of
infinite sets of data and equations relating the data.

\hypertarget{writing-definitions-interactively}{%
\section{Writing definitions
interactively}\label{writing-definitions-interactively}}

Agda is designed to be used with the Emacs text editor, and the two in
combination provide features that help to create definitions and proofs
interactively.

Begin by typing:

\begin{myDisplay}
_+_ : ℕ → ℕ → ℕ
m + n = ?
\end{myDisplay}

The question mark indicates that you would like Agda to help with
filling in that part of the code. If you type \texttt{C-c\ C-l}
(pressing the control key while hitting the \texttt{c} key followed by
the \texttt{l} key), which stands for \textbf{l}oad, the question mark
will be replaced:

\begin{myDisplay}
_+_ : ℕ → ℕ → ℕ
m + n = { }0
\end{myDisplay}

The empty braces are called a \emph{hole}, and 0 is a number used for
referring to the hole. The hole will display highlighted in green. Emacs
will also create a window displaying the text

\begin{myDisplay}
?0 : ℕ
\end{myDisplay}

to indicate that hole 0 is to be filled in with a term of type
\texttt{ℕ}. Typing \texttt{C-c\ C-f} (for \textbf{f}orward) will move
you into the next hole.

We wish to define addition by recursion on the first argument. Move the
cursor into the hole and type \texttt{C-c\ C-c} (for \textbf{c}ase). You
will be given the prompt:

\begin{myDisplay}
pattern variables to case (empty for split on result):
\end{myDisplay}

Typing \texttt{m} will cause a split on that variable, resulting in an
update to the code:

\begin{myDisplay}
_+_ : ℕ → ℕ → ℕ
zero + n = { }0
suc m + n = { }1
\end{myDisplay}

There are now two holes, and the window at the bottom tells you the
required type of each:

\begin{myDisplay}
?0 : ℕ
?1 : ℕ
\end{myDisplay}

Going into hole 0 and type \texttt{C-c\ C-,} will display information on
the required type of the hole, and what free variables are available:

\begin{myDisplay}
Goal: ℕ
————————————————————————————————————————————————————————————
n : ℕ
\end{myDisplay}

This strongly suggests filling the hole with \texttt{n}. After the hole
is filled, you can type \texttt{C-c\ C-space}, which will remove the
hole:

\begin{myDisplay}
_+_ : ℕ → ℕ → ℕ
zero + n = n
suc m + n = { }1
\end{myDisplay}

Again, going into hole 1 and type \texttt{C-c\ C-,} will display
information on the required type of the hole, and what free variables
are available:

\begin{myDisplay}
Goal: ℕ
————————————————————————————————————————————————————————————
n : ℕ
m : ℕ
\end{myDisplay}

Going into the hole and type \texttt{C-c\ C-r} (for \textbf{r}efine)
will fill it in with a constructor (if there is a unique choice) or tell
you what constructors you might use, if there is a choice. In this case,
it displays the following:

\begin{myDisplay}
Don't know which constructor to introduce of zero or suc
\end{myDisplay}

Filling the hole with \texttt{suc\ ?} and typing \texttt{C-c\ C-space}
results in the following:

\begin{myDisplay}
_+_ : ℕ → ℕ → ℕ
zero + n = n
suc m + n = suc { }1
\end{myDisplay}

Going into the new hole and typing \texttt{C-c\ C-,} gives similar
information to before:

\begin{myDisplay}
Goal: ℕ
————————————————————————————————————————————————————————————
n : ℕ
m : ℕ
\end{myDisplay}

We can fill the hole with \texttt{m\ +\ n} and type
\texttt{C-c\ C-space} to complete the program:

\begin{myDisplay}
_+_ : ℕ → ℕ → ℕ
zero + n = n
suc m + n = suc (m + n)
\end{myDisplay}

Exploiting interaction to this degree is probably not helpful for a
program this simple, but the same techniques can help with more complex
programs. Even for a program this simple, using \texttt{C-c\ C-c} to
split cases can be helpful.

\hypertarget{more-pragmas}{%
\section{More pragmas}\label{more-pragmas}}

Including the lines

\begin{fence}
\begin{code}%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{BUILTIN}\AgdaSpace{}%
\AgdaKeyword{NATPLUS}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{BUILTIN}\AgdaSpace{}%
\AgdaKeyword{NATTIMES}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{BUILTIN}\AgdaSpace{}%
\AgdaKeyword{NATMINUS}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}∸\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\end{code}
\end{fence}

tells Agda that these three operators correspond to the usual ones, and
enables it to perform these computations using the corresponding Haskell
operators on the arbitrary-precision integer type. Representing naturals
with \texttt{zero} and \texttt{suc} requires time proportional to
\emph{m} to add \emph{m} and \emph{n}, whereas representing naturals as
integers in Haskell requires time proportional to the larger of the
logarithms of \emph{m} and \emph{n}. Similarly, representing naturals
with \texttt{zero} and \texttt{suc} requires time proportional to the
product of \emph{m} and \emph{n} to multiply \emph{m} and \emph{n},
whereas representing naturals as integers in Haskell requires time
proportional to the sum of the logarithms of \emph{m} and \emph{n}.

\hypertarget{Naturals-Bin}{%
\subsubsection{\texorpdfstring{Exercise \texttt{Bin}
(stretch)}{Exercise Bin (stretch)}}\label{Naturals-Bin}}

A more efficient representation of natural numbers uses a binary rather
than a unary system. We represent a number as a bitstring:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Bin}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{⟨⟩}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Bin}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}O}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Bin}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bin}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}I}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Bin}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bin}\<%
\end{code}
\end{fence}

For instance, the bitstring

\begin{myDisplay}
1011
\end{myDisplay}

standing for the number eleven is encoded as

\begin{myDisplay}
⟨⟩ I O I I
\end{myDisplay}

Representations are not unique due to leading zeros. Hence, eleven is
also represented by \texttt{001011}, encoded as:

\begin{myDisplay}
⟨⟩ O O I O I I
\end{myDisplay}

Define a function

\begin{myDisplay}
inc : Bin → Bin
\end{myDisplay}

that converts a bitstring to the bitstring for the next higher number.
For example, since \texttt{1100} encodes twelve, we should have:

\begin{myDisplay}
inc (⟨⟩ I O I I) ≡ ⟨⟩ I I O O
\end{myDisplay}

Confirm that this gives the correct answer for the bitstrings encoding
zero through four.

Using the above, define a pair of functions to convert between the two
representations.

\begin{myDisplay}
to   : ℕ → Bin
from : Bin → ℕ
\end{myDisplay}

For the former, choose the bitstring to have no leading zeros if it
represents a positive natural, and represent zero by \texttt{⟨⟩\ O}.
Confirm that these both give the correct answer for zero through four.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{standard-library}{%
\section{Standard library}\label{standard-library}}

At the end of each chapter, we will show where to find relevant
definitions in the standard library. The naturals, constructors for
them, and basic operators upon them, are defined in the standard library
module \texttt{Data.Nat}:

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- import Data.Nat using (ℕ; zero; suc; \AgdaUnderscore{}+\AgdaUnderscore{}; \AgdaUnderscore{}*\AgdaUnderscore{}; \AgdaUnderscore{}\textasciicircum{}\AgdaUnderscore{}; \AgdaUnderscore{}∸\AgdaUnderscore{})}\<%
\end{code}
\end{fence}

Normally, we will show an import as running code, so Agda will complain
if we attempt to import a definition that is not available. This time,
however, we have only shown the import as a comment. Both this chapter
and the standard library invoke the \texttt{NATURAL} pragma, the former
on \texttt{ℕ}, and the latter on the equivalent type
\texttt{Data.Nat.ℕ}. Such a pragma can only be invoked once, as invoking
it twice would raise confusion as to whether \texttt{2} is a value of
type \texttt{ℕ} or type \texttt{Data.Nat.ℕ}. Similar confusions arise if
other pragmas are invoked twice. For this reason, we will usually avoid
pragmas in future chapters. Information on pragmas can be found in the
\href{https://agda.readthedocs.io/en/v2.6.1/language/pragmas.html}{Agda
documentation}.

\hypertarget{unicode}{%
\section{Unicode}\label{unicode}}

This chapter uses the following unicode:

\begin{myDisplay}
ℕ  U+2115  DOUBLE-STRUCK CAPITAL N (\bN)
→  U+2192  RIGHTWARDS ARROW (\to, \r, \->)
∸  U+2238  DOT MINUS (\.-)
≡  U+2261  IDENTICAL TO (\==)
⟨  U+27E8  MATHEMATICAL LEFT ANGLE BRACKET (\<)
⟩  U+27E9  MATHEMATICAL RIGHT ANGLE BRACKET (\>)
∎  U+220E  END OF PROOF (\qed)
\end{myDisplay}

Each line consists of the Unicode character (\texttt{ℕ}), the
corresponding code point (\texttt{U+2115}), the name of the character
(\texttt{DOUBLE-STRUCK\ CAPITAL\ N}), and the sequence to type into
Emacs to generate the character (\texttt{\textbackslash{}bN}).

The command \texttt{\textbackslash{}r} gives access to a wide variety of
rightward arrows. After typing \texttt{\textbackslash{}r}, one can
access the many available arrows by using the left, right, up, and down
keys to navigate. The command remembers where you navigated to the last
time, and starts with the same character next time. The command
\texttt{\textbackslash{}l} works similarly for left arrows. In place of
left, right, up, and down keys, one may also use control characters:

\begin{myDisplay}
C-b  left (backward one character)
C-f  right (forward one character)
C-p  up (to the previous line)
C-n  down (to the next line)
\end{myDisplay}

We write \texttt{C-b} to stand for control-b, and similarly. One can
also navigate left and right by typing the digits that appear in the
displayed list.

For a full list of supported characters, use
\texttt{agda-input-show-translations} with:

\begin{myDisplay}
M-x agda-input-show-translations
\end{myDisplay}

All the characters supported by \texttt{agda-mode} are shown. We write
M-x to stand for typing \texttt{ESC} followed by \texttt{x}.

If you want to know how you input a specific Unicode character in an
agda file, move the cursor onto the character and use
\texttt{quail-show-key} with:

\begin{myDisplay}
M-x quail-show-key
\end{myDisplay}

You'll see a key sequence of the character in mini buffer. If you run
\texttt{M-x\ quail-show-key} on say \texttt{∸}, you will see
\texttt{\textbackslash{}.-} for the character.

