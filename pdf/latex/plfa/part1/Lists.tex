\hypertarget{Lists}{%
\chapter{Lists: Lists and higher-order functions}\label{Lists}}

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{plfa.part1.Lists}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\end{code}
\end{fence}

This chapter discusses the list data type. It gives further examples of
many of the techniques we have developed so far, and provides examples
of polymorphic types and higher-order functions.

\hypertarget{imports}{%
\section{Imports}\label{imports}}

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary.PropositionalEquality}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Eq}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Eq}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{trans}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Eq.≡-Reasoning}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Bool}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{Bool}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{T}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∧\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∨\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{not}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{ℕ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}∸\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≤\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{s≤s}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat.Properties}\AgdaSpace{}%
\AgdaKeyword{using}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{(}\AgdaFunction{+-assoc}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{+-identityˡ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{+-identityʳ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{*-assoc}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{*-identityˡ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{*-identityʳ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{¬\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}×\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{∃}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{∃-syntax}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨\AgdaUnderscore{},\AgdaUnderscore{}⟩}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Function}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∘\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Level}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{Level}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{plfa.part1.Isomorphism}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaRecord{\AgdaUnderscore{}≃\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{\AgdaUnderscore{}⇔\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

\hypertarget{lists}{%
\section{Lists}\label{lists}}

Lists are defined in Agda as follows:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{[]}%
\>[6]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∷\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∷\AgdaUnderscore{}}}\<%
\end{code}
\end{fence}

Let's unpack this definition. If \texttt{A} is a set, then
\texttt{List\ A} is a set. The next two lines tell us that
\texttt{{[}{]}} (pronounced \emph{nil}) is a list of type \texttt{A}
(often called the \emph{empty} list), and that \texttt{\_∷\_}
(pronounced \emph{cons}, short for \emph{constructor}) takes a value of
type \texttt{A} and a value of type \texttt{List\ A} and returns a value
of type \texttt{List\ A}. Operator \texttt{\_∷\_} has precedence level 5
and associates to the right.

For example,

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\end{code}
\end{fence}

denotes the list of the first three natural numbers. Since
\texttt{\_∷\_} associates to the right, the term parses as
\texttt{0\ ∷\ (1\ ∷\ (2\ ∷\ {[}{]}))}. Here \texttt{0} is the first
element of the list, called the \emph{head}, and
\texttt{1\ ∷\ (2\ ∷\ {[}{]})} is a list of the remaining elements,
called the \emph{tail}. A list is a strange beast: it has a head and a
tail, nothing in between, and the tail is itself another list!

As we've seen, parameterised types can be translated to indexed types.
The definition above is equivalent to the following:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{List′}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{[]′}%
\>[7]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List′}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∷′\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List′}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List′}\AgdaSpace{}%
\AgdaBound{A}\<%
\end{code}
\end{fence}

Each constructor takes the parameter as an implicit argument. Thus, our
example list could also be written:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∷\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaDatatype{ℕ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∷\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaDatatype{ℕ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∷\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaDatatype{ℕ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaDatatype{ℕ}\AgdaSymbol{\})))}\<%
\end{code}
\end{fence}

where here we have provided the implicit parameters explicitly.

Including the pragma:

\begin{myDisplay}
{-# BUILTIN LIST List #-}
\end{myDisplay}

tells Agda that the type \texttt{List} corresponds to the Haskell type
list, and the constructors \texttt{{[}{]}} and \texttt{\_∷\_} correspond
to nil and cons respectively, allowing a more efficient representation
of lists.

\hypertarget{list-syntax}{%
\section{List syntax}\label{list-syntax}}

We can write lists more conveniently by introducing the following
definitions:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{pattern}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[\AgdaUnderscore{}]}}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
\>[0]\AgdaKeyword{pattern}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[\AgdaUnderscore{},\AgdaUnderscore{}]}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
\>[0]\AgdaKeyword{pattern}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[\AgdaUnderscore{},\AgdaUnderscore{},\AgdaUnderscore{}]}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
\>[0]\AgdaKeyword{pattern}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[\AgdaUnderscore{},\AgdaUnderscore{},\AgdaUnderscore{},\AgdaUnderscore{}]}}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
\>[0]\AgdaKeyword{pattern}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[\AgdaUnderscore{},\AgdaUnderscore{},\AgdaUnderscore{},\AgdaUnderscore{},\AgdaUnderscore{}]}}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
\>[0]\AgdaKeyword{pattern}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[\AgdaUnderscore{},\AgdaUnderscore{},\AgdaUnderscore{},\AgdaUnderscore{},\AgdaUnderscore{},\AgdaUnderscore{}]}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\end{code}
\end{fence}

This is our first use of pattern declarations. For instance, the third
line tells us that \texttt{{[}\ x\ ,\ y\ ,\ z\ {]}} is equivalent to
\texttt{x\ ∷\ y\ ∷\ z\ ∷\ {[}{]}}, and permits the former to appear
either in a pattern on the left-hand side of an equation, or a term on
the right-hand side of an equation.

\hypertarget{append}{%
\section{Append}\label{append}}

Our first function on lists is written \texttt{\_++\_} and pronounced
\emph{append}:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}++\AgdaUnderscore{}}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}++\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaInductiveConstructor{[]}%
\>[9]\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}%
\>[16]\AgdaSymbol{=}%
\>[19]\AgdaBound{ys}\<%
\\
\>[0]\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}%
\>[16]\AgdaSymbol{=}%
\>[19]\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

The type \texttt{A} is an implicit argument to append, making it a
\emph{polymorphic} function (one that can be used at many types). A list
appended to the empty list yields the list itself. A list appended to a
non-empty list yields a list with the head the same as the head of the
non-empty list, and a tail the same as the other list appended to tail
of the non-empty list.

Here is an example, showing how to compute the result of appending two
lists:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}%
\>[276I]\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[276I]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

Appending two lists requires time linear in the number of elements in
the first list.

\hypertarget{reasoning-about-append}{%
\section{Reasoning about append}\label{reasoning-about-append}}

We can reason about lists in much the same way that we reason about
numbers. Here is the proof that append is associative:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{++-assoc}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaBound{zs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{zs}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ys}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{zs}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{++-assoc}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaBound{zs}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{zs}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{ys}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{zs}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ys}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{zs}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\\
\>[0]\AgdaFunction{++-assoc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaBound{zs}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{zs}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{zs}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{zs}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{≡⟨}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{++-assoc}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaBound{zs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{⟩}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ys}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{zs}\AgdaSymbol{))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ys}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{zs}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

The proof is by induction on the first argument. The base case
instantiates to \texttt{{[}{]}}, and follows by straightforward
computation. The inductive case instantiates to \texttt{x\ ∷\ xs}, and
follows by straightforward computation combined with the inductive
hypothesis. As usual, the inductive hypothesis is indicated by a
recursive invocation of the proof, in this case
\texttt{++-assoc\ xs\ ys\ zs}.

Recall that Agda supports
\protect\hyperlink{Induction-sections}{sections}. Applying
\texttt{cong\ (x\ ∷\_)} promotes the inductive hypothesis:

\begin{myDisplay}
(xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)
\end{myDisplay}

to the equality:

\begin{myDisplay}
x ∷ ((xs ++ ys) ++ zs) ≡ x ∷ (xs ++ (ys ++ zs))
\end{myDisplay}

which is needed in the proof.

It is also easy to show that \texttt{{[}{]}} is a left and right
identity for \texttt{\_++\_}. That it is a left identity is immediate
from the definition:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{++-identityˡ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{xs}\<%
\\
\>[0]\AgdaFunction{++-identityˡ}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{xs}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{xs}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

That it is a right identity follows by simple induction:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{++-identityʳ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{xs}\<%
\\
\>[0]\AgdaFunction{++-identityʳ}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\\
\>[0]\AgdaFunction{++-identityʳ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{≡⟨}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{++-identityʳ}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{⟩}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

As we will see later, these three properties establish that
\texttt{\_++\_} and \texttt{{[}{]}} form a \emph{monoid} over lists.

\hypertarget{length}{%
\section{Length}\label{length}}

Our next function finds the length of a list:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{length}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
\>[0]\AgdaFunction{length}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}%
\>[17]\AgdaSymbol{=}%
\>[20]\AgdaInductiveConstructor{zero}\<%
\\
\>[0]\AgdaFunction{length}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}%
\>[17]\AgdaSymbol{=}%
\>[20]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{length}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

Again, it takes an implicit parameter \texttt{A}. The length of the
empty list is zero. The length of a non-empty list is one greater than
the length of the tail of the list.

Here is an example showing how to compute the length of a list:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{length}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaNumber{3}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}%
\>[500I]\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[500I]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{length}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{length}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{length}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{length}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaDatatype{ℕ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

Computing the length of a list requires time linear in the number of
elements in the list.

In the second-to-last line, we cannot write simply
\texttt{length\ {[}{]}} but must instead write
\texttt{length\ \{ℕ\}\ {[}{]}}. Since \texttt{{[}{]}} has no elements,
Agda has insufficient information to infer the implicit parameter.

\hypertarget{reasoning-about-length}{%
\section{Reasoning about length}\label{reasoning-about-length}}

The length of one list appended to another is the sum of the lengths of
the lists:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{length-++}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{length}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{length}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaFunction{length}\AgdaSpace{}%
\AgdaBound{ys}\<%
\\
\>[0]\AgdaFunction{length-++}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{length}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{length}\AgdaSpace{}%
\AgdaBound{ys}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{length}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaFunction{length}\AgdaSpace{}%
\AgdaBound{ys}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\\
\>[0]\AgdaFunction{length-++}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{length}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{length}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{))}\<%
\\
%
\>[2]\AgdaFunction{≡⟨}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{length-++}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{⟩}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{length}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaFunction{length}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{length}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaFunction{length}\AgdaSpace{}%
\AgdaBound{ys}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

The proof is by induction on the first argument. The base case
instantiates to \texttt{{[}{]}}, and follows by straightforward
computation. As before, Agda cannot infer the implicit type parameter to
\texttt{length}, and it must be given explicitly. The inductive case
instantiates to \texttt{x\ ∷\ xs}, and follows by straightforward
computation combined with the inductive hypothesis. As usual, the
inductive hypothesis is indicated by a recursive invocation of the
proof, in this case \texttt{length-++\ xs\ ys}, and it is promoted by
the congruence \texttt{cong\ suc}.

\hypertarget{reverse}{%
\section{Reverse}\label{reverse}}

Using append, it is easy to formulate a function to reverse a list:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}%
\>[18]\AgdaSymbol{=}%
\>[21]\AgdaInductiveConstructor{[]}\<%
\\
\>[0]\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}%
\>[18]\AgdaSymbol{=}%
\>[21]\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\end{code}
\end{fence}

The reverse of the empty list is the empty list. The reverse of a
non-empty list is the reverse of its tail appended to a unit list
containing its head.

Here is an example showing how to reverse a list:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}%
\>[628I]\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[628I]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{((}\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{((}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{((}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

Reversing a list in this way takes time \emph{quadratic} in the length
of the list. This is because reverse ends up appending lists of lengths
\texttt{1}, \texttt{2}, up to \texttt{n\ -\ 1}, where \texttt{n} is the
length of the list being reversed, append takes time linear in the
length of the first list, and the sum of the numbers up to
\texttt{n\ -\ 1} is \texttt{n\ *\ (n\ -\ 1)\ /\ 2}. (We will validate
that last fact in an exercise later in this chapter.)

\hypertarget{exercise-reverse--distrib-recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{reverse-++-distrib}
(recommended)}{Exercise reverse-++-distrib (recommended)}}\label{exercise-reverse--distrib-recommended}}

Show that the reverse of one list appended to another is the reverse of
the second appended to the reverse of the first:

\begin{myDisplay}
reverse (xs ++ ys) ≡ reverse ys ++ reverse xs
\end{myDisplay}

\hypertarget{exercise-reverse-involutive-recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{reverse-involutive}
(recommended)}{Exercise reverse-involutive (recommended)}}\label{exercise-reverse-involutive-recommended}}

A function is an \emph{involution} if when applied twice it acts as the
identity function. Show that reverse is an involution:

\begin{myDisplay}
reverse (reverse xs) ≡ xs
\end{myDisplay}

\hypertarget{faster-reverse}{%
\section{Faster reverse}\label{faster-reverse}}

The definition above, while easy to reason about, is less efficient than
one might expect since it takes time quadratic in the length of the
list. The idea is that we generalise reverse to take an additional
argument:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{shunt}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaFunction{shunt}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}%
\>[15]\AgdaBound{ys}%
\>[19]\AgdaSymbol{=}%
\>[22]\AgdaBound{ys}\<%
\\
\>[0]\AgdaFunction{shunt}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ys}%
\>[19]\AgdaSymbol{=}%
\>[22]\AgdaFunction{shunt}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

The definition is by recursion on the first argument. The second
argument actually becomes \emph{larger}, but this is not a problem
because the argument on which we recurse becomes \emph{smaller}.

Shunt is related to reverse as follows:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{shunt-reverse}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{shunt}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\<%
\\
\>[0]\AgdaFunction{shunt-reverse}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{shunt}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaBound{ys}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{ys}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\\
\>[0]\AgdaFunction{shunt-reverse}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{shunt}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ys}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{shunt}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{≡⟨}\AgdaSpace{}%
\AgdaFunction{shunt-reverse}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{⟩}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{≡⟨}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{++-assoc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{⟩}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

The proof is by induction on the first argument. The base case
instantiates to \texttt{{[}{]}}, and follows by straightforward
computation. The inductive case instantiates to \texttt{x\ ∷\ xs} and
follows by the inductive hypothesis and associativity of append. When we
invoke the inductive hypothesis, the second argument actually becomes
\emph{larger}, but this is not a problem because the argument on which
we induct becomes \emph{smaller}.

Generalising on an auxiliary argument, which becomes larger as the
argument on which we recurse or induct becomes smaller, is a common
trick. It belongs in your quiver of arrows, ready to slay the right
problem.

Having defined shunt be generalisation, it is now easy to respecialise
to give a more efficient definition of reverse:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{reverse′}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaFunction{reverse′}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{shunt}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\end{code}
\end{fence}

Given our previous lemma, it is straightforward to show the two
definitions equivalent:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{reverses}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{reverse′}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaBound{xs}\<%
\\
\>[0]\AgdaFunction{reverses}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{reverse′}\AgdaSpace{}%
\AgdaBound{xs}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{shunt}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaFunction{≡⟨}\AgdaSpace{}%
\AgdaFunction{shunt-reverse}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaFunction{⟩}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaFunction{≡⟨}\AgdaSpace{}%
\AgdaFunction{++-identityʳ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{⟩}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{reverse}\AgdaSpace{}%
\AgdaBound{xs}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

Here is an example showing fast reverse of the list
\texttt{{[}\ 0\ ,\ 1\ ,\ 2\ {]}}:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{reverse′}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}%
\>[914I]\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[914I]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{reverse′}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{shunt}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{shunt}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{shunt}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{shunt}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

Now the time to reverse a list is linear in the length of the list.

\hypertarget{Lists-Map}{%
\section{Map}\label{Lists-Map}}

Map applies a function to every element of a list to generate a
corresponding list. Map is an example of a \emph{higher-order function},
one which takes a function as an argument or returns a function as a
result:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{map}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
\>[0]\AgdaFunction{map}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}%
\>[16]\AgdaSymbol{=}%
\>[19]\AgdaInductiveConstructor{[]}\<%
\\
\>[0]\AgdaFunction{map}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}%
\>[16]\AgdaSymbol{=}%
\>[19]\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{xs}\<%
\end{code}
\end{fence}

Map of the empty list is the empty list. Map of a non-empty list yields
a list with head the same as the function applied to the head of the
given list, and tail the same as map of the function applied to the tail
of the given list.

Here is an example showing how to use map to increment every element of
a list:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}%
\>[1005I]\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[1005I]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{map}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

Map requires time linear in the length of the list.

It is often convenient to exploit currying by applying map to a function
to yield a new function, and at a later point applying the resulting
function:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{sucs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
\>[0]\AgdaFunction{sucs}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{sucs}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}%
\>[1085I]\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[1085I]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{sucs}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{map}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

Any type that is parameterised on another type, such as lists, has a
corresponding map, which accepts a function and returns a function from
the type parameterised on the domain of the function to the type
parameterised on the range of the function. Further, a type that is
parameterised on \emph{n} types will have a map that is parameterised on
\emph{n} functions.

\hypertarget{exercise-map-compose-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{map-compose}
(practice)}{Exercise map-compose (practice)}}\label{exercise-map-compose-practice}}

Prove that the map of a composition is equal to the composition of two
maps:

\begin{myDisplay}
map (g ∘ f) ≡ map g ∘ map f
\end{myDisplay}

The last step of the proof requires extensionality.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-map--distribute-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{map-++-distribute}
(practice)}{Exercise map-++-distribute (practice)}}\label{exercise-map--distribute-practice}}

Prove the following relationship between map and append:

\begin{myDisplay}
map f (xs ++ ys) ≡ map f xs ++ map f ys
\end{myDisplay}

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-map-tree-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{map-Tree}
(practice)}{Exercise map-Tree (practice)}}\label{exercise-map-tree-practice}}

Define a type of trees with leaves of type \texttt{A} and internal nodes
of type \texttt{B}:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Tree}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{leaf}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Tree}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
%
\>[2]\AgdaInductiveConstructor{node}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Tree}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Tree}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Tree}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\<%
\end{code}
\end{fence}

Define a suitable map operator over trees:

\begin{myDisplay}
map-Tree : ∀ {A B C D : Set} → (A → C) → (B → D) → Tree A B → Tree C D
\end{myDisplay}

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{Lists-Fold}{%
\section{Fold}\label{Lists-Fold}}

Fold takes an operator and a value, and uses the operator to combine
each of the elements of the list, taking the given value as the result
for the empty list:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
\>[0]\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}%
\>[22]\AgdaSymbol{=}%
\>[25]\AgdaBound{e}\<%
\\
\>[0]\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}%
\>[22]\AgdaSymbol{=}%
\>[25]\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{xs}\<%
\end{code}
\end{fence}

Fold of the empty list is the given value. Fold of a non-empty list uses
the operator to combine the head of the list and the fold of the tail of
the list.

Here is an example showing how to use fold to find the sum of a list:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaNumber{10}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}%
\>[1182I]\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[1182I]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSymbol{)))}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

Here we have an instance of \texttt{foldr} where \texttt{A} and
\texttt{B} are both \texttt{ℕ}. Fold requires time linear in the length
of the list.

It is often convenient to exploit currying by applying fold to an
operator and a value to yield a new function, and at a later point
applying the resulting function:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{sum}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
\>[0]\AgdaFunction{sum}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaNumber{0}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{sum}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaNumber{10}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}%
\>[1268I]\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[1268I]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{sum}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaNumber{10}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

Just as the list type has two constructors, \texttt{{[}{]}} and
\texttt{\_∷\_}, so the fold function takes two arguments, \texttt{e} and
\texttt{\_⊗\_} (in addition to the list argument). In general, a data
type with \emph{n} constructors will have a corresponding fold function
that takes \emph{n} arguments.

As another example, observe that

\begin{myDisplay}
foldr _∷_ [] xs ≡ xs
\end{myDisplay}

Here, if \texttt{xs} is of type \texttt{List\ A}, then we see we have an
instance of \texttt{foldr} where \texttt{A} is \texttt{A} and \texttt{B}
is \texttt{List\ A}. It follows that

\begin{myDisplay}
xs ++ ys ≡ foldr _∷_ ys xs
\end{myDisplay}

Demonstrating both these equations is left as an exercise.

\hypertarget{exercise-product-recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{product}
(recommended)}{Exercise product (recommended)}}\label{exercise-product-recommended}}

Use fold to define a function to find the product of a list of numbers.
For example:

\begin{myDisplay}
product [ 1 , 2 , 3 , 4 ] ≡ 24
\end{myDisplay}

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-foldr--recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{foldr-++}
(recommended)}{Exercise foldr-++ (recommended)}}\label{exercise-foldr--recommended}}

Show that fold and append are related as follows:

\begin{myDisplay}
foldr _⊗_ e (xs ++ ys) ≡ foldr _⊗_ (foldr _⊗_ e ys) xs
\end{myDisplay}

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-foldr--practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{foldr-∷}
(practice)}{Exercise foldr-∷ (practice)}}\label{exercise-foldr--practice}}

Show

\begin{myDisplay}
foldr _∷_ [] xs ≡ xs
\end{myDisplay}

Show as a consequence of \texttt{foldr-++} above that

\begin{myDisplay}
xs ++ ys ≡ foldr _∷_ ys xs
\end{myDisplay}

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-map-is-foldr-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{map-is-foldr}
(practice)}{Exercise map-is-foldr (practice)}}\label{exercise-map-is-foldr-practice}}

Show that map can be defined using fold:

\begin{myDisplay}
map f ≡ foldr (λ x xs → f x ∷ xs) []
\end{myDisplay}

The proof requires extensionality.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-fold-tree-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{fold-Tree}
(practice)}{Exercise fold-Tree (practice)}}\label{exercise-fold-tree-practice}}

Define a suitable fold function for the type of trees given earlier:

\begin{myDisplay}
fold-Tree : ∀ {A B C : Set} → (A → C) → (C → B → C → C) → Tree A B → C
\end{myDisplay}

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-map-is-fold-tree-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{map-is-fold-Tree}
(practice)}{Exercise map-is-fold-Tree (practice)}}\label{exercise-map-is-fold-tree-practice}}

Demonstrate an analogue of \texttt{map-is-foldr} for the type of trees.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-sum-downfrom-stretch}{%
\subsubsection{\texorpdfstring{Exercise \texttt{sum-downFrom}
(stretch)}{Exercise sum-downFrom (stretch)}}\label{exercise-sum-downfrom-stretch}}

Define a function that counts down as follows:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{downFrom}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
\>[0]\AgdaFunction{downFrom}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}%
\>[18]\AgdaSymbol{=}%
\>[21]\AgdaInductiveConstructor{[]}\<%
\\
\>[0]\AgdaFunction{downFrom}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}%
\>[18]\AgdaSymbol{=}%
\>[21]\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaFunction{downFrom}\AgdaSpace{}%
\AgdaBound{n}\<%
\end{code}
\end{fence}

For example:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{downFrom}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

Prove that the sum of the numbers \texttt{(n\ -\ 1)\ +\ ⋯\ +\ 0} is
equal to \texttt{n\ *\ (n\ ∸\ 1)\ /\ 2}:

\begin{myDisplay}
sum (downFrom n) * 2 ≡ n * (n ∸ 1)
\end{myDisplay}

\hypertarget{monoids}{%
\section{Monoids}\label{monoids}}

Typically when we use a fold the operator is associative and the value
is a left and right identity for the operator, meaning that the operator
and the value form a \emph{monoid}.

We can define a monoid as a suitable record type:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{IsMonoid}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{e}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{assoc}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaBound{z}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaField{identityˡ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\>[4]\AgdaField{identityʳ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{IsMonoid}\<%
\end{code}
\end{fence}

As examples, sum and zero, multiplication and one, and append and the
empty list, are all examples of monoids:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{+-monoid}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{IsMonoid}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaNumber{0}\<%
\\
\>[0]\AgdaFunction{+-monoid}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{record}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{assoc}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{+-assoc}\<%
\\
%
\>[4]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{identityˡ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{+-identityˡ}\<%
\\
%
\>[4]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{identityʳ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{+-identityʳ}\<%
\\
%
\>[4]\AgdaSymbol{\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{*-monoid}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{IsMonoid}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaNumber{1}\<%
\\
\>[0]\AgdaFunction{*-monoid}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{record}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{assoc}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{*-assoc}\<%
\\
%
\>[4]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{identityˡ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{*-identityˡ}\<%
\\
%
\>[4]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{identityʳ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{*-identityʳ}\<%
\\
%
\>[4]\AgdaSymbol{\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{++-monoid}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{IsMonoid}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}++\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
\>[0]\AgdaFunction{++-monoid}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{record}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{assoc}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{++-assoc}\<%
\\
%
\>[4]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{identityˡ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{++-identityˡ}\<%
\\
%
\>[4]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{identityʳ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{++-identityʳ}\<%
\\
%
\>[4]\AgdaSymbol{\}}\<%
\end{code}
\end{fence}

If \texttt{\_⊗\_} and \texttt{e} form a monoid, then we can re-express
fold on the same operator and an arbitrary value:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{foldr-monoid}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{e}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{IsMonoid}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
\>[0]\AgdaFunction{foldr-monoid}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{⊗-monoid}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{y}\<%
\\
%
\>[2]\AgdaFunction{≡⟨}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{identityˡ}\AgdaSpace{}%
\AgdaBound{⊗-monoid}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{⟩}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{e}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\\
\>[0]\AgdaFunction{foldr-monoid}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{⊗-monoid}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{≡⟨}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{foldr-monoid}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{⊗-monoid}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{⟩}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{≡⟨}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{assoc}\AgdaSpace{}%
\AgdaBound{⊗-monoid}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{⟩}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{≡⟨⟩}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

In a previous exercise we showed the following.

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{foldr-++}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{e}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{xs}\<%
\end{code}
\end{fence}

As a consequence, using a previous exercise, we have the following:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{foldr-monoid-++}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{e}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{IsMonoid}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{ys}\<%
\\
\>[0]\AgdaFunction{foldr-monoid-++}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{monoid-⊗}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{begin}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{≡⟨}\AgdaSpace{}%
\AgdaPostulate{foldr-++}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaFunction{⟩}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{xs}\<%
\\
%
\>[2]\AgdaFunction{≡⟨}\AgdaSpace{}%
\AgdaFunction{foldr-monoid}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{monoid-⊗}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{⟩}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⊗}}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaBound{ys}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{∎}}\<%
\end{code}
\end{fence}

\hypertarget{exercise-foldl-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{foldl}
(practice)}{Exercise foldl (practice)}}\label{exercise-foldl-practice}}

Define a function \texttt{foldl} which is analogous to \texttt{foldr},
but where operations associate to the left rather than the right. For
example:

\begin{myDisplay}
foldr _⊗_ e [ x , y , z ]  =  x ⊗ (y ⊗ (z ⊗ e))
foldl _⊗_ e [ x , y , z ]  =  ((e ⊗ x) ⊗ y) ⊗ z
\end{myDisplay}

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-foldr-monoid-foldl-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{foldr-monoid-foldl}
(practice)}{Exercise foldr-monoid-foldl (practice)}}\label{exercise-foldr-monoid-foldl-practice}}

Show that if \texttt{\_⊗\_} and \texttt{e} form a monoid, then
\texttt{foldr\ \_⊗\_\ e} and \texttt{foldl\ \_⊗\_\ e} always compute the
same result.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{Lists-All}{%
\section{All}\label{Lists-All}}

We can also define predicates over lists. Two of the most important are
\texttt{All} and \texttt{Any}.

Predicate \texttt{All\ P} holds if predicate \texttt{P} is satisfied by
every element of a list:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{All}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{[]}%
\>[6]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{All}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∷\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{All}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{All}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

The type has two constructors, reusing the names of the same
constructors for lists. The first asserts that \texttt{P} holds for
every element of the empty list. The second asserts that if \texttt{P}
holds of the head of a list and for every element of the tail of a list,
then \texttt{P} holds for every element of the list. Agda uses types to
disambiguate whether the constructor is building a list or evidence that
\texttt{All\ P} holds.

For example, \texttt{All\ (\_≤\ 2)} holds of a list where every element
is less than or equal to two. Recall that \texttt{z≤n} proves
\texttt{zero\ ≤\ n} for any \texttt{n}, and that if \texttt{m≤n} proves
\texttt{m\ ≤\ n} then \texttt{s≤s\ m≤n} proves
\texttt{suc\ m\ ≤\ suc\ n}, for any \texttt{m} and \texttt{n}:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{All}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≤}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\end{code}
\end{fence}

Here \texttt{\_∷\_} and \texttt{{[}{]}} are the constructors of
\texttt{All\ P} rather than of \texttt{List\ A}. The three items are
proofs of \texttt{0\ ≤\ 2}, \texttt{1\ ≤\ 2}, and \texttt{2\ ≤\ 2},
respectively.

(One might wonder whether a pattern such as \texttt{{[}\_,\_,\_{]}} can
be used to construct values of type \texttt{All} as well as type
\texttt{List}, since both use the same constructors. Indeed it can, so
long as both types are in scope when the pattern is declared. That's not
the case here, since \texttt{List} is defined before
\texttt{{[}\_,\_,\_{]}}, but \texttt{All} is defined later.)

\hypertarget{any}{%
\section{Any}\label{any}}

Predicate \texttt{Any\ P} holds if predicate \texttt{P} is satisfied by
some element of a list:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Any}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{here}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Any}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaInductiveConstructor{there}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Any}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Any}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

The first constructor provides evidence that the head of the list
satisfies \texttt{P}, while the second provides evidence that some
element of the tail of the list satisfies \texttt{P}. For example, we
can define list membership as follows:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∈\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∉\AgdaUnderscore{}}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∈\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∈}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{Any}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{xs}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∉\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∉}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{¬}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∈}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

For example, zero is an element of the list
\texttt{{[}\ 0\ ,\ 1\ ,\ 0\ ,\ 2\ {]}}. Indeed, we can demonstrate this
fact in two different ways, corresponding to the two different
occurrences of zero in the list, as the first element and as the third
element:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∈}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{here}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∈}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{there}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{there}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{here}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{))}\<%
\end{code}
\end{fence}

Further, we can demonstrate that three is not in the list, because any
possible proof that it is in the list leads to contradiction:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{not-in}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∉}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaFunction{not-in}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{here}\AgdaSpace{}%
\AgdaSymbol{())}\<%
\\
\>[0]\AgdaFunction{not-in}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{there}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{here}\AgdaSpace{}%
\AgdaSymbol{()))}\<%
\\
\>[0]\AgdaFunction{not-in}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{there}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{there}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{here}\AgdaSpace{}%
\AgdaSymbol{())))}\<%
\\
\>[0]\AgdaFunction{not-in}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{there}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{there}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{there}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{here}\AgdaSpace{}%
\AgdaSymbol{()))))}\<%
\\
\>[0]\AgdaFunction{not-in}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{there}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{there}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{there}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{there}\AgdaSpace{}%
\AgdaSymbol{()))))}\<%
\end{code}
\end{fence}

The five occurrences of \texttt{()} attest to the fact that there is no
possible evidence for \texttt{3\ ≡\ 0}, \texttt{3\ ≡\ 1},
\texttt{3\ ≡\ 0}, \texttt{3\ ≡\ 2}, and \texttt{3\ ∈\ {[}{]}},
respectively.

\hypertarget{all-and-append}{%
\section{All and append}\label{all-and-append}}

A predicate holds for every element of one list appended to another if
and only if it holds for every element of both lists:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{All-++-⇔}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaDatatype{All}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaRecord{⇔}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{All}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaDatatype{All}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{All-++-⇔}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{record}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{to}%
\>[15]\AgdaSymbol{=}%
\>[18]\AgdaFunction{to}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\<%
\\
%
\>[4]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{from}%
\>[15]\AgdaSymbol{=}%
\>[18]\AgdaFunction{from}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\<%
\\
%
\>[4]\AgdaSymbol{\}}\<%
\\
%
\>[2]\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{to}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaDatatype{All}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{All}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaDatatype{All}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{to}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaBound{Pys}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{Pys}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\<%
\\
%
\>[2]\AgdaFunction{to}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Px}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{Pxs++ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{to}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaBound{Pxs++ys}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{Pxs}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{Pys}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{Px}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{Pxs}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{Pys}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{from}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaDatatype{All}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaDatatype{All}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{All}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{from}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{Pys}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{Pys}\<%
\\
%
\>[2]\AgdaFunction{from}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{Px}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{Pxs}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{Pys}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[41]\AgdaBound{Px}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaFunction{from}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨}}\AgdaSpace{}%
\AgdaBound{Pxs}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{Pys}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟩}}\<%
\end{code}
\end{fence}

\hypertarget{exercise-any---recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{Any-++-⇔}
(recommended)}{Exercise Any-++-⇔ (recommended)}}\label{exercise-any---recommended}}

Prove a result similar to \texttt{All-++-⇔}, but with \texttt{Any} in
place of \texttt{All}, and a suitable replacement for \texttt{\_×\_}. As
a consequence, demonstrate an equivalence relating \texttt{\_∈\_} and
\texttt{\_++\_}.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-all---stretch}{%
\subsubsection{\texorpdfstring{Exercise \texttt{All-++-≃}
(stretch)}{Exercise All-++-≃ (stretch)}}\label{exercise-all---stretch}}

Show that the equivalence \texttt{All-++-⇔} can be extended to an
isomorphism.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-anyall-recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{¬Any⇔All¬}
(recommended)}{Exercise ¬Any⇔All¬ (recommended)}}\label{exercise-anyall-recommended}}

Show that \texttt{Any} and \texttt{All} satisfy a version of De Morgan's
Law:

\begin{myDisplay}
(¬_ ∘ Any P) xs ⇔ All (¬_ ∘ P) xs
\end{myDisplay}

(Can you see why it is important that here \texttt{\_∘\_} is generalised
to arbitrary levels, as described in the section on
\protect\hyperlink{Equality-unipoly}{universe polymorphism}?)

Do we also have the following?

\begin{myDisplay}
(¬_ ∘ All P) xs ⇔ Any (¬_ ∘ P) xs
\end{myDisplay}

If so, prove; if not, explain why.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-anyall-stretch}{%
\subsubsection{\texorpdfstring{Exercise \texttt{¬Any≃All¬}
(stretch)}{Exercise ¬Any≃All¬ (stretch)}}\label{exercise-anyall-stretch}}

Show that the equivalence \texttt{¬Any⇔All¬} can be extended to an
isomorphism. You will need to use extensionality.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-all--practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{All-∀}
(practice)}{Exercise All-∀ (practice)}}\label{exercise-all--practice}}

Show that \texttt{All\ P\ xs} is isomorphic to
\texttt{∀\ \{x\}\ →\ x\ ∈\ xs\ →\ P\ x}.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- You code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-any--practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{Any-∃}
(practice)}{Exercise Any-∃ (practice)}}\label{exercise-any--practice}}

Show that \texttt{Any\ P\ xs} is isomorphic to
\texttt{∃{[}\ x\ {]}\ (x\ ∈\ xs\ ×\ P\ x)}.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- You code goes here}\<%
\end{code}
\end{fence}

\hypertarget{decidability-of-all}{%
\section{Decidability of All}\label{decidability-of-all}}

If we consider a predicate as a function that yields a boolean, it is
easy to define an analogue of \texttt{All}, which returns true if a
given predicate returns true for every element of a list:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{all}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bool}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Bool}\<%
\\
\>[0]\AgdaFunction{all}\AgdaSpace{}%
\AgdaBound{p}%
\>[7]\AgdaSymbol{=}%
\>[10]\AgdaFunction{foldr}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∧\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaBound{p}\<%
\end{code}
\end{fence}

The function can be written in a particularly compact style by using the
higher-order functions \texttt{map} and \texttt{foldr}.

As one would hope, if we replace booleans by decidables there is again
an analogue of \texttt{All}. First, return to the notion of a predicate
\texttt{P} as a function of type \texttt{A\ →\ Set}, taking a value
\texttt{x} of type \texttt{A} into evidence \texttt{P\ x} that a
property holds for \texttt{x}. Say that a predicate \texttt{P} is
\emph{decidable} if we have a function that for a given \texttt{x} can
decide \texttt{P\ x}:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{Decidable}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaFunction{Decidable}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{P}%
\>[17]\AgdaSymbol{=}%
\>[20]\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

Then if predicate \texttt{P} is decidable, it is also decidable whether
every element of a list satisfies the predicate:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{All?}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Decidable}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Decidable}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{All}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{All?}\AgdaSpace{}%
\AgdaBound{P?}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}%
\>[43]\AgdaSymbol{=}%
\>[46]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
\>[0]\AgdaFunction{All?}\AgdaSpace{}%
\AgdaBound{P?}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaBound{P?}\AgdaSpace{}%
\AgdaBound{x}%
\>[29]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaFunction{All?}\AgdaSpace{}%
\AgdaBound{P?}\AgdaSpace{}%
\AgdaBound{xs}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[20]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{Px}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaBound{Pxs}%
\>[43]\AgdaSymbol{=}%
\>[46]\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Px}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{Pxs}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[20]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬Px}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}%
\>[43]\AgdaSymbol{=}%
\>[46]\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Px}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{Pxs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬Px}\AgdaSpace{}%
\AgdaBound{Px}%
\>[74]\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaCatchallClause{\AgdaSymbol{...}}%
\>[20]\AgdaCatchallClause{\AgdaSymbol{|}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaSymbol{\AgdaUnderscore{}}}%
\>[29]\AgdaCatchallClause{\AgdaSymbol{|}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaInductiveConstructor{no}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaBound{¬Pxs}}%
\>[43]\AgdaSymbol{=}%
\>[46]\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Px}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{Pxs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬Pxs}\AgdaSpace{}%
\AgdaBound{Pxs}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}
\end{fence}

If the list is empty, then trivially \texttt{P} holds for every element
of the list. Otherwise, the structure of the proof is similar to that
showing that the conjunction of two decidable propositions is itself
decidable, using \texttt{\_∷\_} rather than \texttt{⟨\_,\_⟩} to combine
the evidence for the head and tail of the list.

\hypertarget{exercise-any-stretch}{%
\subsubsection{\texorpdfstring{Exercise \texttt{Any?}
(stretch)}{Exercise Any? (stretch)}}\label{exercise-any-stretch}}

Just as \texttt{All} has analogues \texttt{all} and \texttt{All?} which
determine whether a predicate holds for every element of a list, so does
\texttt{Any} have analogues \texttt{any} and \texttt{Any?} which
determine whether a predicate holds for some element of a list. Give
their definitions.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{exercise-split-stretch}{%
\subsubsection{\texorpdfstring{Exercise \texttt{split}
(stretch)}{Exercise split (stretch)}}\label{exercise-split-stretch}}

The relation \texttt{merge} holds when two lists merge to give a third
list.

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{merge}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaBound{zs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{[]}%
\>[2151I]\AgdaSymbol{:}\<%
\\
\>[2151I][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaComment{--------------}\<%
\\
%
\>[6]\AgdaDatatype{merge}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{left-∷}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaBound{zs}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}%
\>[2161I]\AgdaDatatype{merge}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaBound{zs}\<%
\\
\>[.][@{}l@{}]\<[2161I]%
\>[6]\AgdaComment{--------------------------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{merge}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{zs}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{right-∷}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaBound{zs}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}%
\>[2179I]\AgdaDatatype{merge}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSpace{}%
\AgdaBound{zs}\<%
\\
\>[.][@{}l@{}]\<[2179I]%
\>[6]\AgdaComment{--------------------------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{merge}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{ys}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{zs}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

For example,

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{merge}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{left-∷}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right-∷}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right-∷}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{left-∷}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)))}\<%
\\
\>[0]\<%
\end{code}
\end{fence}

Given a decidable predicate and a list, we can split the list into two
lists that merge to give the original list, where all elements of one
list satisfy the predicate, and all elements of the other do not satisfy
the predicate.

Define the following variant of the traditional \texttt{filter} function
on lists, which given a decidable predicate and a list returns a list of
elements that satisfy the predicate and a list of elements that don't,
with their corresponding proofs.

\begin{myDisplay}
split : ∀ {A : Set} {P : A → Set} (P? : Decidable P) (zs : List A)
  → ∃[ xs ] ∃[ ys ] ( merge xs ys zs × All P xs × All (¬_ ∘ P) ys )
\end{myDisplay}

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{standard-library}{%
\section{Standard Library}\label{standard-library}}

Definitions similar to those in this chapter can be found in the
standard library:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.List}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{List}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}++\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{length}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{reverse}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{foldr}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{downFrom}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.List.Relation.Unary.All}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{All}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∷\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.List.Relation.Unary.Any}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{Any}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{here}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{there}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.List.Membership.Propositional}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∈\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.List.Properties}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reverse-++-commute}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{map-compose}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{map-++-commute}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{foldr-++}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{mapIsFold}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaFunction{map-is-foldr}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Algebra.Structures}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{IsMonoid}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Unary}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Decidable}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Decidable}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

The standard library version of \texttt{IsMonoid} differs from the one
given here, in that it is also parameterised on an equivalence relation.

Both \texttt{Relation.Unary} and \texttt{Relation.Binary} define a
version of \texttt{Decidable}, one for unary relations (as used in this
chapter where \texttt{P} ranges over unary predicates) and one for
binary relations (as used earlier, where \texttt{\_≤\_} ranges over a
binary relation).

\hypertarget{unicode}{%
\section{Unicode}\label{unicode}}

This chapter uses the following unicode:

\begin{myDisplay}
∷  U+2237  PROPORTION  (\::)
⊗  U+2297  CIRCLED TIMES  (\otimes, \ox)
∈  U+2208  ELEMENT OF  (\in)
∉  U+2209  NOT AN ELEMENT OF  (\inn, \notin)
\end{myDisplay}

