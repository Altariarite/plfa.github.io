\hypertarget{Relations}{%
\chapter{Relations: Inductive definition of relations}\label{Relations}}

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{plfa.part1.Relations}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\end{code}
\end{fence}

After having defined operations such as addition and multiplication, the
next step is to define relations, such as \emph{less than or equal}.

\hypertarget{imports}{%
\section{Imports}\label{imports}}

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary.PropositionalEquality}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Eq}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Eq}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{ℕ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat.Properties}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{+-comm}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{+-identityʳ}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

\hypertarget{defining-relations}{%
\section{Defining relations}\label{defining-relations}}

The relation \emph{less than or equal} has an infinite number of
instances. Here are a few of them:

\begin{myDisplay}
0 ≤ 0     0 ≤ 1     0 ≤ 2     0 ≤ 3     ...
          1 ≤ 1     1 ≤ 2     1 ≤ 3     ...
                    2 ≤ 2     2 ≤ 3     ...
                              3 ≤ 3     ...
                                        ...
\end{myDisplay}

And yet, we can write a finite definition that encompasses all of these
instances in just a few lines. Here is the definition as a pair of
inference rules:

\begin{myDisplay}
z≤n --------
    zero ≤ n

    m ≤ n
s≤s -------------
    suc m ≤ suc n
\end{myDisplay}

And here is the definition in Agda:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≤\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{z≤n}%
\>[30I]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[30I]%
\>[6]\AgdaComment{--------}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}%
\>[44I]\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[.][@{}l@{}]\<[44I]%
\>[6]\AgdaComment{-------------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\<%
\end{code}
\end{fence}

Here \texttt{z≤n} and \texttt{s≤s} (with no spaces) are constructor
names, while \texttt{zero\ ≤\ n}, and \texttt{m\ ≤\ n} and
\texttt{suc\ m\ ≤\ suc\ n} (with spaces) are types. This is our first
use of an \emph{indexed} datatype, where the type \texttt{m\ ≤\ n} is
indexed by two naturals, \texttt{m} and \texttt{n}. In Agda any line
beginning with two or more dashes is a comment, and here we have
exploited that convention to write our Agda code in a form that
resembles the corresponding inference rules, a trick we will use often
from now on.

Both definitions above tell us the same two things:

\begin{itemize}
\tightlist
\item
  \emph{Base case}: for all naturals \texttt{n}, the proposition
  \texttt{zero\ ≤\ n} holds.
\item
  \emph{Inductive case}: for all naturals \texttt{m} and \texttt{n}, if
  the proposition \texttt{m\ ≤\ n} holds, then the proposition
  \texttt{suc\ m\ ≤\ suc\ n} holds.
\end{itemize}

In fact, they each give us a bit more detail:

\begin{itemize}
\tightlist
\item
  \emph{Base case}: for all naturals \texttt{n}, the constructor
  \texttt{z≤n} produces evidence that \texttt{zero\ ≤\ n} holds.
\item
  \emph{Inductive case}: for all naturals \texttt{m} and \texttt{n}, the
  constructor \texttt{s≤s} takes evidence that \texttt{m\ ≤\ n} holds
  into evidence that \texttt{suc\ m\ ≤\ suc\ n} holds.
\end{itemize}

For example, here in inference rule notation is the proof that
\texttt{2\ ≤\ 4}:

\begin{myDisplay}
  z≤n -----
      0 ≤ 2
 s≤s -------
      1 ≤ 3
s≤s ---------
      2 ≤ 4
\end{myDisplay}

And here is the corresponding Agda proof:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaNumber{4}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

\hypertarget{implicit-arguments}{%
\section{Implicit arguments}\label{implicit-arguments}}

This is our first use of implicit arguments. In the definition of
inequality, the two lines defining the constructors use \texttt{∀}, very
similar to our use of \texttt{∀} in propositions such as:

\begin{myDisplay}
+-comm : ∀ (m n : ℕ) → m + n ≡ n + m
\end{myDisplay}

However, here the declarations are surrounded by curly braces
\texttt{\{\ \}} rather than parentheses \texttt{(\ )}. This means that
the arguments are \emph{implicit} and need not be written explicitly;
instead, they are \emph{inferred} by Agda's typechecker. Thus, we write
\texttt{+-comm\ m\ n} for the proof that \texttt{m\ +\ n\ ≡\ n\ +\ m},
but \texttt{z≤n} for the proof that \texttt{zero\ ≤\ n}, leaving
\texttt{n} implicit. Similarly, if \texttt{m≤n} is evidence that
\texttt{m\ ≤\ n}, we write \texttt{s≤s\ m≤n} for evidence that
\texttt{suc\ m\ ≤\ suc\ n}, leaving both \texttt{m} and \texttt{n}
implicit.

If we wish, it is possible to provide implicit arguments explicitly by
writing the arguments inside curly braces. For instance, here is the
Agda proof that \texttt{2\ ≤\ 4} repeated, with the implicit arguments
made explicit:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaNumber{4}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaNumber{1}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaNumber{3}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaNumber{0}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaNumber{2}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{z≤n}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaNumber{2}\AgdaSymbol{\}))}\<%
\end{code}
\end{fence}

One may also identify implicit arguments by name:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaNumber{4}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{m}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{m}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{z≤n}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSymbol{\}))}\<%
\end{code}
\end{fence}

In the latter format, you can choose to only supply some implicit
arguments:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaNumber{4}\<%
\\
\>[0]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaNumber{3}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

It is not permitted to swap implicit arguments, even when named.

We can ask Agda to use the same inference to try and infer an
\emph{explicit} term, by writing \texttt{\_}. For instance, we can
define a variant of the proposition \texttt{+-identityʳ} with implicit
arguments:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{+-identityʳ′}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{m}\<%
\\
\>[0]\AgdaFunction{+-identityʳ′}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{+-identityʳ}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\end{code}
\end{fence}

We use \texttt{\_} to ask Agda to infer the value of the \emph{explicit}
argument from context. There is only one value which gives us the
correct proof, \texttt{m}, so Agda happily fills it in. If Agda fails to
infer the value, it reports an error.

\hypertarget{precedence}{%
\section{Precedence}\label{precedence}}

We declare the precedence for comparison as follows:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≤\AgdaUnderscore{}}}\<%
\end{code}
\end{fence}

We set the precedence of \texttt{\_≤\_} at level 4, so it binds less
tightly than \texttt{\_+\_} at level 6 and hence \texttt{1\ +\ 2\ ≤\ 3}
parses as \texttt{(1\ +\ 2)\ ≤\ 3}. We write \texttt{infix} to indicate
that the operator does not associate to either the left or right, as it
makes no sense to parse \texttt{1\ ≤\ 2\ ≤\ 3} as either
\texttt{(1\ ≤\ 2)\ ≤\ 3} or \texttt{1\ ≤\ (2\ ≤\ 3)}.

\hypertarget{decidability}{%
\section{Decidability}\label{decidability}}

Given two numbers, it is straightforward to compute whether or not the
first is less than or equal to the second. We don't give the code for
doing so here, but will return to this point in Chapter
\protect\hyperlink{Decidable}{Decidable}.

\hypertarget{inversion}{%
\section{Inversion}\label{inversion}}

In our definitions, we go from smaller things to larger things. For
instance, from \texttt{m\ ≤\ n} we can conclude
\texttt{suc\ m\ ≤\ suc\ n}, where \texttt{suc\ m} is bigger than
\texttt{m} (that is, the former contains the latter), and
\texttt{suc\ n} is bigger than \texttt{n}. But sometimes we want to go
from bigger things to smaller things.

There is only one way to prove that \texttt{suc\ m\ ≤\ suc\ n}, for any
\texttt{m} and \texttt{n}. This lets us invert our previous rule.

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{inv-s≤s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}%
\>[132I]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[.][@{}l@{}]\<[132I]%
\>[4]\AgdaComment{-------------}\<%
\\
%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[0]\AgdaFunction{inv-s≤s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{m≤n}\<%
\end{code}
\end{fence}

Here \texttt{m≤n} (with no spaces) is a variable name while
\texttt{m\ ≤\ n} (with spaces) is a type, and the latter is the type of
the former. It is a common convention in Agda to derive a variable name
by removing spaces from its type.

Not every rule is invertible; indeed, the rule for \texttt{z≤n} has no
non-implicit hypotheses, so there is nothing to invert. But often
inversions of this kind hold.

Another example of inversion is showing that there is only one way a
number can be less than or equal to zero.

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{inv-z≤n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}%
\>[149I]\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\<%
\\
\>[.][@{}l@{}]\<[149I]%
\>[4]\AgdaComment{--------}\<%
\\
%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\<%
\\
\>[0]\AgdaFunction{inv-z≤n}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{fence}

\hypertarget{properties-of-ordering-relations}{%
\section{Properties of ordering
relations}\label{properties-of-ordering-relations}}

Relations pop up all the time, and mathematicians have agreed on names
for some of the most common properties.

\begin{itemize}
\tightlist
\item
  \emph{Reflexive}. For all \texttt{n}, the relation \texttt{n\ ≤\ n}
  holds.
\item
  \emph{Transitive}. For all \texttt{m}, \texttt{n}, and \texttt{p}, if
  \texttt{m\ ≤\ n} and \texttt{n\ ≤\ p} hold, then \texttt{m\ ≤\ p}
  holds.
\item
  \emph{Anti-symmetric}. For all \texttt{m} and \texttt{n}, if both
  \texttt{m\ ≤\ n} and \texttt{n\ ≤\ m} hold, then \texttt{m\ ≡\ n}
  holds.
\item
  \emph{Total}. For all \texttt{m} and \texttt{n}, either
  \texttt{m\ ≤\ n} or \texttt{n\ ≤\ m} holds.
\end{itemize}

The relation \texttt{\_≤\_} satisfies all four of these properties.

There are also names for some combinations of these properties.

\begin{itemize}
\tightlist
\item
  \emph{Preorder}. Any relation that is reflexive and transitive.
\item
  \emph{Partial order}. Any preorder that is also anti-symmetric.
\item
  \emph{Total order}. Any partial order that is also total.
\end{itemize}

If you ever bump into a relation at a party, you now know how to make
small talk, by asking it whether it is reflexive, transitive,
anti-symmetric, and total. Or instead you might ask whether it is a
preorder, partial order, or total order.

Less frivolously, if you ever bump into a relation while reading a
technical paper, this gives you a way to orient yourself, by checking
whether or not it is a preorder, partial order, or total order. A
careful author will often call out these properties---or their
lack---for instance by saying that a newly introduced relation is a
partial order but not a total order.

\hypertarget{Relations-orderings}{%
\subsubsection{\texorpdfstring{Exercise \texttt{orderings}
(practice)}{Exercise orderings (practice)}}\label{Relations-orderings}}

Give an example of a preorder that is not a partial order.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

Give an example of a partial order that is not a total order.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{reflexivity}{%
\section{Reflexivity}\label{reflexivity}}

The first property to prove about comparison is that it is reflexive:
for any natural \texttt{n}, the relation \texttt{n\ ≤\ n} holds. We
follow the convention in the standard library and make the argument
implicit, as that will make it easier to invoke reflexivity:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{≤-refl}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaComment{-----}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[0]\AgdaFunction{≤-refl}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{zero}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\<%
\\
\>[0]\AgdaFunction{≤-refl}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaFunction{≤-refl}\<%
\end{code}
\end{fence}

The proof is a straightforward induction on the implicit argument
\texttt{n}. In the base case, \texttt{zero\ ≤\ zero} holds by
\texttt{z≤n}. In the inductive case, the inductive hypothesis
\texttt{≤-refl\ \{n\}} gives us a proof of \texttt{n\ ≤\ n}, and
applying \texttt{s≤s} to that yields a proof of
\texttt{suc\ n\ ≤\ suc\ n}.

It is a good exercise to prove reflexivity interactively in Emacs, using
holes and the \texttt{C-c\ C-c}, \texttt{C-c\ C-,}, and
\texttt{C-c\ C-r} commands.

\hypertarget{transitivity}{%
\section{Transitivity}\label{transitivity}}

The second property to prove about comparison is that it is transitive:
for any naturals \texttt{m}, \texttt{n}, and \texttt{p}, if
\texttt{m\ ≤\ n} and \texttt{n\ ≤\ p} hold, then \texttt{m\ ≤\ p} holds.
Again, \texttt{m}, \texttt{n}, and \texttt{p} are implicit:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{≤-trans}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
%
\>[2]\AgdaSymbol{→}%
\>[184I]\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{p}\<%
\\
\>[.][@{}l@{}]\<[184I]%
\>[4]\AgdaComment{-----}\<%
\\
%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{p}\<%
\\
\>[0]\AgdaFunction{≤-trans}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}%
\>[18]\AgdaSymbol{\AgdaUnderscore{}}%
\>[29]\AgdaSymbol{=}%
\>[32]\AgdaInductiveConstructor{z≤n}\<%
\\
\>[0]\AgdaFunction{≤-trans}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{n≤p}\AgdaSymbol{)}%
\>[29]\AgdaSymbol{=}%
\>[32]\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{≤-trans}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSpace{}%
\AgdaBound{n≤p}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

Here the proof is by induction on the \emph{evidence} that
\texttt{m\ ≤\ n}. In the base case, the first inequality holds by
\texttt{z≤n} and must show \texttt{zero\ ≤\ p}, which follows
immediately by \texttt{z≤n}. In this case, the fact that
\texttt{n\ ≤\ p} is irrelevant, and we write \texttt{\_} as the pattern
to indicate that the corresponding evidence is unused.

In the inductive case, the first inequality holds by \texttt{s≤s\ m≤n}
and the second inequality by \texttt{s≤s\ n≤p}, and so we are given
\texttt{suc\ m\ ≤\ suc\ n} and \texttt{suc\ n\ ≤\ suc\ p}, and must show
\texttt{suc\ m\ ≤\ suc\ p}. The inductive hypothesis
\texttt{≤-trans\ m≤n\ n≤p} establishes that \texttt{m\ ≤\ p}, and our
goal follows by applying \texttt{s≤s}.

The case \texttt{≤-trans\ (s≤s\ m≤n)\ z≤n} cannot arise, since the first
inequality implies the middle value is \texttt{suc\ n} while the second
inequality implies that it is \texttt{zero}. Agda can determine that
such a case cannot arise, and does not require (or permit) it to be
listed.

Alternatively, we could make the implicit parameters explicit:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{≤-trans′}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
%
\>[2]\AgdaSymbol{→}%
\>[208I]\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{p}\<%
\\
\>[.][@{}l@{}]\<[208I]%
\>[4]\AgdaComment{-----}\<%
\\
%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{p}\<%
\\
\>[0]\AgdaFunction{≤-trans′}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}%
\>[17]\AgdaSymbol{\AgdaUnderscore{}}%
\>[25]\AgdaSymbol{\AgdaUnderscore{}}%
\>[33]\AgdaInductiveConstructor{z≤n}%
\>[43]\AgdaSymbol{\AgdaUnderscore{}}%
\>[54]\AgdaSymbol{=}%
\>[57]\AgdaInductiveConstructor{z≤n}\<%
\\
\>[0]\AgdaFunction{≤-trans′}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{n≤p}\AgdaSymbol{)}%
\>[54]\AgdaSymbol{=}%
\>[57]\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{≤-trans′}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSpace{}%
\AgdaBound{n≤p}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

One might argue that this is clearer or one might argue that the extra
length obscures the essence of the proof. We will usually opt for
shorter proofs.

The technique of induction on evidence that a property holds (e.g.,
inducting on evidence that \texttt{m\ ≤\ n})---rather than induction on
values of which the property holds (e.g., inducting on
\texttt{m})---will turn out to be immensely valuable, and one that we
use often.

Again, it is a good exercise to prove transitivity interactively in
Emacs, using holes and the \texttt{C-c\ C-c}, \texttt{C-c\ C-,}, and
\texttt{C-c\ C-r} commands.

\hypertarget{anti-symmetry}{%
\section{Anti-symmetry}\label{anti-symmetry}}

The third property to prove about comparison is that it is
antisymmetric: for all naturals \texttt{m} and \texttt{n}, if both
\texttt{m\ ≤\ n} and \texttt{n\ ≤\ m} hold, then \texttt{m\ ≡\ n} holds:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{≤-antisym}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
%
\>[2]\AgdaSymbol{→}%
\>[240I]\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{m}\<%
\\
\>[.][@{}l@{}]\<[240I]%
\>[4]\AgdaComment{-----}\<%
\\
%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[0]\AgdaFunction{≤-antisym}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}%
\>[20]\AgdaInductiveConstructor{z≤n}%
\>[31]\AgdaSymbol{=}%
\>[34]\AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaFunction{≤-antisym}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{n≤m}\AgdaSymbol{)}%
\>[31]\AgdaSymbol{=}%
\>[34]\AgdaFunction{cong}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{≤-antisym}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSpace{}%
\AgdaBound{n≤m}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

Again, the proof is by induction over the evidence that \texttt{m\ ≤\ n}
and \texttt{n\ ≤\ m} hold.

In the base case, both inequalities hold by \texttt{z≤n}, and so we are
given \texttt{zero\ ≤\ zero} and \texttt{zero\ ≤\ zero} and must show
\texttt{zero\ ≡\ zero}, which follows by reflexivity. (Reflexivity of
equality, that is, not reflexivity of inequality.)

In the inductive case, the first inequality holds by \texttt{s≤s\ m≤n}
and the second inequality holds by \texttt{s≤s\ n≤m}, and so we are
given \texttt{suc\ m\ ≤\ suc\ n} and \texttt{suc\ n\ ≤\ suc\ m} and must
show \texttt{suc\ m\ ≡\ suc\ n}. The inductive hypothesis
\texttt{≤-antisym\ m≤n\ n≤m} establishes that \texttt{m\ ≡\ n}, and our
goal follows by congruence.

\hypertarget{Relations-leq-antisym-cases}{%
\subsubsection{\texorpdfstring{Exercise \texttt{≤-antisym-cases}
(practice)}{Exercise ≤-antisym-cases (practice)}}\label{Relations-leq-antisym-cases}}

The above proof omits cases where one argument is \texttt{z≤n} and one
argument is \texttt{s≤s}. Why is it ok to omit them?

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{total}{%
\section{Total}\label{total}}

The fourth property to prove about comparison is that it is total: for
any naturals \texttt{m} and \texttt{n} either \texttt{m\ ≤\ n} or
\texttt{n\ ≤\ m}, or both if \texttt{m} and \texttt{n} are equal.

We specify what it means for inequality to be total:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Total}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{forward}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
%
\>[6]\AgdaComment{---------}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Total}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{flipped}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{m}\<%
\\
%
\>[6]\AgdaComment{---------}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Total}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\<%
\end{code}
\end{fence}

Evidence that \texttt{Total\ m\ n} holds is either of the form
\texttt{forward\ m≤n} or \texttt{flipped\ n≤m}, where \texttt{m≤n} and
\texttt{n≤m} are evidence of \texttt{m\ ≤\ n} and \texttt{n\ ≤\ m}
respectively.

(For those familiar with logic, the above definition could also be
written as a disjunction. Disjunctions will be introduced in Chapter
\protect\hyperlink{Connectives}{Connectives}.)

This is our first use of a datatype with \emph{parameters}, in this case
\texttt{m} and \texttt{n}. It is equivalent to the following indexed
datatype:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Total′}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{forward′}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}%
\>[289I]\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[.][@{}l@{}]\<[289I]%
\>[6]\AgdaComment{----------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Total′}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{flipped′}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}%
\>[301I]\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{m}\<%
\\
\>[.][@{}l@{}]\<[301I]%
\>[6]\AgdaComment{----------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Total′}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\<%
\end{code}
\end{fence}

Each parameter of the type translates as an implicit parameter of each
constructor. Unlike an indexed datatype, where the indexes can vary (as
in \texttt{zero\ ≤\ n} and \texttt{suc\ m\ ≤\ suc\ n}), in a
parameterised datatype the parameters must always be the same (as in
\texttt{Total\ m\ n}). Parameterised declarations are shorter, easier to
read, and occasionally aid Agda's termination checker, so we will use
them in preference to indexed types when possible.

With that preliminary out of the way, we specify and prove totality:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{≤-total}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Total}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[0]\AgdaFunction{≤-total}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}%
\>[16]\AgdaBound{n}%
\>[42]\AgdaSymbol{=}%
\>[45]\AgdaInductiveConstructor{forward}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\<%
\\
\>[0]\AgdaFunction{≤-total}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}%
\>[42]\AgdaSymbol{=}%
\>[45]\AgdaInductiveConstructor{flipped}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\<%
\\
\>[0]\AgdaFunction{≤-total}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{≤-total}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[27]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{forward}\AgdaSpace{}%
\AgdaBound{m≤n}%
\>[42]\AgdaSymbol{=}%
\>[45]\AgdaInductiveConstructor{forward}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[27]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{flipped}\AgdaSpace{}%
\AgdaBound{n≤m}%
\>[42]\AgdaSymbol{=}%
\>[45]\AgdaInductiveConstructor{flipped}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{n≤m}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

In this case the proof is by induction over both the first and second
arguments. We perform a case analysis:

\begin{itemize}
\item
  \emph{First base case}: If the first argument is \texttt{zero} and the
  second argument is \texttt{n} then the forward case holds, with
  \texttt{z≤n} as evidence that \texttt{zero\ ≤\ n}.
\item
  \emph{Second base case}: If the first argument is \texttt{suc\ m} and
  the second argument is \texttt{zero} then the flipped case holds, with
  \texttt{z≤n} as evidence that \texttt{zero\ ≤\ suc\ m}.
\item
  \emph{Inductive case}: If the first argument is \texttt{suc\ m} and
  the second argument is \texttt{suc\ n}, then the inductive hypothesis
  \texttt{≤-total\ m\ n} establishes one of the following:

  \begin{itemize}
  \item
    The forward case of the inductive hypothesis holds with \texttt{m≤n}
    as evidence that \texttt{m\ ≤\ n}, from which it follows that the
    forward case of the proposition holds with \texttt{s≤s\ m≤n} as
    evidence that \texttt{suc\ m\ ≤\ suc\ n}.
  \item
    The flipped case of the inductive hypothesis holds with \texttt{n≤m}
    as evidence that \texttt{n\ ≤\ m}, from which it follows that the
    flipped case of the proposition holds with \texttt{s≤s\ n≤m} as
    evidence that \texttt{suc\ n\ ≤\ suc\ m}.
  \end{itemize}
\end{itemize}

This is our first use of the \texttt{with} clause in Agda. The keyword
\texttt{with} is followed by an expression and one or more subsequent
lines. Each line begins with an ellipsis (\texttt{...}) and a vertical
bar (\texttt{\textbar{}}), followed by a pattern to be matched against
the expression and the right-hand side of the equation.

Every use of \texttt{with} is equivalent to defining a helper function.
For example, the definition above is equivalent to the following:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{≤-total′}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Total}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[0]\AgdaFunction{≤-total′}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}%
\>[17]\AgdaBound{n}%
\>[26]\AgdaSymbol{=}%
\>[29]\AgdaInductiveConstructor{forward}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\<%
\\
\>[0]\AgdaFunction{≤-total′}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}%
\>[26]\AgdaSymbol{=}%
\>[29]\AgdaInductiveConstructor{flipped}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\<%
\\
\>[0]\AgdaFunction{≤-total′}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}%
\>[26]\AgdaSymbol{=}%
\>[29]\AgdaFunction{helper}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{≤-total′}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{where}\<%
\\
%
\>[2]\AgdaFunction{helper}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Total}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Total}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{helper}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{forward}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSymbol{)}%
\>[24]\AgdaSymbol{=}%
\>[27]\AgdaInductiveConstructor{forward}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{helper}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{flipped}\AgdaSpace{}%
\AgdaBound{n≤m}\AgdaSymbol{)}%
\>[24]\AgdaSymbol{=}%
\>[27]\AgdaInductiveConstructor{flipped}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{n≤m}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

This is also our first use of a \texttt{where} clause in Agda. The
keyword \texttt{where} is followed by one or more definitions, which
must be indented. Any variables bound on the left-hand side of the
preceding equation (in this case, \texttt{m} and \texttt{n}) are in
scope within the nested definition, and any identifiers bound in the
nested definition (in this case, \texttt{helper}) are in scope in the
right-hand side of the preceding equation.

If both arguments are equal, then both cases hold and we could return
evidence of either. In the code above we return the forward case, but
there is a variant that returns the flipped case:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{≤-total″}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Total}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[0]\AgdaFunction{≤-total″}\AgdaSpace{}%
\AgdaBound{m}%
\>[17]\AgdaInductiveConstructor{zero}%
\>[43]\AgdaSymbol{=}%
\>[46]\AgdaInductiveConstructor{flipped}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\<%
\\
\>[0]\AgdaFunction{≤-total″}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}%
\>[17]\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}%
\>[43]\AgdaSymbol{=}%
\>[46]\AgdaInductiveConstructor{forward}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\<%
\\
\>[0]\AgdaFunction{≤-total″}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{≤-total″}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[27]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{forward}\AgdaSpace{}%
\AgdaBound{m≤n}%
\>[43]\AgdaSymbol{=}%
\>[46]\AgdaInductiveConstructor{forward}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaSymbol{...}%
\>[27]\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{flipped}\AgdaSpace{}%
\AgdaBound{n≤m}%
\>[43]\AgdaSymbol{=}%
\>[46]\AgdaInductiveConstructor{flipped}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaBound{n≤m}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

It differs from the original code in that it pattern matches on the
second argument before the first argument.

\hypertarget{monotonicity}{%
\section{Monotonicity}\label{monotonicity}}

If one bumps into both an operator and an ordering at a party, one may
ask if the operator is \emph{monotonic} with regard to the ordering. For
example, addition is monotonic with regard to inequality, meaning:

\begin{myDisplay}
∀ {m n p q : ℕ} → m ≤ n → p ≤ q → m + p ≤ n + q
\end{myDisplay}

The proof is straightforward using the techniques we have learned, and
is best broken into three parts. First, we deal with the special case of
showing addition is monotonic on the right:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{+-monoʳ-≤}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}%
\>[418I]\AgdaBound{p}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{q}\<%
\\
\>[.][@{}l@{}]\<[418I]%
\>[4]\AgdaComment{-------------}\<%
\\
%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaBound{q}\<%
\\
\>[0]\AgdaFunction{+-monoʳ-≤}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}%
\>[18]\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaBound{p≤q}%
\>[27]\AgdaSymbol{=}%
\>[30]\AgdaBound{p≤q}\<%
\\
\>[0]\AgdaFunction{+-monoʳ-≤}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaBound{p≤q}%
\>[27]\AgdaSymbol{=}%
\>[30]\AgdaInductiveConstructor{s≤s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{+-monoʳ-≤}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaBound{p≤q}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

The proof is by induction on the first argument.

\begin{itemize}
\item
  \emph{Base case}: The first argument is \texttt{zero} in which case
  \texttt{zero\ +\ p\ ≤\ zero\ +\ q} simplifies to \texttt{p\ ≤\ q}, the
  evidence for which is given by the argument \texttt{p≤q}.
\item
  \emph{Inductive case}: The first argument is \texttt{suc\ n}, in which
  case \texttt{suc\ n\ +\ p\ ≤\ suc\ n\ +\ q} simplifies to
  \texttt{suc\ (n\ +\ p)\ ≤\ suc\ (n\ +\ q)}. The inductive hypothesis
  \texttt{+-monoʳ-≤\ n\ p\ q\ p≤q} establishes that
  \texttt{n\ +\ p\ ≤\ n\ +\ q}, and our goal follows by applying
  \texttt{s≤s}.
\end{itemize}

Second, we deal with the special case of showing addition is monotonic
on the left. This follows from the previous result and the commutativity
of addition:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{+-monoˡ-≤}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}%
\>[448I]\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[.][@{}l@{}]\<[448I]%
\>[4]\AgdaComment{-------------}\<%
\\
%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaBound{p}\<%
\\
\>[0]\AgdaFunction{+-monoˡ-≤}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{m≤n}%
\>[21]\AgdaKeyword{rewrite}\AgdaSpace{}%
\AgdaFunction{+-comm}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaFunction{+-comm}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{p}%
\>[54]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{+-monoʳ-≤}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{m≤n}\<%
\end{code}
\end{fence}

Rewriting by \texttt{+-comm\ m\ p} and \texttt{+-comm\ n\ p} converts
\texttt{m\ +\ p\ ≤\ n\ +\ p} into \texttt{p\ +\ m\ ≤\ p\ +\ n}, which is
proved by invoking \texttt{+-monoʳ-≤\ p\ m\ n\ m≤n}.

Third, we combine the two previous results:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{+-mono-≤}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
%
\>[2]\AgdaSymbol{→}%
\>[485I]\AgdaBound{p}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{q}\<%
\\
\>[.][@{}l@{}]\<[485I]%
\>[4]\AgdaComment{-------------}\<%
\\
%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≤}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaBound{q}\<%
\\
\>[0]\AgdaFunction{+-mono-≤}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSpace{}%
\AgdaBound{p≤q}%
\>[26]\AgdaSymbol{=}%
\>[29]\AgdaFunction{≤-trans}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{+-monoˡ-≤}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{m≤n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{+-monoʳ-≤}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaBound{p≤q}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

Invoking \texttt{+-monoˡ-≤\ m\ n\ p\ m≤n} proves
\texttt{m\ +\ p\ ≤\ n\ +\ p} and invoking
\texttt{+-monoʳ-≤\ n\ p\ q\ p≤q} proves \texttt{n\ +\ p\ ≤\ n\ +\ q},
and combining these with transitivity proves
\texttt{m\ +\ p\ ≤\ n\ +\ q}, as was to be shown.

\hypertarget{exercise--mono--stretch}{%
\subsubsection{\texorpdfstring{Exercise \texttt{*-mono-≤}
(stretch)}{Exercise *-mono-≤ (stretch)}}\label{exercise--mono--stretch}}

Show that multiplication is monotonic with regard to inequality.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{Relations-strict-inequality}{%
\section{Strict inequality}\label{Relations-strict-inequality}}

We can define strict inequality similarly to inequality:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}<\AgdaUnderscore{}}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}<\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{z<s}%
\>[521I]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[521I]%
\>[6]\AgdaComment{------------}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{<}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{s<s}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}%
\>[536I]\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{<}}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[.][@{}l@{}]\<[536I]%
\>[6]\AgdaComment{-------------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{<}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\<%
\end{code}
\end{fence}

The key difference is that zero is less than the successor of an
arbitrary number, but is not less than zero.

Clearly, strict inequality is not reflexive. However it is
\emph{irreflexive} in that \texttt{n\ \textless{}\ n} never holds for
any value of \texttt{n}. Like inequality, strict inequality is
transitive. Strict inequality is not total, but satisfies the closely
related property of \emph{trichotomy}: for any \texttt{m} and
\texttt{n}, exactly one of \texttt{m\ \textless{}\ n}, \texttt{m\ ≡\ n},
or \texttt{m\ \textgreater{}\ n} holds (where we define
\texttt{m\ \textgreater{}\ n} to hold exactly when
\texttt{n\ \textless{}\ m}). It is also monotonic with regards to
addition and multiplication.

Most of the above are considered in exercises below. Irreflexivity
requires negation, as does the fact that the three cases in trichotomy
are mutually exclusive, so those points are deferred to Chapter
\protect\hyperlink{Negation}{Negation}.

It is straightforward to show that \texttt{suc\ m\ ≤\ n} implies
\texttt{m\ \textless{}\ n}, and conversely. One can then give an
alternative derivation of the properties of strict inequality, such as
transitivity, by exploiting the corresponding properties of inequality.

\hypertarget{Relations-less-trans}{%
\subsubsection{\texorpdfstring{Exercise \texttt{\textless{}-trans}
(recommended)}{Exercise \textless-trans (recommended)}}\label{Relations-less-trans}}

Show that strict inequality is transitive.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{Relations-trichotomy}{%
\subsubsection{\texorpdfstring{Exercise \texttt{trichotomy}
(practice)}{Exercise trichotomy (practice)}}\label{Relations-trichotomy}}

Show that strict inequality satisfies a weak version of trichotomy, in
the sense that for any \texttt{m} and \texttt{n} that one of the
following holds: * \texttt{m\ \textless{}\ n}, * \texttt{m\ ≡\ n}, or *
\texttt{m\ \textgreater{}\ n}.

Define \texttt{m\ \textgreater{}\ n} to be the same as
\texttt{n\ \textless{}\ m}. You will need a suitable data declaration,
similar to that used for totality. (We will show that the three cases
are exclusive after we introduce
\protect\hyperlink{Negation}{negation}.)

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{Relations-plus-mono-less}{%
\subsubsection{\texorpdfstring{Exercise \texttt{+-mono-\textless{}}
(practice)}{Exercise +-mono-\textless{} (practice)}}\label{Relations-plus-mono-less}}

Show that addition is monotonic with respect to strict inequality. As
with inequality, some additional definitions may be required.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{Relations-leq-iff-less}{%
\subsubsection{\texorpdfstring{Exercise \texttt{≤-iff-\textless{}}
(recommended)}{Exercise ≤-iff-\textless{} (recommended)}}\label{Relations-leq-iff-less}}

Show that \texttt{suc\ m\ ≤\ n} implies \texttt{m\ \textless{}\ n}, and
conversely.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{Relations-less-trans-revisited}{%
\subsubsection{\texorpdfstring{Exercise
\texttt{\textless{}-trans-revisited}
(practice)}{Exercise \textless-trans-revisited (practice)}}\label{Relations-less-trans-revisited}}

Give an alternative proof that strict inequality is transitive, using
the relation between strict inequality and inequality and the fact that
inequality is transitive.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{even-and-odd}{%
\section{Even and odd}\label{even-and-odd}}

As a further example, let's specify even and odd numbers. Inequality and
strict inequality are \emph{binary relations}, while even and odd are
\emph{unary relations}, sometimes called \emph{predicates}:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{even}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{odd}%
\>[10]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitiveType{Set}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{even}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaComment{---------}\<%
\\
%
\>[6]\AgdaDatatype{even}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{suc}%
\>[7]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}%
\>[561I]\AgdaDatatype{odd}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[.][@{}l@{}]\<[561I]%
\>[6]\AgdaComment{------------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{even}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{odd}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{suc}%
\>[7]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{→}%
\>[572I]\AgdaDatatype{even}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[.][@{}l@{}]\<[572I]%
\>[6]\AgdaComment{-----------}\<%
\\
%
\>[4]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{odd}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

A number is even if it is zero or the successor of an odd number, and
odd if it is the successor of an even number.

This is our first use of a mutually recursive datatype declaration.
Since each identifier must be defined before it is used, we first
declare the indexed types \texttt{even} and \texttt{odd} (omitting the
\texttt{where} keyword and the declarations of the constructors) and
then declare the constructors (omitting the signatures
\texttt{ℕ\ →\ Set} which were given earlier).

This is also our first use of \emph{overloaded} constructors, that is,
using the same name for constructors of different types. Here
\texttt{suc} means one of three constructors:

\begin{myDisplay}
suc : ℕ → ℕ

suc : ∀ {n : ℕ}
  → odd n
    ------------
  → even (suc n)

suc : ∀ {n : ℕ}
  → even n
    -----------
  → odd (suc n)
\end{myDisplay}

Similarly, \texttt{zero} refers to one of two constructors. Due to how
it does type inference, Agda does not allow overloading of defined
names, but does allow overloading of constructors. It is recommended
that one restrict overloading to related meanings, as we have done here,
but it is not required.

We show that the sum of two even numbers is even:

\begin{fence}
\begin{code}%
\>[0]\AgdaFunction{e+e≡e}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{even}\AgdaSpace{}%
\AgdaBound{m}\<%
\\
%
\>[2]\AgdaSymbol{→}%
\>[585I]\AgdaDatatype{even}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[.][@{}l@{}]\<[585I]%
\>[4]\AgdaComment{------------}\<%
\\
%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{even}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{o+e≡o}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{odd}\AgdaSpace{}%
\AgdaBound{m}\<%
\\
%
\>[2]\AgdaSymbol{→}%
\>[599I]\AgdaDatatype{even}\AgdaSpace{}%
\AgdaBound{n}\<%
\\
\>[.][@{}l@{}]\<[599I]%
\>[4]\AgdaComment{-----------}\<%
\\
%
\>[2]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{odd}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{e+e≡e}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}%
\>[15]\AgdaBound{en}%
\>[19]\AgdaSymbol{=}%
\>[22]\AgdaBound{en}\<%
\\
\>[0]\AgdaFunction{e+e≡e}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{om}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{en}%
\>[19]\AgdaSymbol{=}%
\>[22]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{o+e≡o}\AgdaSpace{}%
\AgdaBound{om}\AgdaSpace{}%
\AgdaBound{en}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{o+e≡o}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{em}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{en}%
\>[19]\AgdaSymbol{=}%
\>[22]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{e+e≡e}\AgdaSpace{}%
\AgdaBound{em}\AgdaSpace{}%
\AgdaBound{en}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

Corresponding to the mutually recursive types, we use two mutually
recursive functions, one to show that the sum of two even numbers is
even, and the other to show that the sum of an odd and an even number is
odd.

This is our first use of mutually recursive functions. Since each
identifier must be defined before it is used, we first give the
signatures for both functions and then the equations that define them.

To show that the sum of two even numbers is even, consider the evidence
that the first number is even. If it is because it is zero, then the sum
is even because the second number is even. If it is because it is the
successor of an odd number, then the result is even because it is the
successor of the sum of an odd and an even number, which is odd.

To show that the sum of an odd and even number is odd, consider the
evidence that the first number is odd. If it is because it is the
successor of an even number, then the result is odd because it is the
successor of the sum of two even numbers, which is even.

\hypertarget{Relations-odd-plus-odd}{%
\subsubsection{\texorpdfstring{Exercise \texttt{o+o≡e}
(stretch)}{Exercise o+o≡e (stretch)}}\label{Relations-odd-plus-odd}}

Show that the sum of two odd numbers is even.

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{Relations-Bin-predicates}{%
\subsubsection{\texorpdfstring{Exercise \texttt{Bin-predicates}
(stretch)}{Exercise Bin-predicates (stretch)}}\label{Relations-Bin-predicates}}

Recall that Exercise \protect\hyperlink{Naturals-Bin}{Bin} defines a
datatype \texttt{Bin} of bitstrings representing natural numbers.
Representations are not unique due to leading zeros. Hence, eleven may
be represented by both of the following:

\begin{myDisplay}
⟨⟩ I O I I
⟨⟩ O O I O I I
\end{myDisplay}

Define a predicate

\begin{myDisplay}
Can : Bin → Set
\end{myDisplay}

over all bitstrings that holds if the bitstring is canonical, meaning it
has no leading zeros; the first representation of eleven above is
canonical, and the second is not. To define it, you will need an
auxiliary predicate

\begin{myDisplay}
One : Bin → Set
\end{myDisplay}

that holds only if the bistring has a leading one. A bitstring is
canonical if it has a leading one (representing a positive number) or if
it consists of a single zero (representing zero).

Show that increment preserves canonical bitstrings:

\begin{myDisplay}
Can b
------------
Can (inc b)
\end{myDisplay}

Show that converting a natural to a bitstring always yields a canonical
bitstring:

\begin{myDisplay}
----------
Can (to n)
\end{myDisplay}

Show that converting a canonical bitstring to a natural and back is the
identity:

\begin{myDisplay}
Can b
---------------
to (from b) ≡ b
\end{myDisplay}

(Hint: For each of these, you may first need to prove related properties
of \texttt{One}. Also, you may need to prove that if \texttt{One\ b}
then \texttt{1} is less or equal to the result of \texttt{from\ b}.)

\begin{fence}
\begin{code}%
\>[0]\AgdaComment{-- Your code goes here}\<%
\end{code}
\end{fence}

\hypertarget{standard-library}{%
\section{Standard library}\label{standard-library}}

Definitions similar to those in this chapter can be found in the
standard library:

\begin{fence}
\begin{code}%
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≤\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{s≤s}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat.Properties}\AgdaSpace{}%
\AgdaKeyword{using}%
\>[625I]\AgdaSymbol{(}\AgdaFunction{≤-refl}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{≤-trans}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{≤-antisym}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{≤-total}\AgdaSymbol{;}\<%
\\
\>[625I][@{}l@{\AgdaIndent{0}}]%
\>[34]\AgdaFunction{+-monoʳ-≤}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{+-monoˡ-≤}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{+-mono-≤}\AgdaSymbol{)}\<%
\end{code}
\end{fence}

In the standard library, \texttt{≤-total} is formalised in terms of
disjunction (which we define in Chapter
\protect\hyperlink{Connectives}{Connectives}), and \texttt{+-monoʳ-≤},
\texttt{+-monoˡ-≤}, \texttt{+-mono-≤} are proved differently than here,
and more arguments are implicit.

\hypertarget{unicode}{%
\section{Unicode}\label{unicode}}

This chapter uses the following unicode:

\begin{myDisplay}
≤  U+2264  LESS-THAN OR EQUAL TO (\<=, \le)
≥  U+2265  GREATER-THAN OR EQUAL TO (\>=, \ge)
ˡ  U+02E1  MODIFIER LETTER SMALL L (\^l)
ʳ  U+02B3  MODIFIER LETTER SMALL R (\^r)
\end{myDisplay}

The commands \texttt{\textbackslash{}\^{}l} and
\texttt{\textbackslash{}\^{}r} give access to a variety of superscript
leftward and rightward arrows in addition to superscript letters
\texttt{l} and \texttt{r}.

