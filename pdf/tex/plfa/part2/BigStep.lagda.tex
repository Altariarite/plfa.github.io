\hypertarget{BigStep}{%
\chapter{BigStep: Big-step semantics of untyped lambda
calculus}\label{BigStep}}

\begin{fence}
\begin{code}
module plfa.part2.BigStep where
\end{code}
\end{fence}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

The call-by-name evaluation strategy is a deterministic method for
computing the value of a program in the lambda calculus. That is,
call-by-name produces a value if and only if beta reduction can reduce
the program to a lambda abstraction. In this chapter we define
call-by-name evaluation and prove the forward direction of this
if-and-only-if. The backward direction is traditionally proved via
Curry-Feys standardisation, which is quite complex. We give a sketch of
that proof, due to Plotkin, but postpone the proof in Agda until after
we have developed a denotational semantics for the lambda calculus, at
which point the proof is an easy corollary of properties of the
denotational semantics.

We present the call-by-name strategy as a relation between an input term
and an output value. Such a relation is often called a \emph{big-step
semantics}, written \texttt{M\ ⇓\ V}, as it relates the input term
\texttt{M} directly to the final result \texttt{V}, in contrast to the
small-step reduction relation, \texttt{M\ —→\ M′}, that maps \texttt{M}
to another term \texttt{M′} in which a single sub-computation has been
completed.

\hypertarget{imports}{%
\section{Imports}\label{imports}}

\begin{fence}
\begin{code}
open import Relation.Binary.PropositionalEquality
  using (_≡_; refl; trans; sym; cong-app)
open import Data.Product using (_×_; Σ; Σ-syntax; ∃; ∃-syntax; proj₁; proj₂)
  renaming (_,_ to ⟨_,_⟩)
open import Function using (_∘_)
open import plfa.part2.Untyped
  using (Context; _⊢_; _∋_; ★; ∅; _,_; Z; S_; `_; #_; ƛ_; _·_;
  subst; subst-zero; exts; rename; β; ξ₁; ξ₂; ζ; _—→_; _—↠_; _—→⟨_⟩_; _∎;
  —↠-trans; appL-cong)
open import plfa.part2.Substitution using (Subst; ids)
\end{code}
\end{fence}

\hypertarget{environments}{%
\section{Environments}\label{environments}}

To handle variables and function application, there is the choice
between using substitution, as in \texttt{—→}, or to use an
\emph{environment}. An environment in call-by-name is a map from
variables to closures, that is, to terms paired with their environments.
We choose to use environments instead of substitution because the point
of the call-by-name strategy is to be closer to an implementation of the
language. Also, the denotational semantics introduced in later chapters
uses environments and the proof of adequacy is made easier by aligning
these choices.

We define environments and closures as follows.

\begin{fence}
\begin{code}
ClosEnv : Context → Set

data Clos : Set where
  clos : ∀{Γ} → (M : Γ ⊢ ★) → ClosEnv Γ → Clos

ClosEnv Γ = ∀ (x : Γ ∋ ★) → Clos
\end{code}
\end{fence}

As usual, we have the empty environment, and we can extend an
environment.

\begin{fence}
\begin{code}
∅' : ClosEnv ∅
∅' ()

_,'_ : ∀ {Γ} → ClosEnv Γ → Clos → ClosEnv (Γ , ★)
(γ ,' c) Z = c
(γ ,' c) (S x) = γ x
\end{code}
\end{fence}

\hypertarget{big-step-evaluation}{%
\section{Big-step evaluation}\label{big-step-evaluation}}

The big-step semantics is represented as a ternary relation, written
\texttt{γ\ ⊢\ M\ ⇓\ V}, where \texttt{γ} is the environment, \texttt{M}
is the input term, and \texttt{V} is the result value. A \emph{value} is
a closure whose term is a lambda abstraction.

\begin{fence}
\begin{code}
data _⊢_⇓_ : ∀{Γ} → ClosEnv Γ → (Γ ⊢ ★) → Clos → Set where

  ⇓-var : ∀{Γ}{γ : ClosEnv Γ}{x : Γ ∋ ★}{Δ}{δ : ClosEnv Δ}{M : Δ ⊢ ★}{V}
    → γ x ≡ clos M δ
    → δ ⊢ M ⇓ V
      -----------
    → γ ⊢ ` x ⇓ V

  ⇓-lam : ∀{Γ}{γ : ClosEnv Γ}{M : Γ , ★ ⊢ ★}
    → γ ⊢ ƛ M ⇓ clos (ƛ M) γ

  ⇓-app : ∀{Γ}{γ : ClosEnv Γ}{L M : Γ ⊢ ★}{Δ}{δ : ClosEnv Δ}{N : Δ , ★ ⊢ ★}{V}
    → γ ⊢ L ⇓ clos (ƛ N) δ   →   (δ ,' clos M γ) ⊢ N ⇓ V
      ---------------------------------------------------
    → γ ⊢ L · M ⇓ V
\end{code}
\end{fence}

\begin{itemize}
\item
  The \texttt{⇓-var} rule evaluates a variable by finding the associated
  closure in the environment and then evaluating the closure.
\item
  The \texttt{⇓-lam} rule turns a lambda abstraction into a closure by
  packaging it up with its environment.
\item
  The \texttt{⇓-app} rule performs function application by first
  evaluating the term \texttt{L} in operator position. If that produces
  a closure containing a lambda abstraction \texttt{ƛ\ N}, then we
  evaluate the body \texttt{N} in an environment extended with the
  argument \texttt{M}. Note that \texttt{M} is not evaluated in rule
  \texttt{⇓-app} because this is call-by-name and not call-by-value.
\end{itemize}

\hypertarget{exercise-big-step-eg-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{big-step-eg}
(practice)}{Exercise big-step-eg (practice)}}\label{exercise-big-step-eg-practice}}

Show that
\texttt{(ƛ\ ƛ\ \#\ 1)\ ·\ ((ƛ\ \#\ 0\ ·\ \#\ 0)\ ·\ (ƛ\ \#\ 0\ ·\ \#\ 0))}
terminates under big-step call-by-name evaluation.

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{the-big-step-semantics-is-deterministic}{%
\section{The big-step semantics is
deterministic}\label{the-big-step-semantics-is-deterministic}}

If the big-step relation evaluates a term \texttt{M} to both \texttt{V}
and \texttt{V′}, then \texttt{V} and \texttt{V′} must be identical. In
other words, the call-by-name relation is a partial function. The proof
is a straightforward induction on the two big-step derivations.

\begin{fence}
\begin{code}
⇓-determ : ∀{Γ}{γ : ClosEnv Γ}{M : Γ ⊢ ★}{V V' : Clos}
  → γ ⊢ M ⇓ V → γ ⊢ M ⇓ V'
  → V ≡ V'
⇓-determ (⇓-var eq1 mc) (⇓-var eq2 mc')
    with trans (sym eq1) eq2
... | refl = ⇓-determ mc mc'
⇓-determ ⇓-lam ⇓-lam = refl
⇓-determ (⇓-app mc mc₁) (⇓-app mc' mc'')
    with ⇓-determ mc mc'
... | refl = ⇓-determ mc₁ mc''
\end{code}
\end{fence}

\hypertarget{big-step-evaluation-implies-beta-reduction-to-a-lambda}{%
\section{Big-step evaluation implies beta reduction to a
lambda}\label{big-step-evaluation-implies-beta-reduction-to-a-lambda}}

If big-step evaluation produces a value, then the input term can reduce
to a lambda abstraction by beta reduction:

\begin{myDisplay}
  ∅' ⊢ M ⇓ clos (ƛ N′) δ
  -----------------------------
→ Σ[ N ∈ ∅ , ★ ⊢ ★ ] (M —↠ ƛ N)
\end{myDisplay}

The proof is by induction on the big-step derivation. As is often
necessary, one must generalize the statement to get the induction to go
through. In the case for \texttt{⇓-app} (function application), the
argument is added to the environment, so the environment becomes
non-empty. The corresponding β reduction substitutes the argument into
the body of the lambda abstraction. So we generalize the lemma to allow
an arbitrary environment \texttt{γ} and we add a premise that relates
the environment \texttt{γ} to an equivalent substitution \texttt{σ}.

The case for \texttt{⇓-app} also requires that we strengthen the
conclusion. In the case for \texttt{⇓-app} we have
\texttt{γ\ ⊢\ L\ ⇓\ clos\ (λ\ N)\ δ} and the induction hypothesis gives
us \texttt{L\ —↠\ ƛ\ N′}, but we need to know that \texttt{N} and
\texttt{N′} are equivalent. In particular, that
\texttt{N′\ ≡\ subst\ τ\ N} where \texttt{τ} is the substitution that is
equivalent to \texttt{δ}. Therefore we expand the conclusion of the
statement, stating that the results are equivalent.

We make the two notions of equivalence precise by defining the following
two mutually-recursive predicates \texttt{V\ ≈\ M} and
\texttt{γ\ ≈ₑ\ σ}.

\begin{fence}
\begin{code}
_≈_ : Clos → (∅ ⊢ ★) → Set
_≈ₑ_ : ∀{Γ} → ClosEnv Γ → Subst Γ ∅ → Set

(clos {Γ} M γ) ≈ N = Σ[ σ ∈ Subst Γ ∅ ] γ ≈ₑ σ × (N ≡ subst σ M)

γ ≈ₑ σ = ∀{x} → (γ x) ≈ (σ x)
\end{code}
\end{fence}

We can now state the main lemma:

\begin{myDisplay}
If γ ⊢ M ⇓ V  and  γ ≈ₑ σ,
then  subst σ M —↠ N  and  V ≈ N  for some N.
\end{myDisplay}

Before starting the proof, we establish a couple lemmas about equivalent
environments and substitutions.

The empty environment is equivalent to the identity substitution
\texttt{ids}, which we import from Chapter
\protect\hyperlink{Substitution}{Substitution}.

\begin{fence}
\begin{code}
≈ₑ-id : ∅' ≈ₑ ids
≈ₑ-id {()}
\end{code}
\end{fence}

Of course, applying the identity substitution to a term returns the same
term.

\begin{fence}
\begin{code}
sub-id : ∀{Γ} {A} {M : Γ ⊢ A} → subst ids M ≡ M
sub-id = plfa.part2.Substitution.sub-id
\end{code}
\end{fence}

We define an auxiliary function for extending a substitution.

\begin{fence}
\begin{code}
ext-subst : ∀{Γ Δ} → Subst Γ Δ → Δ ⊢ ★ → Subst (Γ , ★) Δ
ext-subst{Γ}{Δ} σ N {A} = subst (subst-zero N) ∘ exts σ
\end{code}
\end{fence}

The next lemma we need to prove states that if you start with an
equivalent environment and substitution \texttt{γ\ ≈ₑ\ σ}, extending
them with an equivalent closure and term \texttt{c\ ≈\ N} produces an
equivalent environment and substitution:
\texttt{(γ\ ,\textquotesingle{}\ V)\ ≈ₑ\ (ext-subst\ σ\ N)}, or
equivalently,
\texttt{(γ\ ,\textquotesingle{}\ V)\ x\ ≈ₑ\ (ext-subst\ σ\ N)\ x} for
any variable \texttt{x}. The proof will be by induction on \texttt{x}
and for the induction step we need the following lemma, which states
that applying the composition of \texttt{exts\ σ} and
\texttt{subst-zero} to \texttt{S\ x} is the same as just \texttt{σ\ x},
which is a corollary of a theorem in Chapter
\protect\hyperlink{Substitution}{Substitution}.

\begin{fence}
\begin{code}
subst-zero-exts : ∀{Γ Δ}{σ : Subst Γ Δ}{B}{M : Δ ⊢ B}{x : Γ ∋ ★}
  → (subst (subst-zero M) ∘ exts σ) (S x) ≡ σ x
subst-zero-exts {Γ}{Δ}{σ}{B}{M}{x} =
   cong-app (plfa.part2.Substitution.subst-zero-exts-cons{σ = σ}) (S x)
\end{code}
\end{fence}

So the proof of \texttt{≈ₑ-ext} is as follows.

\begin{fence}
\begin{code}
≈ₑ-ext : ∀ {Γ} {γ : ClosEnv Γ} {σ : Subst Γ ∅} {V} {N : ∅ ⊢ ★}
  → γ ≈ₑ σ  →  V ≈ N
    --------------------------
  → (γ ,' V) ≈ₑ (ext-subst σ N)
≈ₑ-ext {Γ} {γ} {σ} {V} {N} γ≈ₑσ V≈N {Z} = V≈N
≈ₑ-ext {Γ} {γ} {σ} {V} {N} γ≈ₑσ V≈N {S x}
  rewrite subst-zero-exts {σ = σ}{M = N}{x} = γ≈ₑσ
\end{code}
\end{fence}

We proceed by induction on the input variable.

\begin{itemize}
\item
  If it is \texttt{Z}, then we immediately conclude using the premise
  \texttt{V\ ≈\ N}.
\item
  If it is \texttt{S\ x}, then we rewrite using the
  \texttt{subst-zero-exts} lemma and use the premise \texttt{γ\ ≈ₑ\ σ}
  to conclude.
\end{itemize}

To prove the main lemma, we need another technical lemma about
substitution. Applying one substitution after another is the same as
composing the two substitutions and then applying them.

\begin{fence}
\begin{code}
sub-sub : ∀{Γ Δ Σ}{A}{M : Γ ⊢ A} {σ₁ : Subst Γ Δ}{σ₂ : Subst Δ Σ}
  → subst σ₂ (subst σ₁ M) ≡ subst (subst σ₂ ∘ σ₁) M
sub-sub {M = M} = plfa.part2.Substitution.sub-sub {M = M}
\end{code}
\end{fence}

We arive at the main lemma: if \texttt{M} big steps to a closure
\texttt{V} in environment \texttt{γ}, and if \texttt{γ\ ≈ₑ\ σ}, then
\texttt{subst\ σ\ M} reduces to some term \texttt{N} that is equivalent
to \texttt{V}. We describe the proof below.

\begin{fence}
\begin{code}
⇓→—↠×≈ : ∀{Γ}{γ : ClosEnv Γ}{σ : Subst Γ ∅}{M : Γ ⊢ ★}{V : Clos}
       → γ ⊢ M ⇓ V  →  γ ≈ₑ σ
         ---------------------------------------
       → Σ[ N ∈ ∅ ⊢ ★ ] (subst σ M —↠ N) × V ≈ N
⇓→—↠×≈ {γ = γ} (⇓-var{x = x} γx≡Lδ δ⊢L⇓V) γ≈ₑσ
    with γ x | γ≈ₑσ {x} | γx≡Lδ
... | clos L δ | ⟨ τ , ⟨ δ≈ₑτ , σx≡τL ⟩ ⟩ | refl
      with ⇓→—↠×≈{σ = τ} δ⊢L⇓V δ≈ₑτ
...   | ⟨ N , ⟨ τL—↠N , V≈N ⟩ ⟩ rewrite σx≡τL =
        ⟨ N , ⟨ τL—↠N , V≈N ⟩ ⟩
⇓→—↠×≈ {σ = σ} {V = clos (ƛ N) γ} (⇓-lam) γ≈ₑσ =
    ⟨ subst σ (ƛ N) , ⟨ subst σ (ƛ N) ∎ , ⟨ σ , ⟨ γ≈ₑσ , refl ⟩ ⟩ ⟩ ⟩
⇓→—↠×≈{Γ}{γ} {σ = σ} {L · M} {V} (⇓-app {N = N} L⇓ƛNδ N⇓V) γ≈ₑσ
    with ⇓→—↠×≈{σ = σ} L⇓ƛNδ γ≈ₑσ
... | ⟨ _ , ⟨ σL—↠ƛτN , ⟨ τ , ⟨ δ≈ₑτ , ≡ƛτN ⟩ ⟩ ⟩ ⟩ rewrite ≡ƛτN
      with ⇓→—↠×≈ {σ = ext-subst τ (subst σ M)} N⇓V
             (λ {x} → ≈ₑ-ext{σ = τ} δ≈ₑτ ⟨ σ , ⟨ γ≈ₑσ , refl ⟩ ⟩ {x})
           | β{∅}{subst (exts τ) N}{subst σ M}
...   | ⟨ N' , ⟨ —↠N' , V≈N' ⟩ ⟩ | ƛτN·σM—→
        rewrite sub-sub{M = N}{σ₁ = exts τ}{σ₂ = subst-zero (subst σ M)} =
        let rs = (ƛ subst (exts τ) N) · subst σ M —→⟨ ƛτN·σM—→ ⟩ —↠N' in
        let g = —↠-trans (appL-cong σL—↠ƛτN) rs in
        ⟨ N' , ⟨ g , V≈N' ⟩ ⟩
\end{code}
\end{fence}

The proof is by induction on \texttt{γ\ ⊢\ M\ ⇓\ V}. We have three cases
to consider.

\begin{itemize}
\item
  Case \texttt{⇓-var}. So we have \texttt{γ\ x\ ≡\ clos\ L\ δ} and
  \texttt{δ\ ⊢\ L\ ⇓\ V}. We need to show that
  \texttt{subst\ σ\ x\ —↠\ N} and \texttt{V\ ≈\ N} for some \texttt{N}.
  The premise \texttt{γ\ ≈ₑ\ σ} tells us that \texttt{γ\ x\ ≈\ σ\ x}, so
  \texttt{clos\ L\ δ\ ≈\ σ\ x}. By the definition of \texttt{≈}, there
  exists a \texttt{τ} such that \texttt{δ\ ≈ₑ\ τ} and
  \texttt{σ\ x\ ≡\ subst\ τ\ L}. Using \texttt{δ\ ⊢\ L\ ⇓\ V} and
  \texttt{δ\ ≈ₑ\ τ}, the induction hypothesis gives us
  \texttt{subst\ τ\ L\ —↠\ N} and \texttt{V\ ≈\ N} for some \texttt{N}.
  So we have shown that \texttt{subst\ σ\ x\ —↠\ N} and \texttt{V\ ≈\ N}
  for some \texttt{N}.
\item
  Case \texttt{⇓-lam}. We immediately have
  \texttt{subst\ σ\ (ƛ\ N)\ —↠\ subst\ σ\ (ƛ\ N)} and
  \texttt{clos\ (subst\ σ\ (ƛ\ N))\ γ\ ≈\ subst\ σ\ (ƛ\ N)}.
\item
  Case \texttt{⇓-app}. Using \texttt{γ\ ⊢\ L\ ⇓\ clos\ N\ δ} and
  \texttt{γ\ ≈ₑ\ σ}, the induction hypothesis gives us

  \begin{myDisplay}
    subst σ L —↠ ƛ subst (exts τ) N                                     (1)
  \end{myDisplay}

  and \texttt{δ\ ≈ₑ\ τ} for some \texttt{τ}. From \texttt{γ≈ₑσ} we have
  \texttt{clos\ M\ γ\ ≈\ subst\ σ\ M}. Then with
  \texttt{(δ\ ,\textquotesingle{}\ clos\ M\ γ)\ ⊢\ N\ ⇓\ V}, the
  induction hypothesis gives us \texttt{V\ ≈\ N\textquotesingle{}} and

  \begin{myDisplay}
    subst (subst (subst-zero (subst σ M)) ∘ (exts τ)) N —↠ N'         (2)
  \end{myDisplay}

  Meanwhile, by \texttt{β}, we have

  \begin{myDisplay}
    (ƛ subst (exts τ) N) · subst σ M
    —→ subst (subst-zero (subst σ M)) (subst (exts τ) N)
  \end{myDisplay}

  which is the same as the following, by \texttt{sub-sub}.

  \begin{myDisplay}
    (ƛ subst (exts τ) N) · subst σ M
    —→ subst (subst (subst-zero (subst σ M)) ∘ exts τ) N              (3)
  \end{myDisplay}

  Using (3) and (2) we have

  \begin{myDisplay}
    (ƛ subst (exts τ) N) · subst σ M —↠ N'                             (4)
  \end{myDisplay}

  From (1) we have

  \begin{myDisplay}
    subst σ L · subst σ M —↠ (ƛ subst (exts τ) N) · subst σ M
  \end{myDisplay}

  which we combine with (4) to conclude that

  \begin{myDisplay}
    subst σ L · subst σ M —↠ N'
  \end{myDisplay}
\end{itemize}

With the main lemma complete, we establish the forward direction of the
equivalence between the big-step semantics and beta reduction.

\begin{fence}
\begin{code}
cbn→reduce :  ∀{M : ∅ ⊢ ★}{Δ}{δ : ClosEnv Δ}{N′ : Δ , ★ ⊢ ★}
  → ∅' ⊢ M ⇓ clos (ƛ N′) δ
    -----------------------------
  → Σ[ N ∈ ∅ , ★ ⊢ ★ ] (M —↠ ƛ N)
cbn→reduce {M}{Δ}{δ}{N′} M⇓c
    with ⇓→—↠×≈{σ = ids} M⇓c ≈ₑ-id
... | ⟨ N , ⟨ rs , ⟨ σ , ⟨ h , eq2 ⟩ ⟩ ⟩ ⟩ rewrite sub-id{M = M} | eq2 =
      ⟨ subst (exts σ) N′ , rs ⟩
\end{code}
\end{fence}

\hypertarget{exercise-big-alt-implies-multi-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{big-alt-implies-multi}
(practice)}{Exercise big-alt-implies-multi (practice)}}\label{exercise-big-alt-implies-multi-practice}}

Formulate an alternative big-step semantics, of the form
\texttt{M\ ↓\ N}, for call-by-name that uses substitution instead of
environments. That is, the analogue of the application rule
\texttt{⇓-app} should perform substitution, as in
\texttt{N\ {[}\ M\ {]}}, instead of extending the environment with
\texttt{M}. Prove that \texttt{M\ ↓\ N} implies \texttt{M\ —↠\ N}.

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{beta-reduction-to-a-lambda-implies-big-step-evaluation}{%
\section{Beta reduction to a lambda implies big-step
evaluation}\label{beta-reduction-to-a-lambda-implies-big-step-evaluation}}

The proof of the backward direction, that beta reduction to a lambda
implies that the call-by-name semantics produces a result, is more
difficult to prove. The difficulty stems from reduction proceeding
underneath lambda abstractions via the \texttt{ζ} rule. The call-by-name
semantics does not reduce under lambda, so a straightforward proof by
induction on the reduction sequence is impossible. In the article
\emph{Call-by-name, call-by-value, and the λ-calculus}, Plotkin proves
the theorem in two steps, using two auxiliary reduction relations. The
first step uses a classic technique called Curry-Feys standardisation.
It relies on the notion of \emph{standard reduction sequence}, which
acts as a half-way point between full beta reduction and call-by-name by
expanding call-by-name to also include reduction underneath lambda.
Plotkin proves that \texttt{M} reduces to \texttt{L} if and only if
\texttt{M} is related to \texttt{L} by a standard reduction sequence.

\begin{myDisplay}
Theorem 1 (Standardisation)
`M —↠ L` if and only if `M` goes to `L` via a standard reduction sequence.
\end{myDisplay}

Plotkin then introduces \emph{left reduction}, a small-step version of
call-by-name and uses the above theorem to prove that beta reduction and
left reduction are equivalent in the following sense.

\begin{myDisplay}
Corollary 1
`M —↠ ƛ N` if and only if `M` goes to `ƛ N′`, for some `N′`, by left reduction.
\end{myDisplay}

The second step of the proof connects left reduction to call-by-name
evaluation.

\begin{myDisplay}
Theorem 2
`M` left reduces to `ƛ N` if and only if `⊢ M ⇓ ƛ N`.
\end{myDisplay}

(Plotkin's call-by-name evaluator uses substitution instead of
environments, which explains why the environment is omitted in
\texttt{⊢\ M\ ⇓\ ƛ\ N} in the above theorem statement.)

Putting Corollary 1 and Theorem 2 together, Plotkin proves that
call-by-name evaluation is equivalent to beta reduction.

\begin{myDisplay}
Corollary 2
`M —↠ ƛ N` if and only if `⊢ M ⇓ ƛ N′` for some `N′`.
\end{myDisplay}

Plotkin also proves an analogous result for the λᵥ calculus, relating it
to call-by-value evaluation. For a nice exposition of that proof, we
recommend Chapter 5 of \emph{Semantics Engineering with PLT Redex} by
Felleisen, Findler, and Flatt.

Instead of proving the backwards direction via standardisation, as
sketched above, we defer the proof until after we define a denotational
semantics for the lambda calculus, at which point the proof of the
backwards direction will fall out as a corollary to the soundness and
adequacy of the denotational semantics.

\hypertarget{unicode}{%
\section{Unicode}\label{unicode}}

This chapter uses the following unicode:

\begin{myDisplay}
≈  U+2248  ALMOST EQUAL TO (\~~ or \approx)
ₑ  U+2091  LATIN SUBSCRIPT SMALL LETTER E (\_e)
⊢  U+22A2  RIGHT TACK (\|- or \vdash)
⇓  U+21DB  DOWNWARDS DOUBLE ARROW (\d= or \Downarrow)
\end{myDisplay}

