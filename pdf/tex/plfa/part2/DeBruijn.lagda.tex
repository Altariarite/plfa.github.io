\hypertarget{DeBruijn}{%
\chapter{DeBruijn: Intrinsically-typed de Bruijn
representation}\label{DeBruijn}}

\begin{fence}
\begin{code}
module plfa.part2.DeBruijn where
\end{code}
\end{fence}

The previous two chapters introduced lambda calculus, with a
formalisation based on named variables, and terms defined separately
from types. We began with that approach because it is traditional, but
it is not the one we recommend. This chapter presents an alternative
approach, where named variables are replaced by de Bruijn indices and
terms are indexed by their types. Our new presentation is more compact,
using substantially fewer lines of code to cover the same ground.

There are two fundamental approaches to typed lambda calculi. One
approach, followed in the last two chapters, is to first define terms
and then define types. Terms exist independent of types, and may have
types assigned to them by separate typing rules. Another approach,
followed in this chapter, is to first define types and then define
terms. Terms and type rules are intertwined, and it makes no sense to
talk of a term without a type. The two approaches are sometimes called
\emph{Curry style} and \emph{Church style}. Following Reynolds, we will
refer to them as \emph{extrinsic} and \emph{intrinsic}.

The particular representation described here was first proposed by
Thorsten Altenkirch and Bernhard Reus. The formalisation of renaming and
substitution we use is due to Conor McBride. Related work has been
carried out by James Chapman, James McKinna, and many others.

\hypertarget{imports}{%
\section{Imports}\label{imports}}

\begin{fence}
\begin{code}
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl)
open import Data.Empty using (⊥; ⊥-elim)
open import Data.Nat using (ℕ; zero; suc; _<_; _≤?_; z≤n; s≤s)
open import Relation.Nullary using (¬_)
open import Relation.Nullary.Decidable using (True; toWitness)
\end{code}
\end{fence}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

There is a close correspondence between the structure of a term and the
structure of the derivation showing that it is well typed. For example,
here is the term for the Church numeral two:

\begin{myDisplay}
twoᶜ : Term
twoᶜ = ƛ "s" ⇒ ƛ "z" ⇒ ` "s" · (` "s" · ` "z")
\end{myDisplay}

And here is its corresponding type derivation:

\begin{myDisplay}
⊢twoᶜ : ∀ {A} → ∅ ⊢ twoᶜ ⦂ Ch A
⊢twoᶜ = ⊢ƛ (⊢ƛ (⊢` ∋s · (⊢` ∋s · ⊢` ∋z)))
  where
  ∋s = S ("s" ≠ "z") Z
  ∋z = Z
\end{myDisplay}

(These are both taken from Chapter \protect\hyperlink{Lambda}{Lambda}
and you can see the corresponding derivation tree written out in full
\protect\hyperlink{Lambda-derivation}{here}.) The two definitions are in
close correspondence, where:

\begin{itemize}
\tightlist
\item
  \texttt{\textasciigrave{}\_} corresponds to
  \texttt{⊢\textasciigrave{}}
\item
  \texttt{ƛ\_⇒\_} corresponds to \texttt{⊢ƛ}
\item
  \texttt{\_·\_} corresponds to \texttt{\_·\_}
\end{itemize}

Further, if we think of \texttt{Z} as zero and \texttt{S} as successor,
then the lookup derivation for each variable corresponds to a number
which tells us how many enclosing binding terms to count to find the
binding of that variable. Here \texttt{"z"} corresponds to \texttt{Z} or
zero and \texttt{"s"} corresponds to \texttt{S\ Z} or one. And, indeed,
\texttt{"z"} is bound by the inner abstraction (count outward past zero
abstractions) and \texttt{"s"} is bound by the outer abstraction (count
outward past one abstraction).

In this chapter, we are going to exploit this correspondence, and
introduce a new notation for terms that simultaneously represents the
term and its type derivation. Now we will write the following:

\begin{myDisplay}
twoᶜ  :  ∅ ⊢ Ch `ℕ
twoᶜ  =  ƛ ƛ (# 1 · (# 1 · # 0))
\end{myDisplay}

A variable is represented by a natural number (written with \texttt{Z}
and \texttt{S}, and abbreviated in the usual way), and tells us how many
enclosing binding terms to count to find the binding of that variable.
Thus, \texttt{\#\ 0} is bound at the inner \texttt{ƛ}, and
\texttt{\#\ 1} at the outer \texttt{ƛ}.

Replacing variables by numbers in this way is called \emph{de Bruijn
representation}, and the numbers themselves are called \emph{de Bruijn
indices}, after the Dutch mathematician Nicolaas Govert (Dick) de Bruijn
(1918---2012), a pioneer in the creation of proof assistants. One
advantage of replacing named variables with de Bruijn indices is that
each term now has a unique representation, rather than being represented
by the equivalence class of terms under alpha renaming.

The other important feature of our chosen representation is that it is
\emph{intrinsically typed}. In the previous two chapters, the definition
of terms and the definition of types are completely separate. All terms
have type \texttt{Term}, and nothing in Agda prevents one from writing a
nonsense term such as
\texttt{\textasciigrave{}zero\ ·\ \textasciigrave{}suc\ \textasciigrave{}zero}
which has no type. Such terms that exist independent of types are
sometimes called \emph{preterms} or \emph{raw terms}. Here we are going
to replace the type \texttt{Term} of raw terms by the type
\texttt{Γ\ ⊢\ A} of intrinsically-typed terms which in context
\texttt{Γ} have type \texttt{A}.

While these two choices fit well, they are independent. One can use de
Bruijn indices in raw terms, or have intrinsically-typed terms with
names. In Chapter \protect\hyperlink{Untyped}{Untyped}, we will
introduce terms with de Bruijn indices that are intrinsically scoped but
not typed.

\hypertarget{a-second-example}{%
\section{A second example}\label{a-second-example}}

De Bruijn indices can be tricky to get the hang of, so before proceeding
further let's consider a second example. Here is the term that adds two
naturals:

\begin{myDisplay}
plus : Term
plus = μ "+" ⇒ ƛ "m" ⇒ ƛ "n" ⇒
         case ` "m"
           [zero⇒ ` "n"
           |suc "m" ⇒ `suc (` "+" · ` "m" · ` "n") ]
\end{myDisplay}

Note variable \texttt{"m"} is bound twice, once in a lambda abstraction
and once in the successor branch of the case. Any appearance of
\texttt{"m"} in the successor branch must refer to the latter binding,
due to shadowing.

Here is its corresponding type derivation:

\begin{myDisplay}
⊢plus : ∅ ⊢ plus ⦂ `ℕ ⇒ `ℕ ⇒ `ℕ
⊢plus = ⊢μ (⊢ƛ (⊢ƛ (⊢case (⊢` ∋m) (⊢` ∋n)
         (⊢suc (⊢` ∋+ · ⊢` ∋m′ · ⊢` ∋n′)))))
  where
  ∋+  = (S ("+" ≠ "m") (S ("+" ≠ "n") (S ("+" ≠ "m") Z)))
  ∋m  = (S ("m" ≠ "n") Z)
  ∋n  = Z
  ∋m′ = Z
  ∋n′ = (S ("n" ≠ "m") Z)
\end{myDisplay}

The two definitions are in close correspondence, where in addition to
the previous correspondences we have:

\begin{itemize}
\tightlist
\item
  \texttt{\textasciigrave{}zero} corresponds to \texttt{⊢zero}
\item
  \texttt{\textasciigrave{}suc\_} corresponds to \texttt{⊢suc}
\item
  \texttt{case\_{[}zero⇒\_\textbar{}suc\_⇒\_{]}} corresponds to
  \texttt{⊢case}
\item
  \texttt{μ\_⇒\_} corresponds to \texttt{⊢μ}
\end{itemize}

Note the two lookup judgments \texttt{∋m} and \texttt{∋m′} refer to two
different bindings of variables named \texttt{"m"}. In contrast, the two
judgments \texttt{∋n} and \texttt{∋n′} both refer to the same binding of
\texttt{"n"} but accessed in different contexts, the first where
\texttt{"n"} is the last binding in the context, and the second after
\texttt{"m"} is bound in the successor branch of the case.

Here is the term and its type derivation in the notation of this
chapter:

\begin{myDisplay}
plus : ∀ {Γ} → Γ ⊢ `ℕ ⇒ `ℕ ⇒ `ℕ
plus = μ ƛ ƛ case (# 1) (# 0) (`suc (# 3 · # 0 · # 1))
\end{myDisplay}

Reading from left to right, each de Bruijn index corresponds to a lookup
derivation:

\begin{itemize}
\tightlist
\item
  \texttt{\#\ 1} corresponds to \texttt{∋m}
\item
  \texttt{\#\ 0} corresponds to \texttt{∋n}
\item
  \texttt{\#\ 3} corresponds to \texttt{∋+}
\item
  \texttt{\#\ 0} corresponds to \texttt{∋m′}
\item
  \texttt{\#\ 1} corresponds to \texttt{∋n′}
\end{itemize}

The de Bruijn index counts the number of \texttt{S} constructs in the
corresponding lookup derivation. Variable \texttt{"n"} bound in the
inner abstraction is referred to as \texttt{\#\ 0} in the zero branch of
the case but as \texttt{\#\ 1} in the successor branch of the case,
because of the intervening binding. Variable \texttt{"m"} bound in the
lambda abstraction is referred to by the first \texttt{\#\ 1} in the
code, while variable \texttt{"m"} bound in the successor branch of the
case is referred to by the second \texttt{\#\ 0}. There is no shadowing:
with variable names, there is no way to refer to the former binding in
the scope of the latter, but with de Bruijn indices it could be referred
to as \texttt{\#\ 2}.

\hypertarget{order-of-presentation}{%
\section{Order of presentation}\label{order-of-presentation}}

In the current chapter, the use of intrinsically-typed terms
necessitates that we cannot introduce operations such as substitution or
reduction without also showing that they preserve types. Hence, the
order of presentation must change.

The syntax of terms now incorporates their typing rules, and the
definition of values now incorporates the Canonical Forms lemma. The
definition of substitution is somewhat more involved, but incorporates
the trickiest part of the previous proof, the lemma establishing that
substitution preserves types. The definition of reduction incorporates
preservation, which no longer requires a separate proof.

\hypertarget{syntax}{%
\section{Syntax}\label{syntax}}

We now begin our formal development.

First, we get all our infix declarations out of the way. We list
separately operators for judgments, types, and terms:

\begin{fence}
\begin{code}
infix  4 _⊢_
infix  4 _∋_
infixl 5 _,_

infixr 7 _⇒_

infix  5 ƛ_
infix  5 μ_
infixl 7 _·_
infix  8 `suc_
infix  9 `_
infix  9 S_
infix  9 #_
\end{code}
\end{fence}

Since terms are intrinsically typed, we must define types and contexts
before terms.

\hypertarget{types}{%
\subsection{Types}\label{types}}

As before, we have just two types, functions and naturals. The formal
definition is unchanged:

\begin{fence}
\begin{code}
data Type : Set where
  _⇒_ : Type → Type → Type
  `ℕ  : Type
\end{code}
\end{fence}

\hypertarget{contexts}{%
\subsection{Contexts}\label{contexts}}

Contexts are as before, but we drop the names. Contexts are formalised
as follows:

\begin{fence}
\begin{code}
data Context : Set where
  ∅   : Context
  _,_ : Context → Type → Context
\end{code}
\end{fence}

A context is just a list of types, with the type of the most recently
bound variable on the right. As before, we let \texttt{Γ} and \texttt{Δ}
range over contexts. We write \texttt{∅} for the empty context, and
\texttt{Γ\ ,\ A} for the context \texttt{Γ} extended by type \texttt{A}.
For example

\begin{fence}
\begin{code}
_ : Context
_ = ∅ , `ℕ ⇒ `ℕ , `ℕ
\end{code}
\end{fence}

is a context with two variables in scope, where the outer bound one has
type \texttt{\textasciigrave{}ℕ\ ⇒\ \textasciigrave{}ℕ}, and the inner
bound one has type \texttt{\textasciigrave{}ℕ}.

\hypertarget{variables-and-the-lookup-judgment}{%
\subsection{Variables and the lookup
judgment}\label{variables-and-the-lookup-judgment}}

Intrinsically-typed variables correspond to the lookup judgment. They
are represented by de Bruijn indices, and hence also correspond to
natural numbers. We write

\begin{myDisplay}
Γ ∋ A
\end{myDisplay}

for variables which in context \texttt{Γ} have type \texttt{A}. The
lookup judgement is formalised by a datatype indexed by a context and a
type. It looks exactly like the old lookup judgment, but with all
variable names dropped:

\begin{fence}
\begin{code}
data _∋_ : Context → Type → Set where

  Z : ∀ {Γ A}
      ---------
    → Γ , A ∋ A

  S_ : ∀ {Γ A B}
    → Γ ∋ A
      ---------
    → Γ , B ∋ A
\end{code}
\end{fence}

Constructor \texttt{S} no longer requires an additional parameter, since
without names shadowing is no longer an issue. Now constructors
\texttt{Z} and \texttt{S} correspond even more closely to the
constructors \texttt{here} and \texttt{there} for the element-of
relation \texttt{\_∈\_} on lists, as well as to constructors
\texttt{zero} and \texttt{suc} for natural numbers.

For example, consider the following old-style lookup judgments:

\begin{itemize}
\tightlist
\item
  \texttt{∅\ ,\ "s"\ ⦂\ \textasciigrave{}ℕ\ ⇒\ \textasciigrave{}ℕ\ ,\ "z"\ ⦂\ \textasciigrave{}ℕ\ ∋\ "z"\ ⦂\ \textasciigrave{}ℕ}
\item
  \texttt{∅\ ,\ "s"\ ⦂\ \textasciigrave{}ℕ\ ⇒\ \textasciigrave{}ℕ\ ,\ "z"\ ⦂\ \textasciigrave{}ℕ\ ∋\ "s"\ ⦂\ \textasciigrave{}ℕ\ ⇒\ \textasciigrave{}ℕ}
\end{itemize}

They correspond to the following intrinsically-typed variables:

\begin{fence}
\begin{code}
_ : ∅ , `ℕ ⇒ `ℕ , `ℕ ∋ `ℕ
_ = Z

_ : ∅ , `ℕ ⇒ `ℕ , `ℕ ∋ `ℕ ⇒ `ℕ
_ = S Z
\end{code}
\end{fence}

In the given context, \texttt{"z"} is represented by \texttt{Z} (as the
most recently bound variable), and \texttt{"s"} by \texttt{S\ Z} (as the
next most recently bound variable).

\hypertarget{terms-and-the-typing-judgment}{%
\subsection{Terms and the typing
judgment}\label{terms-and-the-typing-judgment}}

Intrinsically-typed terms correspond to the typing judgment. We write

\begin{myDisplay}
Γ ⊢ A
\end{myDisplay}

for terms which in context \texttt{Γ} have type \texttt{A}. The
judgement is formalised by a datatype indexed by a context and a type.
It looks exactly like the old typing judgment, but with all terms and
variable names dropped:

\begin{fence}
\begin{code}
data _⊢_ : Context → Type → Set where

  `_ : ∀ {Γ A}
    → Γ ∋ A
      -----
    → Γ ⊢ A

  ƛ_  : ∀ {Γ A B}
    → Γ , A ⊢ B
      ---------
    → Γ ⊢ A ⇒ B

  _·_ : ∀ {Γ A B}
    → Γ ⊢ A ⇒ B
    → Γ ⊢ A
      ---------
    → Γ ⊢ B

  `zero : ∀ {Γ}
      ---------
    → Γ ⊢ `ℕ

  `suc_ : ∀ {Γ}
    → Γ ⊢ `ℕ
      ------
    → Γ ⊢ `ℕ

  case : ∀ {Γ A}
    → Γ ⊢ `ℕ
    → Γ ⊢ A
    → Γ , `ℕ ⊢ A
      ----------
    → Γ ⊢ A

  μ_ : ∀ {Γ A}
    → Γ , A ⊢ A
      ---------
    → Γ ⊢ A
\end{code}
\end{fence}

The definition exploits the close correspondence between the structure
of terms and the structure of a derivation showing that it is well
typed: now we use the derivation \emph{as} the term.

For example, consider the following old-style typing judgments:

\begin{itemize}
\tightlist
\item
  \texttt{∅\ ,\ "s"\ ⦂\ \textasciigrave{}ℕ\ ⇒\ \textasciigrave{}ℕ\ ,\ "z"\ ⦂\ \textasciigrave{}ℕ\ ⊢\ \textasciigrave{}\ "z"\ ⦂\ \textasciigrave{}ℕ}
\item
  \texttt{∅\ ,\ "s"\ ⦂\ \textasciigrave{}ℕ\ ⇒\ \textasciigrave{}ℕ\ ,\ "z"\ ⦂\ \textasciigrave{}ℕ\ ⊢\ \textasciigrave{}\ "s"\ ⦂\ \textasciigrave{}ℕ\ ⇒\ \textasciigrave{}ℕ}
\item
  \texttt{∅\ ,\ "s"\ ⦂\ \textasciigrave{}ℕ\ ⇒\ \textasciigrave{}ℕ\ ,\ "z"\ ⦂\ \textasciigrave{}ℕ\ ⊢\ \textasciigrave{}\ "s"\ ·\ \textasciigrave{}\ "z"\ ⦂\ \ \textasciigrave{}ℕ}
\item
  \texttt{∅\ ,\ "s"\ ⦂\ \textasciigrave{}ℕ\ ⇒\ \textasciigrave{}ℕ\ ,\ "z"\ ⦂\ \textasciigrave{}ℕ\ ⊢\ \textasciigrave{}\ "s"\ ·\ (\textasciigrave{}\ "s"\ ·\ \textasciigrave{}\ "z")\ ⦂\ \ \textasciigrave{}ℕ}
\item
  \texttt{∅\ ,\ "s"\ ⦂\ \textasciigrave{}ℕ\ ⇒\ \textasciigrave{}ℕ\ ⊢\ (ƛ\ "z"\ ⇒\ \textasciigrave{}\ "s"\ ·\ (\textasciigrave{}\ "s"\ ·\ \textasciigrave{}\ "z"))\ ⦂\ \ \textasciigrave{}ℕ\ ⇒\ \textasciigrave{}ℕ}
\item
  \texttt{∅\ ⊢\ ƛ\ "s"\ ⇒\ ƛ\ "z"\ ⇒\ \textasciigrave{}\ "s"\ ·\ (\textasciigrave{}\ "s"\ ·\ \textasciigrave{}\ "z"))\ ⦂\ \ (\textasciigrave{}ℕ\ ⇒\ \textasciigrave{}ℕ)\ ⇒\ \textasciigrave{}ℕ\ ⇒\ \textasciigrave{}ℕ}
\end{itemize}

They correspond to the following intrinsically-typed terms:

\begin{fence}
\begin{code}
_ : ∅ , `ℕ ⇒ `ℕ , `ℕ ⊢ `ℕ
_ = ` Z

_ : ∅ , `ℕ ⇒ `ℕ , `ℕ ⊢ `ℕ ⇒ `ℕ
_ = ` S Z

_ : ∅ , `ℕ ⇒ `ℕ , `ℕ ⊢ `ℕ
_ = ` S Z · ` Z

_ : ∅ , `ℕ ⇒ `ℕ , `ℕ ⊢ `ℕ
_ = ` S Z · (` S Z · ` Z)

_ : ∅ , `ℕ ⇒ `ℕ ⊢ `ℕ ⇒ `ℕ
_ = ƛ (` S Z · (` S Z · ` Z))

_ : ∅ ⊢ (`ℕ ⇒ `ℕ) ⇒ `ℕ ⇒ `ℕ
_ = ƛ ƛ (` S Z · (` S Z · ` Z))
\end{code}
\end{fence}

The final term represents the Church numeral two.

\hypertarget{abbreviating-de-bruijn-indices}{%
\subsection{Abbreviating de Bruijn
indices}\label{abbreviating-de-bruijn-indices}}

We define a helper function that computes the length of a context, which
will be useful in making sure an index is within context bounds:

\begin{fence}
\begin{code}
length : Context → ℕ
length ∅        =  zero
length (Γ , _)  =  suc (length Γ)
\end{code}
\end{fence}

We can use a natural number to select a type from a context:

\begin{fence}
\begin{code}
lookup : {Γ : Context} → {n : ℕ} → (p : n < length Γ) → Type
lookup {(_ , A)} {zero}    (s≤s z≤n)  =  A
lookup {(Γ , _)} {(suc n)} (s≤s p)    =  lookup p
\end{code}
\end{fence}

We intend to apply the function only when the natural is shorter than
the length of the context, which is witnessed by \texttt{p}.

Given the above, we can convert a natural to a corresponding de Bruijn
index, looking up its type in the context:

\begin{fence}
\begin{code}
count : ∀ {Γ} → {n : ℕ} → (p : n < length Γ) → Γ ∋ lookup p
count {_ , _} {zero}    (s≤s z≤n)  =  Z
count {Γ , _} {(suc n)} (s≤s p)    =  S (count p)
\end{code}
\end{fence}

We can then introduce a convenient abbreviation for variables:

\begin{fence}
\begin{code}
#_ : ∀ {Γ}
  → (n : ℕ)
  → {n∈Γ : True (suc n ≤? length Γ)}
    --------------------------------
  → Γ ⊢ lookup (toWitness n∈Γ)
#_ n {n∈Γ}  =  ` count (toWitness n∈Γ)
\end{code}
\end{fence}

Function \texttt{\#\_} takes an implicit argument \texttt{n∈Γ} that
provides evidence for \texttt{n} to be within the context's bounds.
Recall that
\protect\hyperlink{Decidable-proof-by-reflection}{\texttt{True}},
\protect\hyperlink{Decidable-the-best-of-both-worlds}{\texttt{\_≤?\_}}
and
\protect\hyperlink{Decidable-decidables-from-booleans-and-booleans-from-decidables}{\texttt{toWitness}}
are defined in Chapter \protect\hyperlink{Decidable}{Decidable}. The
type of \texttt{n∈Γ} guards against invoking \texttt{\#\_} on an
\texttt{n} that is out of context bounds. Finally, in the return type
\texttt{n∈Γ} is converted to a witness that \texttt{n} is within the
bounds.

With this abbreviation, we can rewrite the Church numeral two more
compactly:

\begin{fence}
\begin{code}
_ : ∅ ⊢ (`ℕ ⇒ `ℕ) ⇒ `ℕ ⇒ `ℕ
_ = ƛ ƛ (# 1 · (# 1 · # 0))
\end{code}
\end{fence}

\hypertarget{test-examples}{%
\subsection{Test examples}\label{test-examples}}

We repeat the test examples from Chapter
\protect\hyperlink{Lambda}{Lambda}. You can find them
\protect\hyperlink{Lambda-derivation}{here} for comparison.

First, computing two plus two on naturals:

\begin{fence}
\begin{code}
two : ∀ {Γ} → Γ ⊢ `ℕ
two = `suc `suc `zero

plus : ∀ {Γ} → Γ ⊢ `ℕ ⇒ `ℕ ⇒ `ℕ
plus = μ ƛ ƛ (case (# 1) (# 0) (`suc (# 3 · # 0 · # 1)))

2+2 : ∀ {Γ} → Γ ⊢ `ℕ
2+2 = plus · two · two
\end{code}
\end{fence}

We generalise to arbitrary contexts because later we will give examples
where \texttt{two} appears nested inside binders.

Next, computing two plus two on Church numerals:

\begin{fence}
\begin{code}
Ch : Type → Type
Ch A  =  (A ⇒ A) ⇒ A ⇒ A

twoᶜ : ∀ {Γ A} → Γ ⊢ Ch A
twoᶜ = ƛ ƛ (# 1 · (# 1 · # 0))

plusᶜ : ∀ {Γ A} → Γ ⊢ Ch A ⇒ Ch A ⇒ Ch A
plusᶜ = ƛ ƛ ƛ ƛ (# 3 · # 1 · (# 2 · # 1 · # 0))

sucᶜ : ∀ {Γ} → Γ ⊢ `ℕ ⇒ `ℕ
sucᶜ = ƛ `suc (# 0)

2+2ᶜ : ∀ {Γ} → Γ ⊢ `ℕ
2+2ᶜ = plusᶜ · twoᶜ · twoᶜ · sucᶜ · `zero
\end{code}
\end{fence}

As before we generalise everything to arbitrary contexts. While we are
at it, we also generalise \texttt{twoᶜ} and \texttt{plusᶜ} to Church
numerals over arbitrary types.

\hypertarget{exercise-mul-recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{mul}
(recommended)}{Exercise mul (recommended)}}\label{exercise-mul-recommended}}

Write out the definition of a lambda term that multiplies two natural
numbers, now adapted to the intrinsically-typed DeBruijn representation.

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{renaming}{%
\section{Renaming}\label{renaming}}

Renaming is a necessary prelude to substitution, enabling us to
``rebase'' a term from one context to another. It corresponds directly
to the renaming result from the previous chapter, but here the theorem
that ensures renaming preserves typing also acts as code that performs
renaming.

As before, we first need an extension lemma that allows us to extend the
context when we encounter a binder. Given a map from variables in one
context to variables in another, extension yields a map from the first
context extended to the second context similarly extended. It looks
exactly like the old extension lemma, but with all names and terms
dropped:

\begin{fence}
\begin{code}
ext : ∀ {Γ Δ}
  → (∀ {A} →       Γ ∋ A →     Δ ∋ A)
    ---------------------------------
  → (∀ {A B} → Γ , B ∋ A → Δ , B ∋ A)
ext ρ Z      =  Z
ext ρ (S x)  =  S (ρ x)
\end{code}
\end{fence}

Let \texttt{ρ} be the name of the map that takes variables in \texttt{Γ}
to variables in \texttt{Δ}. Consider the de Bruijn index of the variable
in \texttt{Γ\ ,\ B}:

\begin{itemize}
\item
  If it is \texttt{Z}, which has type \texttt{B} in \texttt{Γ\ ,\ B},
  then we return \texttt{Z}, which also has type \texttt{B} in
  \texttt{Δ\ ,\ B}.
\item
  If it is \texttt{S\ x}, for some variable \texttt{x} in \texttt{Γ},
  then \texttt{ρ\ x} is a variable in \texttt{Δ}, and hence
  \texttt{S\ (ρ\ x)} is a variable in \texttt{Δ\ ,\ B}.
\end{itemize}

With extension under our belts, it is straightforward to define
renaming. If variables in one context map to variables in another, then
terms in the first context map to terms in the second:

\begin{fence}
\begin{code}
rename : ∀ {Γ Δ}
  → (∀ {A} → Γ ∋ A → Δ ∋ A)
    -----------------------
  → (∀ {A} → Γ ⊢ A → Δ ⊢ A)
rename ρ (` x)          =  ` (ρ x)
rename ρ (ƛ N)          =  ƛ (rename (ext ρ) N)
rename ρ (L · M)        =  (rename ρ L) · (rename ρ M)
rename ρ (`zero)        =  `zero
rename ρ (`suc M)       =  `suc (rename ρ M)
rename ρ (case L M N)   =  case (rename ρ L) (rename ρ M) (rename (ext ρ) N)
rename ρ (μ N)          =  μ (rename (ext ρ) N)
\end{code}
\end{fence}

Let \texttt{ρ} be the name of the map that takes variables in \texttt{Γ}
to variables in \texttt{Δ}. Let's unpack the first three cases:

\begin{itemize}
\item
  If the term is a variable, simply apply \texttt{ρ}.
\item
  If the term is an abstraction, use the previous result to extend the
  map \texttt{ρ} suitably and recursively rename the body of the
  abstraction.
\item
  If the term is an application, recursively rename both the function
  and the argument.
\end{itemize}

The remaining cases are similar, recursing on each subterm, and
extending the map whenever the construct introduces a bound variable.

Whereas before renaming was a result that carried evidence that a term
is well typed in one context to evidence that it is well typed in
another context, now it actually transforms the term, suitably altering
the bound variables. Type checking the code in Agda ensures that it is
only passed and returns terms that are well typed by the rules of
simply-typed lambda calculus.

Here is an example of renaming a term with one free and one bound
variable:

\begin{fence}
\begin{code}
M₀ : ∅ , `ℕ ⇒ `ℕ ⊢ `ℕ ⇒ `ℕ
M₀ = ƛ (# 1 · (# 1 · # 0))

M₁ : ∅ , `ℕ ⇒ `ℕ , `ℕ ⊢ `ℕ ⇒ `ℕ
M₁ = ƛ (# 2 · (# 2 · # 0))

_ : rename S_ M₀ ≡ M₁
_ = refl
\end{code}
\end{fence}

In general, \texttt{rename\ S\_} will increment the de Bruijn index for
each free variable by one, while leaving the index for each bound
variable unchanged. The code achieves this naturally: the map originally
increments each variable by one, and is extended for each bound variable
by a map that leaves it unchanged.

We will see below that renaming by \texttt{S\_} plays a key role in
substitution. For traditional uses of de Bruijn indices without
intrinsic typing, this is a little tricky. The code keeps count of a
number where all greater indexes are free and all smaller indexes bound,
and increment only indexes greater than the number. It's easy to have
off-by-one errors. But it's hard to imagine an off-by-one error that
preserves typing, and hence the Agda code for intrinsically-typed de
Bruijn terms is intrinsically reliable.

\hypertarget{simultaneous-substitution}{%
\section{Simultaneous Substitution}\label{simultaneous-substitution}}

Because de Bruijn indices free us of concerns with renaming, it becomes
easy to provide a definition of substitution that is more general than
the one considered previously. Instead of substituting a closed term for
a single variable, it provides a map that takes each free variable of
the original term to another term. Further, the substituted terms are
over an arbitrary context, and need not be closed.

The structure of the definition and the proof is remarkably close to
that for renaming. Again, we first need an extension lemma that allows
us to extend the context when we encounter a binder. Whereas renaming
concerned a map from variables in one context to variables in another,
substitution takes a map from variables in one context to \emph{terms}
in another. Given a map from variables in one context to terms over
another, extension yields a map from the first context extended to the
second context similarly extended:

\begin{fence}
\begin{code}
exts : ∀ {Γ Δ}
  → (∀ {A} →       Γ ∋ A →     Δ ⊢ A)
    ---------------------------------
  → (∀ {A B} → Γ , B ∋ A → Δ , B ⊢ A)
exts σ Z      =  ` Z
exts σ (S x)  =  rename S_ (σ x)
\end{code}
\end{fence}

Let \texttt{σ} be the name of the map that takes variables in \texttt{Γ}
to terms over \texttt{Δ}. Consider the de Bruijn index of the variable
in \texttt{Γ\ ,\ B}:

\begin{itemize}
\item
  If it is \texttt{Z}, which has type \texttt{B} in \texttt{Γ\ ,\ B},
  then we return the term \texttt{\textasciigrave{}\ Z}, which also has
  type \texttt{B} in \texttt{Δ\ ,\ B}.
\item
  If it is \texttt{S\ x}, for some variable \texttt{x} in \texttt{Γ},
  then \texttt{σ\ x} is a term in \texttt{Δ}, and hence
  \texttt{rename\ S\_\ (σ\ x)} is a term in \texttt{Δ\ ,\ B}.
\end{itemize}

This is why we had to define renaming first, since we require it to
convert a term over context \texttt{Δ} to a term over the extended
context \texttt{Δ\ ,\ B}.

With extension under our belts, it is straightforward to define
substitution. If variables in one context map to terms over another,
then terms in the first context map to terms in the second:

\begin{fence}
\begin{code}
subst : ∀ {Γ Δ}
  → (∀ {A} → Γ ∋ A → Δ ⊢ A)
    -----------------------
  → (∀ {A} → Γ ⊢ A → Δ ⊢ A)
subst σ (` k)          =  σ k
subst σ (ƛ N)          =  ƛ (subst (exts σ) N)
subst σ (L · M)        =  (subst σ L) · (subst σ M)
subst σ (`zero)        =  `zero
subst σ (`suc M)       =  `suc (subst σ M)
subst σ (case L M N)   =  case (subst σ L) (subst σ M) (subst (exts σ) N)
subst σ (μ N)          =  μ (subst (exts σ) N)
\end{code}
\end{fence}

Let \texttt{σ} be the name of the map that takes variables in \texttt{Γ}
to terms over \texttt{Δ}. Let's unpack the first three cases:

\begin{itemize}
\item
  If the term is a variable, simply apply \texttt{σ}.
\item
  If the term is an abstraction, use the previous result to extend the
  map \texttt{σ} suitably and recursively substitute over the body of
  the abstraction.
\item
  If the term is an application, recursively substitute over both the
  function and the argument.
\end{itemize}

The remaining cases are similar, recursing on each subterm, and
extending the map whenever the construct introduces a bound variable.

\hypertarget{single-substitution}{%
\section{Single substitution}\label{single-substitution}}

From the general case of substitution for multiple free variables it is
easy to define the special case of substitution for one free variable:

\begin{fence}
\begin{code}
_[_] : ∀ {Γ A B}
  → Γ , B ⊢ A
  → Γ ⊢ B
    ---------
  → Γ ⊢ A
_[_] {Γ} {A} {B} N M =  subst {Γ , B} {Γ} σ {A} N
  where
  σ : ∀ {A} → Γ , B ∋ A → Γ ⊢ A
  σ Z      =  M
  σ (S x)  =  ` x
\end{code}
\end{fence}

In a term of type \texttt{A} over context \texttt{Γ\ ,\ B}, we replace
the variable of type \texttt{B} by a term of type \texttt{B} over
context \texttt{Γ}. To do so, we use a map from the context
\texttt{Γ\ ,\ B} to the context \texttt{Γ}, that maps the last variable
in the context to the term of type \texttt{B} and every other free
variable to itself.

Consider the previous example:

\begin{itemize}
\tightlist
\item
  \texttt{(ƛ\ "z"\ ⇒\ \textasciigrave{}\ "s"\ ·\ (\textasciigrave{}\ "s"\ ·\ \textasciigrave{}\ "z"))\ {[}\ "s"\ :=\ sucᶜ\ {]}}
  yields \texttt{ƛ\ "z"\ ⇒\ sucᶜ\ ·\ (sucᶜ\ ·\ \textasciigrave{}\ "z")}
\end{itemize}

Here is the example formalised:

\begin{fence}
\begin{code}
M₂ : ∅ , `ℕ ⇒ `ℕ ⊢ `ℕ ⇒ `ℕ
M₂ = ƛ # 1 · (# 1 · # 0)

M₃ : ∅ ⊢ `ℕ ⇒ `ℕ
M₃ = ƛ `suc # 0

M₄ : ∅ ⊢ `ℕ ⇒ `ℕ
M₄ = ƛ (ƛ `suc # 0) · ((ƛ `suc # 0) · # 0)

_ : M₂ [ M₃ ] ≡ M₄
_ = refl
\end{code}
\end{fence}

Previously, we presented an example of substitution that we did not
implement, since it needed to rename the bound variable to avoid
capture:

\begin{itemize}
\tightlist
\item
  \texttt{(ƛ\ "x"\ ⇒\ \textasciigrave{}\ "x"\ ·\ \textasciigrave{}\ "y")\ {[}\ "y"\ :=\ \textasciigrave{}\ "x"\ ·\ \textasciigrave{}zero\ {]}}
  should yield
  \texttt{ƛ\ "z"\ ⇒\ \textasciigrave{}\ "z"\ ·\ (\textasciigrave{}\ "x"\ ·\ \textasciigrave{}zero)}
\end{itemize}

Say the bound \texttt{"x"} has type
\texttt{\textasciigrave{}ℕ\ ⇒\ \textasciigrave{}ℕ}, the substituted
\texttt{"y"} has type \texttt{\textasciigrave{}ℕ}, and the free
\texttt{"x"} also has type
\texttt{\textasciigrave{}ℕ\ ⇒\ \textasciigrave{}ℕ}. Here is the example
formalised:

\begin{fence}
\begin{code}
M₅ : ∅ , `ℕ ⇒ `ℕ , `ℕ ⊢ (`ℕ ⇒ `ℕ) ⇒ `ℕ
M₅ = ƛ # 0 · # 1

M₆ : ∅ , `ℕ ⇒ `ℕ ⊢ `ℕ
M₆ = # 0 · `zero

M₇ : ∅ , `ℕ ⇒ `ℕ ⊢ (`ℕ ⇒ `ℕ) ⇒ `ℕ
M₇ = ƛ (# 0 · (# 1 · `zero))

_ : M₅ [ M₆ ] ≡ M₇
_ = refl
\end{code}
\end{fence}

The logician Haskell Curry observed that getting the definition of
substitution right can be a tricky business. It can be even trickier
when using de Bruijn indices, which can often be hard to decipher. Under
the current approach, any definition of substitution must, of necessity,
preserve types. While this makes the definition more involved, it means
that once it is done the hardest work is out of the way. And combining
definition with proof makes it harder for errors to sneak in.

\hypertarget{values}{%
\section{Values}\label{values}}

The definition of value is much as before, save that the added types
incorporate the same information found in the Canonical Forms lemma:

\begin{fence}
\begin{code}
data Value : ∀ {Γ A} → Γ ⊢ A → Set where

  V-ƛ : ∀ {Γ A B} {N : Γ , A ⊢ B}
      ---------------------------
    → Value (ƛ N)

  V-zero : ∀ {Γ}
      -----------------
    → Value (`zero {Γ})

  V-suc : ∀ {Γ} {V : Γ ⊢ `ℕ}
    → Value V
      --------------
    → Value (`suc V)
\end{code}
\end{fence}

Here \texttt{zero} requires an implicit parameter to aid inference, much
in the same way that \texttt{{[}{]}} did in
\protect\hyperlink{Lists}{Lists}.

\hypertarget{reduction}{%
\section{Reduction}\label{reduction}}

The reduction rules are the same as those given earlier, save that for
each term we must specify its types. As before, we have compatibility
rules that reduce a part of a term, labelled with \texttt{ξ}, and rules
that simplify a constructor combined with a destructor, labelled with
\texttt{β}:

\begin{fence}
\begin{code}
infix 2 _—→_

data _—→_ : ∀ {Γ A} → (Γ ⊢ A) → (Γ ⊢ A) → Set where

  ξ-·₁ : ∀ {Γ A B} {L L′ : Γ ⊢ A ⇒ B} {M : Γ ⊢ A}
    → L —→ L′
      ---------------
    → L · M —→ L′ · M

  ξ-·₂ : ∀ {Γ A B} {V : Γ ⊢ A ⇒ B} {M M′ : Γ ⊢ A}
    → Value V
    → M —→ M′
      ---------------
    → V · M —→ V · M′

  β-ƛ : ∀ {Γ A B} {N : Γ , A ⊢ B} {W : Γ ⊢ A}
    → Value W
      --------------------
    → (ƛ N) · W —→ N [ W ]

  ξ-suc : ∀ {Γ} {M M′ : Γ ⊢ `ℕ}
    → M —→ M′
      -----------------
    → `suc M —→ `suc M′

  ξ-case : ∀ {Γ A} {L L′ : Γ ⊢ `ℕ} {M : Γ ⊢ A} {N : Γ , `ℕ ⊢ A}
    → L —→ L′
      -------------------------
    → case L M N —→ case L′ M N

  β-zero :  ∀ {Γ A} {M : Γ ⊢ A} {N : Γ , `ℕ ⊢ A}
      -------------------
    → case `zero M N —→ M

  β-suc : ∀ {Γ A} {V : Γ ⊢ `ℕ} {M : Γ ⊢ A} {N : Γ , `ℕ ⊢ A}
    → Value V
      ----------------------------
    → case (`suc V) M N —→ N [ V ]

  β-μ : ∀ {Γ A} {N : Γ , A ⊢ A}
      ----------------
    → μ N —→ N [ μ N ]
\end{code}
\end{fence}

The definition states that \texttt{M\ —→\ N} can only hold of terms
\texttt{M} and \texttt{N} which \emph{both} have type \texttt{Γ\ ⊢\ A}
for some context \texttt{Γ} and type \texttt{A}. In other words, it is
\emph{built-in} to our definition that reduction preserves types. There
is no separate Preservation theorem to prove. The Agda type-checker
validates that each term preserves types. In the case of \texttt{β}
rules, preservation depends on the fact that substitution preserves
types, which is built-in to our definition of substitution.

\hypertarget{reflexive-and-transitive-closure}{%
\section{Reflexive and transitive
closure}\label{reflexive-and-transitive-closure}}

The reflexive and transitive closure is exactly as before. We simply
cut-and-paste the previous definition:

\begin{fence}
\begin{code}
infix  2 _—↠_
infix  1 begin_
infixr 2 _—→⟨_⟩_
infix  3 _∎

data _—↠_ {Γ A} : (Γ ⊢ A) → (Γ ⊢ A) → Set where

  _∎ : (M : Γ ⊢ A)
      ------
    → M —↠ M

  _—→⟨_⟩_ : (L : Γ ⊢ A) {M N : Γ ⊢ A}
    → L —→ M
    → M —↠ N
      ------
    → L —↠ N

begin_ : ∀ {Γ A} {M N : Γ ⊢ A}
  → M —↠ N
    ------
  → M —↠ N
begin M—↠N = M—↠N
\end{code}
\end{fence}

\hypertarget{examples}{%
\section{Examples}\label{examples}}

We reiterate each of our previous examples. First, the Church numeral
two applied to the successor function and zero yields the natural number
two:

\begin{fence}
\begin{code}
_ : twoᶜ · sucᶜ · `zero {∅} —↠ `suc `suc `zero
_ =
  begin
    twoᶜ · sucᶜ · `zero
  —→⟨ ξ-·₁ (β-ƛ V-ƛ) ⟩
    (ƛ (sucᶜ · (sucᶜ · # 0))) · `zero
  —→⟨ β-ƛ V-zero ⟩
    sucᶜ · (sucᶜ · `zero)
  —→⟨ ξ-·₂ V-ƛ (β-ƛ V-zero) ⟩
    sucᶜ · `suc `zero
  —→⟨ β-ƛ (V-suc V-zero) ⟩
   `suc (`suc `zero)
  ∎
\end{code}
\end{fence}

As before, we need to supply an explicit context to
\texttt{\textasciigrave{}zero}.

Next, a sample reduction demonstrating that two plus two is four:

\begin{fence}
\begin{code}
_ : plus {∅} · two · two —↠ `suc `suc `suc `suc `zero
_ =
    plus · two · two
  —→⟨ ξ-·₁ (ξ-·₁ β-μ) ⟩
    (ƛ ƛ case (` S Z) (` Z) (`suc (plus · ` Z · ` S Z))) · two · two
  —→⟨ ξ-·₁ (β-ƛ (V-suc (V-suc V-zero))) ⟩
    (ƛ case two (` Z) (`suc (plus · ` Z · ` S Z))) · two
  —→⟨ β-ƛ (V-suc (V-suc V-zero)) ⟩
    case two two (`suc (plus · ` Z · two))
  —→⟨ β-suc (V-suc V-zero) ⟩
    `suc (plus · `suc `zero · two)
  —→⟨ ξ-suc (ξ-·₁ (ξ-·₁ β-μ)) ⟩
    `suc ((ƛ ƛ case (` S Z) (` Z) (`suc (plus · ` Z · ` S Z)))
      · `suc `zero · two)
  —→⟨ ξ-suc (ξ-·₁ (β-ƛ (V-suc V-zero))) ⟩
    `suc ((ƛ case (`suc `zero) (` Z) (`suc (plus · ` Z · ` S Z))) · two)
  —→⟨ ξ-suc (β-ƛ (V-suc (V-suc V-zero))) ⟩
    `suc (case (`suc `zero) (two) (`suc (plus · ` Z · two)))
  —→⟨ ξ-suc (β-suc V-zero) ⟩
    `suc (`suc (plus · `zero · two))
  —→⟨ ξ-suc (ξ-suc (ξ-·₁ (ξ-·₁ β-μ))) ⟩
    `suc (`suc ((ƛ ƛ case (` S Z) (` Z) (`suc (plus · ` Z · ` S Z)))
      · `zero · two))
  —→⟨ ξ-suc (ξ-suc (ξ-·₁ (β-ƛ V-zero))) ⟩
    `suc (`suc ((ƛ case `zero (` Z) (`suc (plus · ` Z · ` S Z))) · two))
  —→⟨ ξ-suc (ξ-suc (β-ƛ (V-suc (V-suc V-zero)))) ⟩
    `suc (`suc (case `zero (two) (`suc (plus · ` Z · two))))
  —→⟨ ξ-suc (ξ-suc β-zero) ⟩
   `suc (`suc (`suc (`suc `zero)))
  ∎
\end{code}
\end{fence}

And finally, a similar sample reduction for Church numerals:

\begin{fence}
\begin{code}
_ : plusᶜ · twoᶜ · twoᶜ · sucᶜ · `zero —↠ `suc `suc `suc `suc `zero {∅}
_ =
  begin
    plusᶜ · twoᶜ · twoᶜ · sucᶜ · `zero
  —→⟨ ξ-·₁ (ξ-·₁ (ξ-·₁ (β-ƛ V-ƛ))) ⟩
    (ƛ ƛ ƛ twoᶜ · ` S Z · (` S S Z · ` S Z · ` Z)) · twoᶜ · sucᶜ · `zero
  —→⟨ ξ-·₁ (ξ-·₁ (β-ƛ V-ƛ)) ⟩
    (ƛ ƛ twoᶜ · ` S Z · (twoᶜ · ` S Z · ` Z)) · sucᶜ · `zero
  —→⟨ ξ-·₁ (β-ƛ V-ƛ) ⟩
    (ƛ twoᶜ · sucᶜ · (twoᶜ · sucᶜ · ` Z)) · `zero
  —→⟨ β-ƛ V-zero ⟩
    twoᶜ · sucᶜ · (twoᶜ · sucᶜ · `zero)
  —→⟨ ξ-·₁ (β-ƛ V-ƛ) ⟩
    (ƛ sucᶜ · (sucᶜ · ` Z)) · (twoᶜ · sucᶜ · `zero)
  —→⟨ ξ-·₂ V-ƛ (ξ-·₁ (β-ƛ V-ƛ)) ⟩
    (ƛ sucᶜ · (sucᶜ · ` Z)) · ((ƛ sucᶜ · (sucᶜ · ` Z)) · `zero)
  —→⟨ ξ-·₂ V-ƛ (β-ƛ V-zero) ⟩
    (ƛ sucᶜ · (sucᶜ · ` Z)) · (sucᶜ · (sucᶜ · `zero))
  —→⟨ ξ-·₂ V-ƛ (ξ-·₂ V-ƛ (β-ƛ V-zero)) ⟩
    (ƛ sucᶜ · (sucᶜ · ` Z)) · (sucᶜ · `suc `zero)
  —→⟨ ξ-·₂ V-ƛ (β-ƛ (V-suc V-zero)) ⟩
    (ƛ sucᶜ · (sucᶜ · ` Z)) · `suc (`suc `zero)
  —→⟨ β-ƛ (V-suc (V-suc V-zero)) ⟩
    sucᶜ · (sucᶜ · `suc (`suc `zero))
  —→⟨ ξ-·₂ V-ƛ (β-ƛ (V-suc (V-suc V-zero))) ⟩
    sucᶜ · `suc (`suc (`suc `zero))
  —→⟨ β-ƛ (V-suc (V-suc (V-suc V-zero))) ⟩
    `suc (`suc (`suc (`suc `zero)))
  ∎
\end{code}
\end{fence}

\hypertarget{values-do-not-reduce}{%
\section{Values do not reduce}\label{values-do-not-reduce}}

We have now completed all the definitions, which of necessity subsumed
some of the propositions from the earlier development: Canonical Forms,
Substitution preserves types, and Preservation. We now turn to proving
the remaining results from the previous development.

\hypertarget{exercise-v-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{V¬—→}
(practice)}{Exercise V¬---→ (practice)}}\label{exercise-v-practice}}

Following the previous development, show values do not reduce, and its
corollary, terms that reduce are not values.

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{progress}{%
\section{Progress}\label{progress}}

As before, every term that is well typed and closed is either a value or
takes a reduction step. The formulation of progress is just as before,
but annotated with types:

\begin{fence}
\begin{code}
data Progress {A} (M : ∅ ⊢ A) : Set where

  step : ∀ {N : ∅ ⊢ A}
    → M —→ N
      ----------
    → Progress M

  done :
      Value M
      ----------
    → Progress M
\end{code}
\end{fence}

The statement and proof of progress is much as before, appropriately
annotated. We no longer need to explicitly refer to the Canonical Forms
lemma, since it is built-in to the definition of value:

\begin{fence}
\begin{code}
progress : ∀ {A} → (M : ∅ ⊢ A) → Progress M
progress (` ())
progress (ƛ N)                          =  done V-ƛ
progress (L · M) with progress L
...    | step L—→L′                     =  step (ξ-·₁ L—→L′)
...    | done V-ƛ with progress M
...        | step M—→M′                 =  step (ξ-·₂ V-ƛ M—→M′)
...        | done VM                    =  step (β-ƛ VM)
progress (`zero)                        =  done V-zero
progress (`suc M) with progress M
...    | step M—→M′                     =  step (ξ-suc M—→M′)
...    | done VM                        =  done (V-suc VM)
progress (case L M N) with progress L
...    | step L—→L′                     =  step (ξ-case L—→L′)
...    | done V-zero                    =  step (β-zero)
...    | done (V-suc VL)                =  step (β-suc VL)
progress (μ N)                          =  step (β-μ)
\end{code}
\end{fence}

\hypertarget{evaluation}{%
\section{Evaluation}\label{evaluation}}

Before, we combined progress and preservation to evaluate a term. We can
do much the same here, but we no longer need to explicitly refer to
preservation, since it is built-in to the definition of reduction.

As previously, gas is specified by a natural number:

\begin{fence}
\begin{code}
record Gas : Set where
  constructor gas
  field
    amount : ℕ
\end{code}
\end{fence}

When our evaluator returns a term \texttt{N}, it will either give
evidence that \texttt{N} is a value or indicate that it ran out of gas:

\begin{fence}
\begin{code}
data Finished {Γ A} (N : Γ ⊢ A) : Set where

   done :
       Value N
       ----------
     → Finished N

   out-of-gas :
       ----------
       Finished N
\end{code}
\end{fence}

Given a term \texttt{L} of type \texttt{A}, the evaluator will, for some
\texttt{N}, return a reduction sequence from \texttt{L} to \texttt{N}
and an indication of whether reduction finished:

\begin{fence}
\begin{code}
data Steps {A} : ∅ ⊢ A → Set where

  steps : {L N : ∅ ⊢ A}
    → L —↠ N
    → Finished N
      ----------
    → Steps L
\end{code}
\end{fence}

The evaluator takes gas and a term and returns the corresponding steps:

\begin{fence}
\begin{code}
eval : ∀ {A}
  → Gas
  → (L : ∅ ⊢ A)
    -----------
  → Steps L
eval (gas zero)    L                     =  steps (L ∎) out-of-gas
eval (gas (suc m)) L with progress L
... | done VL                            =  steps (L ∎) (done VL)
... | step {M} L—→M with eval (gas m) M
...    | steps M—↠N fin                  =  steps (L —→⟨ L—→M ⟩ M—↠N) fin
\end{code}
\end{fence}

The definition is a little simpler than previously, as we no longer need
to invoke preservation.

\hypertarget{examples-1}{%
\section{Examples}\label{examples-1}}

We reiterate each of our previous examples. We re-define the term
\texttt{sucμ} that loops forever:

\begin{fence}
\begin{code}
sucμ : ∅ ⊢ `ℕ
sucμ = μ (`suc (# 0))
\end{code}
\end{fence}

To compute the first three steps of the infinite reduction sequence, we
evaluate with three steps worth of gas:

\begin{fence}
\begin{code}
_ : eval (gas 3) sucμ ≡
  steps
   (μ `suc ` Z
   —→⟨ β-μ ⟩
    `suc (μ `suc ` Z)
   —→⟨ ξ-suc β-μ ⟩
    `suc (`suc (μ `suc ` Z))
   —→⟨ ξ-suc (ξ-suc β-μ) ⟩
    `suc (`suc (`suc (μ `suc ` Z)))
   ∎)
   out-of-gas
_ = refl
\end{code}
\end{fence}

The Church numeral two applied to successor and zero:

\begin{fence}
\begin{code}
_ : eval (gas 100) (twoᶜ · sucᶜ · `zero) ≡
  steps
   ((ƛ (ƛ ` (S Z) · (` (S Z) · ` Z))) · (ƛ `suc ` Z) · `zero
   —→⟨ ξ-·₁ (β-ƛ V-ƛ) ⟩
    (ƛ (ƛ `suc ` Z) · ((ƛ `suc ` Z) · ` Z)) · `zero
   —→⟨ β-ƛ V-zero ⟩
    (ƛ `suc ` Z) · ((ƛ `suc ` Z) · `zero)
   —→⟨ ξ-·₂ V-ƛ (β-ƛ V-zero) ⟩
    (ƛ `suc ` Z) · `suc `zero
   —→⟨ β-ƛ (V-suc V-zero) ⟩
    `suc (`suc `zero)
   ∎)
   (done (V-suc (V-suc V-zero)))
_ = refl
\end{code}
\end{fence}

Two plus two is four:

\begin{fence}
\begin{code}
_ : eval (gas 100) (plus · two · two) ≡
  steps
   ((μ
     (ƛ
      (ƛ
       case (` (S Z)) (` Z) (`suc (` (S (S (S Z))) · ` Z · ` (S Z))))))
    · `suc (`suc `zero)
    · `suc (`suc `zero)
   —→⟨ ξ-·₁ (ξ-·₁ β-μ) ⟩
    (ƛ
     (ƛ
      case (` (S Z)) (` Z)
      (`suc
       ((μ
         (ƛ
          (ƛ
           case (` (S Z)) (` Z) (`suc (` (S (S (S Z))) · ` Z · ` (S Z))))))
        · ` Z
        · ` (S Z)))))
    · `suc (`suc `zero)
    · `suc (`suc `zero)
   —→⟨ ξ-·₁ (β-ƛ (V-suc (V-suc V-zero))) ⟩
    (ƛ
     case (`suc (`suc `zero)) (` Z)
     (`suc
      ((μ
        (ƛ
         (ƛ
          case (` (S Z)) (` Z) (`suc (` (S (S (S Z))) · ` Z · ` (S Z))))))
       · ` Z
       · ` (S Z))))
    · `suc (`suc `zero)
   —→⟨ β-ƛ (V-suc (V-suc V-zero)) ⟩
    case (`suc (`suc `zero)) (`suc (`suc `zero))
    (`suc
     ((μ
       (ƛ
        (ƛ
         case (` (S Z)) (` Z) (`suc (` (S (S (S Z))) · ` Z · ` (S Z))))))
      · ` Z
      · `suc (`suc `zero)))
   —→⟨ β-suc (V-suc V-zero) ⟩
    `suc
    ((μ
      (ƛ
       (ƛ
        case (` (S Z)) (` Z) (`suc (` (S (S (S Z))) · ` Z · ` (S Z))))))
     · `suc `zero
     · `suc (`suc `zero))
   —→⟨ ξ-suc (ξ-·₁ (ξ-·₁ β-μ)) ⟩
    `suc
    ((ƛ
      (ƛ
       case (` (S Z)) (` Z)
       (`suc
        ((μ
          (ƛ
           (ƛ
            case (` (S Z)) (` Z) (`suc (` (S (S (S Z))) · ` Z · ` (S Z))))))
         · ` Z
         · ` (S Z)))))
     · `suc `zero
     · `suc (`suc `zero))
   —→⟨ ξ-suc (ξ-·₁ (β-ƛ (V-suc V-zero))) ⟩
    `suc
    ((ƛ
      case (`suc `zero) (` Z)
      (`suc
       ((μ
         (ƛ
          (ƛ
           case (` (S Z)) (` Z) (`suc (` (S (S (S Z))) · ` Z · ` (S Z))))))
        · ` Z
        · ` (S Z))))
     · `suc (`suc `zero))
   —→⟨ ξ-suc (β-ƛ (V-suc (V-suc V-zero))) ⟩
    `suc
    case (`suc `zero) (`suc (`suc `zero))
    (`suc
     ((μ
       (ƛ
        (ƛ
         case (` (S Z)) (` Z) (`suc (` (S (S (S Z))) · ` Z · ` (S Z))))))
      · ` Z
      · `suc (`suc `zero)))
   —→⟨ ξ-suc (β-suc V-zero) ⟩
    `suc
    (`suc
     ((μ
       (ƛ
        (ƛ
         case (` (S Z)) (` Z) (`suc (` (S (S (S Z))) · ` Z · ` (S Z))))))
      · `zero
      · `suc (`suc `zero)))
   —→⟨ ξ-suc (ξ-suc (ξ-·₁ (ξ-·₁ β-μ))) ⟩
    `suc
    (`suc
     ((ƛ
       (ƛ
        case (` (S Z)) (` Z)
        (`suc
         ((μ
           (ƛ
            (ƛ
             case (` (S Z)) (` Z) (`suc (` (S (S (S Z))) · ` Z · ` (S Z))))))
          · ` Z
          · ` (S Z)))))
      · `zero
      · `suc (`suc `zero)))
   —→⟨ ξ-suc (ξ-suc (ξ-·₁ (β-ƛ V-zero))) ⟩
    `suc
    (`suc
     ((ƛ
       case `zero (` Z)
       (`suc
        ((μ
          (ƛ
           (ƛ
            case (` (S Z)) (` Z) (`suc (` (S (S (S Z))) · ` Z · ` (S Z))))))
         · ` Z
         · ` (S Z))))
      · `suc (`suc `zero)))
   —→⟨ ξ-suc (ξ-suc (β-ƛ (V-suc (V-suc V-zero)))) ⟩
    `suc
    (`suc
     case `zero (`suc (`suc `zero))
     (`suc
      ((μ
        (ƛ
         (ƛ
          case (` (S Z)) (` Z) (`suc (` (S (S (S Z))) · ` Z · ` (S Z))))))
       · ` Z
       · `suc (`suc `zero))))
   —→⟨ ξ-suc (ξ-suc β-zero) ⟩
    `suc (`suc (`suc (`suc `zero)))
   ∎)
   (done (V-suc (V-suc (V-suc (V-suc V-zero)))))
_ = refl
\end{code}
\end{fence}

And the corresponding term for Church numerals:

\begin{fence}
\begin{code}
_ : eval (gas 100) (plusᶜ · twoᶜ · twoᶜ · sucᶜ · `zero) ≡
  steps
   ((ƛ
     (ƛ
      (ƛ (ƛ ` (S (S (S Z))) · ` (S Z) · (` (S (S Z)) · ` (S Z) · ` Z)))))
    · (ƛ (ƛ ` (S Z) · (` (S Z) · ` Z)))
    · (ƛ (ƛ ` (S Z) · (` (S Z) · ` Z)))
    · (ƛ `suc ` Z)
    · `zero
   —→⟨ ξ-·₁ (ξ-·₁ (ξ-·₁ (β-ƛ V-ƛ))) ⟩
    (ƛ
     (ƛ
      (ƛ
       (ƛ (ƛ ` (S Z) · (` (S Z) · ` Z))) · ` (S Z) ·
       (` (S (S Z)) · ` (S Z) · ` Z))))
    · (ƛ (ƛ ` (S Z) · (` (S Z) · ` Z)))
    · (ƛ `suc ` Z)
    · `zero
   —→⟨ ξ-·₁ (ξ-·₁ (β-ƛ V-ƛ)) ⟩
    (ƛ
     (ƛ
      (ƛ (ƛ ` (S Z) · (` (S Z) · ` Z))) · ` (S Z) ·
      ((ƛ (ƛ ` (S Z) · (` (S Z) · ` Z))) · ` (S Z) · ` Z)))
    · (ƛ `suc ` Z)
    · `zero
   —→⟨ ξ-·₁ (β-ƛ V-ƛ) ⟩
    (ƛ
     (ƛ (ƛ ` (S Z) · (` (S Z) · ` Z))) · (ƛ `suc ` Z) ·
     ((ƛ (ƛ ` (S Z) · (` (S Z) · ` Z))) · (ƛ `suc ` Z) · ` Z))
    · `zero
   —→⟨ β-ƛ V-zero ⟩
    (ƛ (ƛ ` (S Z) · (` (S Z) · ` Z))) · (ƛ `suc ` Z) ·
    ((ƛ (ƛ ` (S Z) · (` (S Z) · ` Z))) · (ƛ `suc ` Z) · `zero)
   —→⟨ ξ-·₁ (β-ƛ V-ƛ) ⟩
    (ƛ (ƛ `suc ` Z) · ((ƛ `suc ` Z) · ` Z)) ·
    ((ƛ (ƛ ` (S Z) · (` (S Z) · ` Z))) · (ƛ `suc ` Z) · `zero)
   —→⟨ ξ-·₂ V-ƛ (ξ-·₁ (β-ƛ V-ƛ)) ⟩
    (ƛ (ƛ `suc ` Z) · ((ƛ `suc ` Z) · ` Z)) ·
    ((ƛ (ƛ `suc ` Z) · ((ƛ `suc ` Z) · ` Z)) · `zero)
   —→⟨ ξ-·₂ V-ƛ (β-ƛ V-zero) ⟩
    (ƛ (ƛ `suc ` Z) · ((ƛ `suc ` Z) · ` Z)) ·
    ((ƛ `suc ` Z) · ((ƛ `suc ` Z) · `zero))
   —→⟨ ξ-·₂ V-ƛ (ξ-·₂ V-ƛ (β-ƛ V-zero)) ⟩
    (ƛ (ƛ `suc ` Z) · ((ƛ `suc ` Z) · ` Z)) ·
    ((ƛ `suc ` Z) · `suc `zero)
   —→⟨ ξ-·₂ V-ƛ (β-ƛ (V-suc V-zero)) ⟩
    (ƛ (ƛ `suc ` Z) · ((ƛ `suc ` Z) · ` Z)) · `suc (`suc `zero)
   —→⟨ β-ƛ (V-suc (V-suc V-zero)) ⟩
    (ƛ `suc ` Z) · ((ƛ `suc ` Z) · `suc (`suc `zero))
   —→⟨ ξ-·₂ V-ƛ (β-ƛ (V-suc (V-suc V-zero))) ⟩
    (ƛ `suc ` Z) · `suc (`suc (`suc `zero))
   —→⟨ β-ƛ (V-suc (V-suc (V-suc V-zero))) ⟩
    `suc (`suc (`suc (`suc `zero)))
   ∎)
   (done (V-suc (V-suc (V-suc (V-suc V-zero)))))
_ = refl
\end{code}
\end{fence}

We omit the proof that reduction is deterministic, since it is tedious
and almost identical to the previous proof.

\hypertarget{exercise-mul-example-recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{mul-example}
(recommended)}{Exercise mul-example (recommended)}}\label{exercise-mul-example-recommended}}

Using the evaluator, confirm that two times two is four.

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{intrinsic-typing-is-golden}{%
\section{Intrinsic typing is golden}\label{intrinsic-typing-is-golden}}

Counting the lines of code is instructive. While this chapter covers the
same formal development as the previous two chapters, it has much less
code. Omitting all the examples, and all proofs that appear in
Properties but not DeBruijn (such as the proof that reduction is
deterministic), the number of lines of code is as follows:

\begin{myDisplay}
Lambda                      216
Properties                  235
DeBruijn                    276
\end{myDisplay}

The relation between the two approaches approximates the golden ratio:
extrinsically-typed terms require about 1.6 times as much code as
intrinsically-typed.

\hypertarget{unicode}{%
\section{Unicode}\label{unicode}}

This chapter uses the following unicode:

\begin{myDisplay}
σ  U+03C3  GREEK SMALL LETTER SIGMA (\Gs or \sigma)
₀  U+2080  SUBSCRIPT ZERO (\_0)
₃  U+20B3  SUBSCRIPT THREE (\_3)
₄  U+2084  SUBSCRIPT FOUR (\_4)
₅  U+2085  SUBSCRIPT FIVE (\_5)
₆  U+2086  SUBSCRIPT SIX (\_6)
₇  U+2087  SUBSCRIPT SEVEN (\_7)
≠  U+2260  NOT EQUAL TO (\=n)
\end{myDisplay}

