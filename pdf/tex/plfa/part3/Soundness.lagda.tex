\hypertarget{Soundness}{%
\chapter{Soundness: Soundness of reduction with respect to denotational
semantics}\label{Soundness}}

\begin{fence}
\begin{code}
module plfa.part3.Soundness where
\end{code}
\end{fence}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

In this chapter we prove that the reduction semantics is sound with
respect to the denotational semantics, i.e., for any term L

\begin{myDisplay}
L —↠ ƛ N  implies  ℰ L ≃ ℰ (ƛ N)
\end{myDisplay}

The proof is by induction on the reduction sequence, so the main lemma
concerns a single reduction step. We prove that if any term \texttt{M}
steps to a term \texttt{N}, then \texttt{M} and \texttt{N} are
denotationally equal. We shall prove each direction of this
if-and-only-if separately. One direction will look just like a type
preservation proof. The other direction is like proving type
preservation for reduction going in reverse. Recall that type
preservation is sometimes called subject reduction. Preservation in
reverse is a well-known property and is called \emph{subject expansion}.
It is also well-known that subject expansion is false for most typed
lambda calculi!

\hypertarget{imports}{%
\section{Imports}\label{imports}}

\begin{fence}
\begin{code}
open import Relation.Binary.PropositionalEquality
  using (_≡_; _≢_; refl; sym; cong; cong₂; cong-app)
open import Data.Product using (_×_; Σ; Σ-syntax; ∃; ∃-syntax; proj₁; proj₂)
  renaming (_,_ to ⟨_,_⟩)
open import Agda.Primitive using (lzero)
open import Relation.Nullary using (¬_)
open import Relation.Nullary.Negation using (contradiction)
open import Data.Empty using (⊥-elim)
open import Relation.Nullary using (Dec; yes; no)
open import Function using (_∘_)
open import plfa.part2.Untyped
     using (Context; _,_; _∋_; _⊢_; ★; Z; S_; `_; ƛ_; _·_;
            subst; _[_]; subst-zero; ext; rename; exts;
            _—→_; ξ₁; ξ₂; β; ζ; _—↠_; _—→⟨_⟩_; _∎)
open import plfa.part2.Substitution using (Rename; Subst; ids)
open import plfa.part3.Denotational
     using (Value; ⊥; Env; _⊢_↓_; _`,_; _⊑_; _`⊑_; `⊥; _`⊔_; init; last; init-last;
            ⊑-refl; ⊑-trans; `⊑-refl; ⊑-env; ⊑-env-conj-R1; ⊑-env-conj-R2; up-env;
            var; ↦-elim; ↦-intro; ⊥-intro; ⊔-intro; sub;
            rename-pres; ℰ; _≃_; ≃-trans)
open import plfa.part3.Compositional using (lambda-inversion; var-inv)
\end{code}
\end{fence}

\hypertarget{forward-reduction-preserves-denotations}{%
\section{Forward reduction preserves
denotations}\label{forward-reduction-preserves-denotations}}

The proof of preservation in this section mixes techniques from previous
chapters. Like the proof of preservation for the STLC, we are preserving
a relation defined separately from the syntax, in contrast to the
intrinsically-typed terms. On the other hand, we are using de Bruijn
indices for variables.

The outline of the proof remains the same in that we must prove lemmas
concerning all of the auxiliary functions used in the reduction
relation: substitution, renaming, and extension.

\hypertarget{simultaneous-substitution-preserves-denotations}{%
\subsection{Simultaneous substitution preserves
denotations}\label{simultaneous-substitution-preserves-denotations}}

Our next goal is to prove that simultaneous substitution preserves
meaning. That is, if \texttt{M} results in \texttt{v} in environment
\texttt{γ}, then applying a substitution \texttt{σ} to \texttt{M} gives
us a program that also results in \texttt{v}, but in an environment
\texttt{δ} in which, for every variable \texttt{x}, \texttt{σ\ x}
results in the same value as the one for \texttt{x} in the original
environment \texttt{γ}. We write \texttt{δ\ ⊢\ σ\ ↓\ γ} for this
condition.

\begin{fence}
\begin{code}
infix 3 _`⊢_↓_
_`⊢_↓_ : ∀{Δ Γ} → Env Δ → Subst Γ Δ → Env Γ → Set
_`⊢_↓_ {Δ}{Γ} δ σ γ = (∀ (x : Γ ∋ ★) → δ ⊢ σ x ↓ γ x)
\end{code}
\end{fence}

As usual, to prepare for lambda abstraction, we prove an extension
lemma. It says that applying the \texttt{exts} function to a
substitution produces a new substitution that maps variables to terms
that when evaluated in \texttt{δ\ ,\ v} produce the values in
\texttt{γ\ ,\ v}.

\begin{fence}
\begin{code}
subst-ext : ∀ {Γ Δ v} {γ : Env Γ} {δ : Env Δ}
  → (σ : Subst Γ Δ)
  → δ `⊢ σ ↓ γ
   --------------------------
  → δ `, v `⊢ exts σ ↓ γ `, v
subst-ext σ d Z = var
subst-ext σ d (S x′) = rename-pres S_ (λ _ → ⊑-refl) (d x′)
\end{code}
\end{fence}

The proof is by cases on the de Bruijn index \texttt{x}.

\begin{itemize}
\item
  If it is \texttt{Z}, then we need to show that
  \texttt{δ\ ,\ v\ ⊢\ \#\ 0\ ↓\ v}, which we have by rule \texttt{var}.
\item
  If it is \texttt{S\ x′},then we need to show that
  \texttt{δ\ ,\ v\ ⊢\ rename\ S\_\ (σ\ x′)\ ↓\ γ\ x′}, which we obtain
  by the \texttt{rename-pres} lemma.
\end{itemize}

With the extension lemma in hand, the proof that simultaneous
substitution preserves meaning is straightforward. Let's dive in!

\begin{fence}
\begin{code}
subst-pres : ∀ {Γ Δ v} {γ : Env Γ} {δ : Env Δ} {M : Γ ⊢ ★}
  → (σ : Subst Γ Δ)
  → δ `⊢ σ ↓ γ
  → γ ⊢ M ↓ v
    ------------------
  → δ ⊢ subst σ M ↓ v
subst-pres σ s (var {x = x}) = (s x)
subst-pres σ s (↦-elim d₁ d₂) =
  ↦-elim (subst-pres σ s d₁) (subst-pres σ s d₂)
subst-pres σ s (↦-intro d) =
  ↦-intro (subst-pres (λ {A} → exts σ) (subst-ext σ s) d)
subst-pres σ s ⊥-intro = ⊥-intro
subst-pres σ s (⊔-intro d₁ d₂) =
  ⊔-intro (subst-pres σ s d₁) (subst-pres σ s d₂)
subst-pres σ s (sub d lt) = sub (subst-pres σ s d) lt
\end{code}
\end{fence}

The proof is by induction on the semantics of \texttt{M}. The two
interesting cases are for variables and lambda abstractions.

\begin{itemize}
\item
  For a variable \texttt{x}, we have that \texttt{v\ ⊑\ γ\ x} and we
  need to show that \texttt{δ\ ⊢\ σ\ x\ ↓\ v}. From the premise applied
  to \texttt{x}, we have that \texttt{δ\ ⊢\ σ\ x\ ↓\ γ\ x}, so we
  conclude by the \texttt{sub} rule.
\item
  For a lambda abstraction, we must extend the substitution for the
  induction hypothesis. We apply the \texttt{subst-ext} lemma to show
  that the extended substitution maps variables to terms that result in
  the appropriate values.
\end{itemize}

\hypertarget{single-substitution-preserves-denotations}{%
\subsection{Single substitution preserves
denotations}\label{single-substitution-preserves-denotations}}

For β reduction, \texttt{(ƛ\ N)\ ·\ M\ —→\ N\ {[}\ M\ {]}}, we need to
show that the semantics is preserved when substituting \texttt{M} for de
Bruijn index 0 in term \texttt{N}. By inversion on the rules
\texttt{↦-elim} and \texttt{↦-intro}, we have that
\texttt{γ\ ,\ v\ ⊢\ M\ ↓\ w} and \texttt{γ\ ⊢\ N\ ↓\ v}. So we need to
show that \texttt{γ\ ⊢\ M\ {[}\ N\ {]}\ ↓\ w}, or equivalently, that
\texttt{γ\ ⊢\ subst\ (subst-zero\ N)\ M\ ↓\ w}.

\begin{fence}
\begin{code}
substitution : ∀ {Γ} {γ : Env Γ} {N M v w}
   → γ `, v ⊢ N ↓ w
   → γ ⊢ M ↓ v
     ---------------
   → γ ⊢ N [ M ] ↓ w
substitution{Γ}{γ}{N}{M}{v}{w} dn dm =
  subst-pres (subst-zero M) sub-z-ok dn
  where
  sub-z-ok : γ `⊢ subst-zero M ↓ (γ `, v)
  sub-z-ok Z = dm
  sub-z-ok (S x) = var
\end{code}
\end{fence}

This result is a corollary of the lemma for simultaneous substitution.
To use the lemma, we just need to show that \texttt{subst-zero\ M} maps
variables to terms that produces the same values as those in
\texttt{γ\ ,\ v}. Let \texttt{y} be an arbitrary variable (de Bruijn
index).

\begin{itemize}
\item
  If it is \texttt{Z}, then \texttt{(subst-zero\ M)\ y\ =\ M} and
  \texttt{(γ\ ,\ v)\ y\ =\ v}. By the premise we conclude that
  \texttt{γ\ ⊢\ M\ ↓\ v}.
\item
  If it is \texttt{S\ x}, then \texttt{(subst-zero\ M)\ (S\ x)\ =\ x}
  and \texttt{(γ\ ,\ v)\ (S\ x)\ =\ γ\ x}. So we conclude that
  \texttt{γ\ ⊢\ x\ ↓\ γ\ x} by rule \texttt{var}.
\end{itemize}

\hypertarget{reduction-preserves-denotations}{%
\subsection{Reduction preserves
denotations}\label{reduction-preserves-denotations}}

With the substitution lemma in hand, it is straightforward to prove that
reduction preserves denotations.

\begin{fence}
\begin{code}
preserve : ∀ {Γ} {γ : Env Γ} {M N v}
  → γ ⊢ M ↓ v
  → M —→ N
    ----------
  → γ ⊢ N ↓ v
preserve (var) ()
preserve (↦-elim d₁ d₂) (ξ₁ r) = ↦-elim (preserve d₁ r) d₂
preserve (↦-elim d₁ d₂) (ξ₂ r) = ↦-elim d₁ (preserve d₂ r)
preserve (↦-elim d₁ d₂) β = substitution (lambda-inversion d₁) d₂
preserve (↦-intro d) (ζ r) = ↦-intro (preserve d r)
preserve ⊥-intro r = ⊥-intro
preserve (⊔-intro d d₁) r = ⊔-intro (preserve d r) (preserve d₁ r)
preserve (sub d lt) r = sub (preserve d r) lt
\end{code}
\end{fence}

We proceed by induction on the semantics of \texttt{M} with case
analysis on the reduction.

\begin{itemize}
\item
  If \texttt{M} is a variable, then there is no such reduction.
\item
  If \texttt{M} is an application, then the reduction is either a
  congruence (ξ₁ or ξ₂) or β. For each congruence, we use the induction
  hypothesis. For β reduction we use the substitution lemma and the
  \texttt{sub} rule.
\item
  The rest of the cases are straightforward.
\end{itemize}

\hypertarget{reduction-reflects-denotations}{%
\section{Reduction reflects
denotations}\label{reduction-reflects-denotations}}

This section proves that reduction reflects the denotation of a term.
That is, if \texttt{N} results in \texttt{v}, and if \texttt{M} reduces
to \texttt{N}, then \texttt{M} also results in \texttt{v}. While there
are some broad similarities between this proof and the above proof of
semantic preservation, we shall require a few more technical lemmas to
obtain this result.

The main challenge is dealing with the substitution in β reduction:

\begin{myDisplay}
(ƛ N) · M —→ N [ M ]
\end{myDisplay}

We have that \texttt{γ\ ⊢\ N\ {[}\ M\ {]}\ ↓\ v} and need to show that
\texttt{γ\ ⊢\ (ƛ\ N)\ ·\ M\ ↓\ v}. Now consider the derivation of
\texttt{γ\ ⊢\ N\ {[}\ M\ {]}\ ↓\ v}. The term \texttt{M} may occur 0, 1,
or many times inside \texttt{N\ {[}\ M\ {]}}. At each of those
occurrences, \texttt{M} may result in a different value. But to build a
derivation for \texttt{(ƛ\ N)\ ·\ M}, we need a single value for
\texttt{M}. If \texttt{M} occurred more than 1 time, then we can join
all of the different values using \texttt{⊔}. If \texttt{M} occurred 0
times, then we do not need any information about \texttt{M} and can
therefore use \texttt{⊥} for the value of \texttt{M}.

\hypertarget{renaming-reflects-meaning}{%
\subsection{Renaming reflects meaning}\label{renaming-reflects-meaning}}

Previously we showed that renaming variables preserves meaning. Now we
prove the opposite, that it reflects meaning. That is, if
\texttt{δ\ ⊢\ rename\ ρ\ M\ ↓\ v}, then \texttt{γ\ ⊢\ M\ ↓\ v}, where
\texttt{(δ\ ∘\ ρ)}⊑ γ`.

First, we need a variant of a lemma given earlier.

\begin{fence}
\begin{code}
ext-⊑′ : ∀ {Γ Δ v} {γ : Env Γ} {δ : Env Δ}
  → (ρ : Rename Γ Δ)
  → (δ ∘ ρ) `⊑ γ
    ------------------------------
  → ((δ `, v) ∘ ext ρ) `⊑ (γ `, v)
ext-⊑′ ρ lt Z = ⊑-refl
ext-⊑′ ρ lt (S x) = lt x
\end{code}
\end{fence}

The proof is then as follows.

\begin{fence}
\begin{code}
rename-reflect : ∀ {Γ Δ v} {γ : Env Γ} {δ : Env Δ} { M : Γ ⊢ ★}
  → {ρ : Rename Γ Δ}
  → (δ ∘ ρ) `⊑ γ
  → δ ⊢ rename ρ M ↓ v
    ------------------------------------
  → γ ⊢ M ↓ v
rename-reflect {M = ` x} all-n d with var-inv d
... | lt =  sub var (⊑-trans lt (all-n x))
rename-reflect {M = ƛ N}{ρ = ρ} all-n (↦-intro d) =
   ↦-intro (rename-reflect (ext-⊑′ ρ all-n) d)
rename-reflect {M = ƛ N} all-n ⊥-intro = ⊥-intro
rename-reflect {M = ƛ N} all-n (⊔-intro d₁ d₂) =
   ⊔-intro (rename-reflect all-n d₁) (rename-reflect all-n d₂)
rename-reflect {M = ƛ N} all-n (sub d₁ lt) =
   sub (rename-reflect all-n d₁) lt
rename-reflect {M = L · M} all-n (↦-elim d₁ d₂) =
   ↦-elim (rename-reflect all-n d₁) (rename-reflect all-n d₂)
rename-reflect {M = L · M} all-n ⊥-intro = ⊥-intro
rename-reflect {M = L · M} all-n (⊔-intro d₁ d₂) =
   ⊔-intro (rename-reflect all-n d₁) (rename-reflect all-n d₂)
rename-reflect {M = L · M} all-n (sub d₁ lt) =
   sub (rename-reflect all-n d₁) lt
\end{code}
\end{fence}

We cannot prove this lemma by induction on the derivation of
\texttt{δ\ ⊢\ rename\ ρ\ M\ ↓\ v}, so instead we proceed by induction on
\texttt{M}.

\begin{itemize}
\item
  If it is a variable, we apply the inversion lemma to obtain that
  \texttt{v\ ⊑\ δ\ (ρ\ x)}. Instantiating the premise to \texttt{x} we
  have \texttt{δ\ (ρ\ x)\ =\ γ\ x}, so we conclude by the \texttt{var}
  rule.
\item
  If it is a lambda abstraction \texttt{ƛ\ N}, we have rename
  \texttt{ρ\ (ƛ\ N)\ =\ ƛ\ (rename\ (ext\ ρ)\ N)}. We proceed by cases
  on \texttt{δ\ ⊢\ ƛ\ (rename\ (ext\ ρ)\ N)\ ↓\ v}.

  \begin{itemize}
  \item
    Rule \texttt{↦-intro}: To satisfy the premise of the induction
    hypothesis, we prove that the renaming can be extended to be a
    mapping from \texttt{γ\ ,\ v₁\ to\ δ\ ,\ v₁}.
  \item
    Rule \texttt{⊥-intro}: We simply apply \texttt{⊥-intro}.
  \item
    Rule \texttt{⊔-intro}: We apply the induction hypotheses and
    \texttt{⊔-intro}.
  \item
    Rule \texttt{sub}: We apply the induction hypothesis and
    \texttt{sub}.
  \end{itemize}
\item
  If it is an application \texttt{L\ ·\ M}, we have
  \texttt{rename\ ρ\ (L\ ·\ M)\ =\ (rename\ ρ\ L)\ ·\ (rename\ ρ\ M)}.
  We proceed by cases on
  \texttt{δ\ ⊢\ (rename\ ρ\ L)\ ·\ (rename\ ρ\ M)\ ↓\ v} and all the
  cases are straightforward.
\end{itemize}

In the upcoming uses of \texttt{rename-reflect}, the renaming will
always be the increment function. So we prove a corollary for that
special case.

\begin{fence}
\begin{code}
rename-inc-reflect : ∀ {Γ v′ v} {γ : Env Γ} { M : Γ ⊢ ★}
  → (γ `, v′) ⊢ rename S_ M ↓ v
    ----------------------------
  → γ ⊢ M ↓ v
rename-inc-reflect d = rename-reflect `⊑-refl d
\end{code}
\end{fence}

\hypertarget{substitution-reflects-denotations-the-variable-case}{%
\subsection{Substitution reflects denotations, the variable
case}\label{substitution-reflects-denotations-the-variable-case}}

We are almost ready to begin proving that simultaneous substitution
reflects denotations. That is, if \texttt{γ\ ⊢\ (subst\ σ\ M)\ ↓\ v},
then \texttt{γ\ ⊢\ σ\ k\ ↓\ δ\ k} and \texttt{δ\ ⊢\ M\ ↓\ v} for any
\texttt{k} and some \texttt{δ}. We shall start with the case in which
\texttt{M} is a variable \texttt{x}. So instead the premise is
\texttt{γ\ ⊢\ σ\ x\ ↓\ v} and we need to show that
\texttt{δ\ ⊢\ x\ ↓\ v} for some \texttt{δ}. The \texttt{δ} that we
choose shall be the environment that maps \texttt{x} to \texttt{v} and
every other variable to \texttt{⊥}.

Next we define the environment that maps \texttt{x} to \texttt{v} and
every other variable to \texttt{⊥}, that is \texttt{const-env\ x\ v}. To
tell variables apart, we define the following function for deciding
equality of variables.

\begin{fence}
\begin{code}
_var≟_ : ∀ {Γ} → (x y : Γ ∋ ★) → Dec (x ≡ y)
Z var≟ Z  =  yes refl
Z var≟ (S _)  =  no λ()
(S _) var≟ Z  =  no λ()
(S x) var≟ (S y) with  x var≟ y
...                 |  yes refl =  yes refl
...                 |  no neq   =  no λ{refl → neq refl}

var≟-refl : ∀ {Γ} (x : Γ ∋ ★) → (x var≟ x) ≡ yes refl
var≟-refl Z = refl
var≟-refl (S x) rewrite var≟-refl x = refl
\end{code}
\end{fence}

Now we use \texttt{var≟} to define \texttt{const-env}.

\begin{fence}
\begin{code}
const-env : ∀{Γ} → (x : Γ ∋ ★) → Value → Env Γ
const-env x v y with x var≟ y
...             | yes _       = v
...             | no _        = ⊥
\end{code}
\end{fence}

Of course, \texttt{const-env\ x\ v} maps \texttt{x} to value \texttt{v}

\begin{fence}
\begin{code}
same-const-env : ∀{Γ} {x : Γ ∋ ★} {v} → (const-env x v) x ≡ v
same-const-env {x = x} rewrite var≟-refl x = refl
\end{code}
\end{fence}

and \texttt{const-env\ x\ v} maps \texttt{y} to
\texttt{⊥,\ so\ long\ as}x ≢ y`.

\begin{fence}
\begin{code}
diff-const-env : ∀{Γ} {x y : Γ ∋ ★} {v}
  → x ≢ y
    -------------------
  → const-env x v y ≡ ⊥
diff-const-env {Γ} {x} {y} neq with x var≟ y
...  | yes eq  =  ⊥-elim (neq eq)
...  | no _    =  refl
\end{code}
\end{fence}

So we choose \texttt{const-env\ x\ v} for \texttt{δ} and obtain
\texttt{δ\ ⊢\ x\ ↓\ v} with the \texttt{var} rule.

It remains to prove that \texttt{γ\ ⊢\ σ\ ↓\ δ} and
\texttt{δ\ ⊢\ M\ ↓\ v} for any \texttt{k}, given that we have chosen
\texttt{const-env\ x\ v} for \texttt{δ}. We shall have two cases to
consider, \texttt{x\ ≡\ y} or \texttt{x\ ≢\ y}.

Now to finish the two cases of the proof.

\begin{itemize}
\tightlist
\item
  In the case where \texttt{x\ ≡\ y}, we need to show that
  \texttt{γ\ ⊢\ σ\ y\ ↓\ v}, but that's just our premise.
\item
  In the case where \texttt{x\ ≢\ y,} we need to show that
  \texttt{γ\ ⊢\ σ\ y\ ↓\ ⊥}, which we do via rule \texttt{⊥-intro}.
\end{itemize}

Thus, we have completed the variable case of the proof that simultaneous
substitution reflects denotations. Here is the proof again, formally.

\begin{fence}
\begin{code}
subst-reflect-var : ∀ {Γ Δ} {γ : Env Δ} {x : Γ ∋ ★} {v} {σ : Subst Γ Δ}
  → γ ⊢ σ x ↓ v
    -----------------------------------------
  → Σ[ δ ∈ Env Γ ] γ `⊢ σ ↓ δ  ×  δ ⊢ ` x ↓ v
subst-reflect-var {Γ}{Δ}{γ}{x}{v}{σ} xv
  rewrite sym (same-const-env {Γ}{x}{v}) =
    ⟨ const-env x v , ⟨ const-env-ok , var ⟩ ⟩
  where
  const-env-ok : γ `⊢ σ ↓ const-env x v
  const-env-ok y with x var≟ y
  ... | yes x≡y rewrite sym x≡y | same-const-env {Γ}{x}{v} = xv
  ... | no x≢y rewrite diff-const-env {Γ}{x}{y}{v} x≢y = ⊥-intro
\end{code}
\end{fence}

\hypertarget{substitutions-and-environment-construction}{%
\subsection{Substitutions and environment
construction}\label{substitutions-and-environment-construction}}

Every substitution produces terms that can evaluate to \texttt{⊥}.

\begin{fence}
\begin{code}
subst-⊥ : ∀{Γ Δ}{γ : Env Δ}{σ : Subst Γ Δ}
    -----------------
  → γ `⊢ σ ↓ `⊥
subst-⊥ x = ⊥-intro
\end{code}
\end{fence}

If a substitution produces terms that evaluate to the values in both
\texttt{γ₁} and \texttt{γ₂}, then those terms also evaluate to the
values in \texttt{γ₁\ ⊔\ γ₂}.

\begin{fence}
\begin{code}
subst-⊔ : ∀{Γ Δ}{γ : Env Δ}{γ₁ γ₂ : Env Γ}{σ : Subst Γ Δ}
           → γ `⊢ σ ↓ γ₁
           → γ `⊢ σ ↓ γ₂
             -------------------------
           → γ `⊢ σ ↓ (γ₁ `⊔ γ₂)
subst-⊔ γ₁-ok γ₂-ok x = ⊔-intro (γ₁-ok x) (γ₂-ok x)
\end{code}
\end{fence}

\hypertarget{the-lambda-constructor-is-injective}{%
\subsection{The Lambda constructor is
injective}\label{the-lambda-constructor-is-injective}}

\begin{fence}
\begin{code}
lambda-inj : ∀ {Γ} {M N : Γ , ★ ⊢ ★ }
  → _≡_ {A = Γ ⊢ ★} (ƛ M) (ƛ N)
    ---------------------------
  → M ≡ N
lambda-inj refl = refl
\end{code}
\end{fence}

\hypertarget{simultaneous-substitution-reflects-denotations}{%
\subsection{Simultaneous substitution reflects
denotations}\label{simultaneous-substitution-reflects-denotations}}

In this section we prove a central lemma, that substitution reflects
denotations. That is, if \texttt{γ\ ⊢\ subst\ σ\ M\ ↓\ v}, then
\texttt{δ\ ⊢\ M\ ↓\ v} and \texttt{γ\ ⊢\ σ\ ↓\ δ} for some \texttt{δ}.
We shall proceed by induction on the derivation of
\texttt{γ\ ⊢\ subst\ σ\ M\ ↓\ v}. This requires a minor restatement of
the lemma, changing the premise to \texttt{γ\ ⊢\ L\ ↓\ v} and
\texttt{L\ ≡\ subst\ σ\ M}.

\begin{fence}
\begin{code}
split : ∀ {Γ} {M : Γ , ★ ⊢ ★} {δ : Env (Γ , ★)} {v}
  → δ ⊢ M ↓ v
    --------------------------
  → (init δ `, last δ) ⊢ M ↓ v
split {δ = δ} δMv rewrite init-last δ = δMv

subst-reflect : ∀ {Γ Δ} {δ : Env Δ} {M : Γ ⊢ ★} {v} {L : Δ ⊢ ★} {σ : Subst Γ Δ}
  → δ ⊢ L ↓ v
  → subst σ M ≡ L
    ---------------------------------------
  → Σ[ γ ∈ Env Γ ] δ `⊢ σ ↓ γ  ×  γ ⊢ M ↓ v

subst-reflect {M = M}{σ = σ} (var {x = y}) eqL with M
... | ` x  with var {x = y}
...           | yv  rewrite sym eqL = subst-reflect-var {σ = σ} yv
subst-reflect {M = M} (var {x = y}) () | M₁ · M₂
subst-reflect {M = M} (var {x = y}) () | ƛ M′

subst-reflect {M = M}{σ = σ} (↦-elim d₁ d₂) eqL
         with M
...    | ` x with ↦-elim d₁ d₂
...    | d′ rewrite sym eqL = subst-reflect-var {σ = σ} d′
subst-reflect (↦-elim d₁ d₂) () | ƛ M′
subst-reflect{Γ}{Δ}{γ}{σ = σ} (↦-elim d₁ d₂)
   refl | M₁ · M₂
     with subst-reflect {M = M₁} d₁ refl | subst-reflect {M = M₂} d₂ refl
...     | ⟨ δ₁ , ⟨ subst-δ₁ , m1 ⟩ ⟩ | ⟨ δ₂ , ⟨ subst-δ₂ , m2 ⟩ ⟩ =
     ⟨ δ₁ `⊔ δ₂ , ⟨ subst-⊔ {γ₁ = δ₁}{γ₂ = δ₂}{σ = σ} subst-δ₁ subst-δ₂ ,
                    ↦-elim (⊑-env m1 (⊑-env-conj-R1 δ₁ δ₂))
                           (⊑-env m2 (⊑-env-conj-R2 δ₁ δ₂)) ⟩ ⟩

subst-reflect {M = M}{σ = σ} (↦-intro d) eqL with M
...    | ` x with (↦-intro d)
...             | d′ rewrite sym eqL = subst-reflect-var {σ = σ} d′
subst-reflect {σ = σ} (↦-intro d) eq | ƛ M′
      with subst-reflect {σ = exts σ} d (lambda-inj eq)
... | ⟨ δ′ , ⟨ exts-σ-δ′ , m′ ⟩ ⟩ =
    ⟨ init δ′ , ⟨ ((λ x → rename-inc-reflect (exts-σ-δ′ (S x)))) ,
             ↦-intro (up-env (split m′) (var-inv (exts-σ-δ′ Z))) ⟩ ⟩
subst-reflect (↦-intro d) () | M₁ · M₂

subst-reflect {σ = σ} ⊥-intro eq =
    ⟨ `⊥ , ⟨ subst-⊥ {σ = σ} , ⊥-intro ⟩ ⟩

subst-reflect {σ = σ} (⊔-intro d₁ d₂) eq
  with subst-reflect {σ = σ} d₁ eq | subst-reflect {σ = σ} d₂ eq
... | ⟨ δ₁ , ⟨ subst-δ₁ , m1 ⟩ ⟩ | ⟨ δ₂ , ⟨ subst-δ₂ , m2 ⟩ ⟩ =
     ⟨ δ₁ `⊔ δ₂ , ⟨ subst-⊔ {γ₁ = δ₁}{γ₂ = δ₂}{σ = σ} subst-δ₁ subst-δ₂ ,
                    ⊔-intro (⊑-env m1 (⊑-env-conj-R1 δ₁ δ₂))
                            (⊑-env m2 (⊑-env-conj-R2 δ₁ δ₂)) ⟩ ⟩
subst-reflect (sub d lt) eq
    with subst-reflect d eq
... | ⟨ δ , ⟨ subst-δ , m ⟩ ⟩ = ⟨ δ , ⟨ subst-δ , sub m lt ⟩ ⟩
\end{code}
\end{fence}

\begin{itemize}
\item
  Case \texttt{var}: We have subst \texttt{σ\ M\ ≡\ y}, so \texttt{M}
  must also be a variable, say \texttt{x}. We apply the lemma
  \texttt{subst-reflect-var} to conclude.
\item
  Case \texttt{↦-elim}: We have \texttt{subst\ σ\ M\ ≡\ L₁\ ·\ L₂}. We
  proceed by cases on \texttt{M}.

  \begin{itemize}
  \item
    Case \texttt{M\ ≡\ x}: We apply the \texttt{subst-reflect-var} lemma
    again to conclude.
  \item
    Case \texttt{M\ ≡\ M₁\ ·\ M₂}: By the induction hypothesis, we have
    some \texttt{δ₁} and \texttt{δ₂} such that
    \texttt{δ₁\ ⊢\ M₁\ ↓\ v₁\ ↦\ v₃} and \texttt{γ\ ⊢\ σ\ ↓\ δ₁}, as
    well as \texttt{δ₂\ ⊢\ M₂\ ↓\ v₁} and \texttt{γ\ ⊢\ σ\ ↓\ δ₂}. By
    \texttt{⊑-env} we have \texttt{δ₁\ ⊔\ δ₂\ ⊢\ M₁\ ↓\ v₁\ ↦\ v₃} and
    \texttt{δ₁\ ⊔\ δ₂\ ⊢\ M₂\ ↓\ v₁} (using \texttt{⊑-env-conj-R1} and
    \texttt{⊑-env-conj-R2}), and therefore
    \texttt{δ₁\ ⊔\ δ₂\ ⊢\ M₁\ ·\ M₂\ ↓\ v₃}. We conclude this case by
    obtaining \texttt{γ\ ⊢\ σ\ ↓\ δ₁\ ⊔\ δ₂} by the \texttt{subst-⊔}
    lemma.
  \end{itemize}
\item
  Case \texttt{↦-intro}: We have \texttt{subst\ σ\ M\ ≡\ ƛ\ L′}. We
  proceed by cases on \texttt{M}.

  \begin{itemize}
  \item
    Case \texttt{M\ ≡\ x}: We apply the \texttt{subst-reflect-var}
    lemma.
  \item
    Case \texttt{M\ ≡\ ƛ\ M′}: By the induction hypothesis, we have
    \texttt{(δ′\ ,\ v′)\ ⊢\ M′\ ↓\ v₂} and
    \texttt{(δ\ ,\ v₁)\ ⊢\ exts\ σ\ ↓\ (δ′\ ,\ v′)}. From the later we
    have \texttt{(δ\ ,\ v₁)\ ⊢\ \#\ 0\ ↓\ v′}. By the lemma
    \texttt{var-inv} we have \texttt{v′\ ⊑\ v₁}, so by the
    \texttt{up-env} lemma we have \texttt{(δ′\ ,\ v₁)\ ⊢\ M′\ ↓\ v₂} and
    therefore \texttt{δ′\ ⊢\ ƛ\ M′\ ↓\ v₁\ →\ v₂}. We also need to show
    that \texttt{δ}⊢ σ ↓ δ′\texttt{.\ \ Fix}k\texttt{.\ We\ have}(δ ,
    v₁) ⊢ rename S\_ σ k ↓ δ
    k′\texttt{.\ \ We\ then\ apply\ the\ lemma}rename-inc-reflect\texttt{to\ obtain}δ
    ⊢ σ k ↓ δ k′`, so this case is complete.
  \end{itemize}
\item
  Case \texttt{⊥-intro}: We choose \texttt{⊥} for \texttt{δ}. We have
  \texttt{⊥\ ⊢\ M\ ↓\ ⊥} by \texttt{⊥-intro}. We have
  \texttt{δ\ ⊢\ σ\ ↓\ ⊥} by the lemma \texttt{subst-empty}.
\item
  Case \texttt{⊔-intro}: By the induction hypothesis we have
  \texttt{δ₁\ ⊢\ M\ ↓\ v₁}, \texttt{δ₂\ ⊢\ M\ ↓\ v₂},
  \texttt{δ\ ⊢\ σ\ ↓\ δ₁}, and \texttt{δ\ ⊢\ σ\ ↓\ δ₂}. We have
  \texttt{δ₁\ ⊔\ δ₂\ ⊢\ M\ ↓\ v₁} and \texttt{δ₁\ ⊔\ δ₂\ ⊢\ M\ ↓\ v₂} by
  \texttt{⊑-env} with \texttt{⊑-env-conj-R1} and \texttt{⊑-env-conj-R2}.
  So by \texttt{⊔-intro} we have \texttt{δ₁\ ⊔\ δ₂\ ⊢\ M\ ↓\ v₁\ ⊔\ v₂}.
  By \texttt{subst-⊔} we conclude that \texttt{δ\ ⊢\ σ\ ↓\ δ₁\ ⊔\ δ₂}.
\end{itemize}

\hypertarget{single-substitution-reflects-denotations}{%
\subsection{Single substitution reflects
denotations}\label{single-substitution-reflects-denotations}}

Most of the work is now behind us. We have proved that simultaneous
substitution reflects denotations. Of course, β reduction uses single
substitution, so we need a corollary that proves that single
substitution reflects denotations. That is, given terms
\texttt{N\ :\ (Γ\ ,\ ★\ ⊢\ ★)} and \texttt{M\ :\ (Γ\ ⊢\ ★)}, if
\texttt{γ\ ⊢\ N\ {[}\ M\ {]}\ ↓\ w}, then \texttt{γ\ ⊢\ M\ ↓\ v} and
\texttt{(γ\ ,\ v)\ ⊢\ N\ ↓\ w} for some value \texttt{v}. We have
\texttt{N\ {[}\ M\ {]}\ =\ subst\ (subst-zero\ M)\ N}.

We first prove a lemma about \texttt{subst-zero}, that if
\texttt{δ\ ⊢\ subst-zero\ M\ ↓\ γ}, then
\texttt{γ\ ⊑\ (δ\ ,\ w)\ ×\ δ\ ⊢\ M\ ↓\ w} for some \texttt{w}.

\begin{fence}
\begin{code}
subst-zero-reflect : ∀ {Δ} {δ : Env Δ} {γ : Env (Δ , ★)} {M : Δ ⊢ ★}
  → δ `⊢ subst-zero M ↓ γ
    ----------------------------------------
  → Σ[ w ∈ Value ] γ `⊑ (δ `, w) × δ ⊢ M ↓ w
subst-zero-reflect {δ = δ} {γ = γ} δσγ = ⟨ last γ , ⟨ lemma , δσγ Z ⟩ ⟩
  where
  lemma : γ `⊑ (δ `, last γ)
  lemma Z  =  ⊑-refl
  lemma (S x) = var-inv (δσγ (S x))
\end{code}
\end{fence}

We choose \texttt{w} to be the last value in \texttt{γ} and we obtain
\texttt{δ\ ⊢\ M\ ↓\ w} by applying the premise to variable \texttt{Z}.
Finally, to prove \texttt{γ\ ⊑\ (δ\ ,\ w)}, we prove a lemma by
induction in the input variable. The base case is trivial because of our
choice of \texttt{w}. In the induction case, \texttt{S\ x}, the premise
\texttt{δ\ ⊢\ subst-zero\ M\ ↓\ γ} gives us
\texttt{δ\ ⊢\ x\ ↓\ γ\ (S\ x)} and then using \texttt{var-inv} we
conclude that \texttt{γ\ (S\ x)\ ⊑\ (δ}, w) (S x)`.

Now to prove that substitution reflects denotations.

\begin{fence}
\begin{code}
substitution-reflect : ∀ {Δ} {δ : Env Δ} {N : Δ , ★ ⊢ ★} {M : Δ ⊢ ★} {v}
  → δ ⊢ N [ M ] ↓ v
    ------------------------------------------------
  → Σ[ w ∈ Value ] δ ⊢ M ↓ w  ×  (δ `, w) ⊢ N ↓ v
substitution-reflect d with subst-reflect d refl
...  | ⟨ γ , ⟨ δσγ , γNv ⟩ ⟩ with subst-zero-reflect δσγ
...    | ⟨ w , ⟨ ineq , δMw ⟩ ⟩ = ⟨ w , ⟨ δMw , ⊑-env γNv ineq ⟩ ⟩
\end{code}
\end{fence}

We apply the \texttt{subst-reflect} lemma to obtain
\texttt{δ\ ⊢\ subst-zero\ M\ ↓\ γ} and \texttt{γ\ ⊢\ N\ ↓\ v} for some
\texttt{γ}. Using the former, the \texttt{subst-zero-reflect} lemma
gives us \texttt{γ\ ⊑\ (δ\ ,\ w)} and \texttt{δ\ ⊢\ M\ ↓\ w}. We
conclude that \texttt{δ\ ,\ w\ ⊢\ N\ ↓\ v} by applying the
\texttt{⊑-env} lemma, using \texttt{γ\ ⊢\ N\ ↓\ v} and
\texttt{γ\ ⊑\ (δ\ ,\ w)}.

\hypertarget{reduction-reflects-denotations-1}{%
\subsection{Reduction reflects
denotations}\label{reduction-reflects-denotations-1}}

Now that we have proved that substitution reflects denotations, we can
easily prove that reduction does too.

\begin{fence}
\begin{code}
reflect-beta : ∀{Γ}{γ : Env Γ}{M N}{v}
    → γ ⊢ (N [ M ]) ↓ v
    → γ ⊢ (ƛ N) · M ↓ v
reflect-beta d
    with substitution-reflect d
... | ⟨ v₂′ , ⟨ d₁′ , d₂′ ⟩ ⟩ = ↦-elim (↦-intro d₂′) d₁′


reflect : ∀ {Γ} {γ : Env Γ} {M M′ N v}
  → γ ⊢ N ↓ v  →  M —→ M′  →   M′ ≡ N
    ---------------------------------
  → γ ⊢ M ↓ v
reflect var (ξ₁ r) ()
reflect var (ξ₂ r) ()
reflect{γ = γ} (var{x = x}) β mn
    with var{γ = γ}{x = x}
... | d′ rewrite sym mn = reflect-beta d′
reflect var (ζ r) ()
reflect (↦-elim d₁ d₂) (ξ₁ r) refl = ↦-elim (reflect d₁ r refl) d₂
reflect (↦-elim d₁ d₂) (ξ₂ r) refl = ↦-elim d₁ (reflect d₂ r refl)
reflect (↦-elim d₁ d₂) β mn
    with ↦-elim d₁ d₂
... | d′ rewrite sym mn = reflect-beta d′
reflect (↦-elim d₁ d₂) (ζ r) ()
reflect (↦-intro d) (ξ₁ r) ()
reflect (↦-intro d) (ξ₂ r) ()
reflect (↦-intro d) β mn
    with ↦-intro d
... | d′ rewrite sym mn = reflect-beta d′
reflect (↦-intro d) (ζ r) refl = ↦-intro (reflect d r refl)
reflect ⊥-intro r mn = ⊥-intro
reflect (⊔-intro d₁ d₂) r mn rewrite sym mn =
   ⊔-intro (reflect d₁ r refl) (reflect d₂ r refl)
reflect (sub d lt) r mn = sub (reflect d r mn) lt
\end{code}
\end{fence}

\hypertarget{reduction-implies-denotational-equality}{%
\section{Reduction implies denotational
equality}\label{reduction-implies-denotational-equality}}

We have proved that reduction both preserves and reflects denotations.
Thus, reduction implies denotational equality.

\begin{fence}
\begin{code}
reduce-equal : ∀ {Γ} {M : Γ ⊢ ★} {N : Γ ⊢ ★}
  → M —→ N
    ---------
  → ℰ M ≃ ℰ N
reduce-equal {Γ}{M}{N} r γ v =
    ⟨ (λ m → preserve m r) , (λ n → reflect n r refl) ⟩
\end{code}
\end{fence}

We conclude with the \emph{soundness property}, that multi-step
reduction to a lambda abstraction implies denotational equivalence with
a lambda abstraction.

\begin{fence}
\begin{code}
soundness : ∀{Γ} {M : Γ ⊢ ★} {N : Γ , ★ ⊢ ★}
  → M —↠ ƛ N
    -----------------
  → ℰ M ≃ ℰ (ƛ N)
soundness (.(ƛ _) ∎) γ v = ⟨ (λ x → x) , (λ x → x) ⟩
soundness {Γ} (L —→⟨ r ⟩ M—↠N) γ v =
   let ih = soundness M—↠N in
   let e = reduce-equal r in
   ≃-trans {Γ} e ih γ v
\end{code}
\end{fence}

\hypertarget{unicode}{%
\section{Unicode}\label{unicode}}

This chapter uses the following unicode:

\begin{myDisplay}
≟  U+225F  QUESTIONED EQUAL TO (\?=)
\end{myDisplay}

