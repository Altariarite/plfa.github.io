\hypertarget{Adequacy}{%
\chapter{Adequacy: Adequacy of denotational semantics with respect to
operational semantics}\label{Adequacy}}

\begin{fence}
\begin{code}
module plfa.part3.Adequacy where
\end{code}
\end{fence}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

Having proved a preservation property in the last chapter, a natural
next step would be to prove progress. That is, to prove a property of
the form

\begin{myDisplay}
If γ ⊢ M ↓ v, then either M is a lambda abstraction or M —→ N for some N.
\end{myDisplay}

Such a property would tell us that having a denotation implies either
reduction to normal form or divergence. This is indeed true, but we can
prove a much stronger property! In fact, having a denotation that is a
function value (not \texttt{⊥}) implies reduction to a lambda
abstraction.

This stronger property, reformulated a bit, is known as \emph{adequacy}.
That is, if a term \texttt{M} is denotationally equal to a lambda
abstraction, then \texttt{M} reduces to a lambda abstraction.

\begin{myDisplay}
ℰ M ≃ ℰ (ƛ N)  implies M —↠ ƛ N' for some N'
\end{myDisplay}

Recall that \texttt{ℰ\ M\ ≃\ ℰ\ (ƛ\ N)} is equivalent to saying that
\texttt{γ\ ⊢\ M\ ↓\ (v\ ↦\ w)} for some \texttt{v} and \texttt{w}. We
will show that \texttt{γ\ ⊢\ M\ ↓\ (v\ ↦\ w)} implies multi-step
reduction a lambda abstraction. The recursive structure of the
derivations for \texttt{γ\ ⊢\ M\ ↓\ (v\ ↦\ w)} are completely different
from the structure of multi-step reductions, so a direct proof would be
challenging. However, The structure of \texttt{γ\ ⊢\ M\ ↓\ (v\ ↦\ w)}
closer to that of \protect\hyperlink{BigStep}{BigStep} call-by-name
evaluation. Further, we already proved that big-step evaluation implies
multi-step reduction to a lambda (\texttt{cbn→reduce}). So we shall
prove that \texttt{γ\ ⊢\ M\ ↓\ (v\ ↦\ w)} implies that
\texttt{γ\textquotesingle{}\ ⊢\ M\ ⇓\ c}, where \texttt{c} is a closure
(a term paired with an environment), \texttt{γ\textquotesingle{}} is an
environment that maps variables to closures, and \texttt{γ} and
\texttt{γ\textquotesingle{}} are appropriate related. The proof will be
an induction on the derivation of \texttt{γ\ ⊢\ M\ ↓\ v}, and to
strengthen the induction hypothesis, we will relate semantic values to
closures using a \emph{logical relation} \texttt{𝕍}.

The rest of this chapter is organized as follows.

\begin{itemize}
\item
  To make the \texttt{𝕍} relation down-closed with respect to
  \texttt{⊑}, we must loosen the requirement that \texttt{M} result in a
  function value and instead require that \texttt{M} result in a value
  that is greater than or equal to a function value. We establish
  several properties about being ``greater than a function'\,'.
\item
  We define the logical relation \texttt{𝕍} that relates values and
  closures, and extend it to a relation on terms \texttt{𝔼} and
  environments \texttt{𝔾}. We prove several lemmas that culminate in the
  property that if \texttt{𝕍\ v\ c} and \texttt{v′\ ⊑\ v}, then
  \texttt{𝕍\ v′\ c}.
\item
  We prove the main lemma, that if \texttt{𝔾\ γ\ γ\textquotesingle{}}
  and \texttt{γ\ ⊢\ M\ ↓\ v}, then
  \texttt{𝔼\ v\ (clos\ M\ γ\textquotesingle{})}.
\item
  We prove adequacy as a corollary to the main lemma.
\end{itemize}

\hypertarget{imports}{%
\section{Imports}\label{imports}}

\begin{fence}
\begin{code}
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; _≢_; refl; trans; sym; cong; cong₂; cong-app)
open import Data.Product using (_×_; Σ; Σ-syntax; ∃; ∃-syntax; proj₁; proj₂)
  renaming (_,_ to ⟨_,_⟩)
open import Data.Sum
open import Relation.Nullary using (¬_)
open import Relation.Nullary.Negation using (contradiction)
open import Data.Empty using (⊥-elim) renaming (⊥ to Bot)
open import Data.Unit
open import Relation.Nullary using (Dec; yes; no)
open import Function using (_∘_)
open import plfa.part2.Untyped
     using (Context; _⊢_; ★; _∋_; ∅; _,_; Z; S_; `_; ƛ_; _·_;
            rename; subst; ext; exts; _[_]; subst-zero;
            _—↠_; _—→⟨_⟩_; _∎; _—→_; ξ₁; ξ₂; β; ζ)
open import plfa.part2.Substitution using (ids; sub-id)
open import plfa.part2.BigStep
     using (Clos; clos; ClosEnv; ∅'; _,'_; _⊢_⇓_; ⇓-var; ⇓-lam; ⇓-app; ⇓-determ;
            cbn→reduce)
open import plfa.part3.Denotational
     using (Value; Env; `∅; _`,_; _↦_; _⊑_; _⊢_↓_; ⊥; all-funs∈; _⊔_; ∈→⊑;
            var; ↦-elim; ↦-intro; ⊔-intro; ⊥-intro; sub; ℰ; _≃_; _iff_;
            ⊑-trans; ⊑-conj-R1; ⊑-conj-R2; ⊑-conj-L; ⊑-refl; ⊑-fun; ⊑-bot; ⊑-dist;
            sub-inv-fun)
open import plfa.part3.Soundness using (soundness)

\end{code}
\end{fence}

\hypertarget{the-property-of-being-greater-or-equal-to-a-function}{%
\section{The property of being greater or equal to a
function}\label{the-property-of-being-greater-or-equal-to-a-function}}

We define the following short-hand for saying that a value is
greater-than or equal to a function value.

\begin{fence}
\begin{code}
above-fun : Value → Set
above-fun u = Σ[ v ∈ Value ] Σ[ w ∈ Value ] v ↦ w ⊑ u
\end{code}
\end{fence}

If a value \texttt{u} is greater than a function, then an even greater
value \texttt{u\textquotesingle{}} is too.

\begin{fence}
\begin{code}
above-fun-⊑ : ∀{u u' : Value}
      → above-fun u → u ⊑ u'
        -------------------
      → above-fun u'
above-fun-⊑ ⟨ v , ⟨ w , lt' ⟩ ⟩ lt = ⟨ v , ⟨ w , ⊑-trans lt' lt ⟩ ⟩
\end{code}
\end{fence}

The bottom value \texttt{⊥} is not greater than a function.

\begin{fence}
\begin{code}
above-fun⊥ : ¬ above-fun ⊥
above-fun⊥ ⟨ v , ⟨ w , lt ⟩ ⟩
    with sub-inv-fun lt
... | ⟨ Γ , ⟨ f , ⟨ Γ⊆⊥ , ⟨ lt1 , lt2 ⟩ ⟩ ⟩ ⟩
    with all-funs∈ f
... | ⟨ A , ⟨ B , m ⟩ ⟩
    with Γ⊆⊥ m
... | ()
\end{code}
\end{fence}

If the join of two values \texttt{u} and \texttt{u\textquotesingle{}} is
greater than a function, then at least one of them is too.

\begin{fence}
\begin{code}
above-fun-⊔ : ∀{u u'}
           → above-fun (u ⊔ u')
           → above-fun u ⊎ above-fun u'
above-fun-⊔{u}{u'} ⟨ v , ⟨ w , v↦w⊑u⊔u' ⟩ ⟩
    with sub-inv-fun v↦w⊑u⊔u'
... | ⟨ Γ , ⟨ f , ⟨ Γ⊆u⊔u' , ⟨ lt1 , lt2 ⟩ ⟩ ⟩ ⟩
    with all-funs∈ f
... | ⟨ A , ⟨ B , m ⟩ ⟩
    with Γ⊆u⊔u' m
... | inj₁ x = inj₁ ⟨ A , ⟨ B , (∈→⊑ x) ⟩ ⟩
... | inj₂ x = inj₂ ⟨ A , ⟨ B , (∈→⊑ x) ⟩ ⟩
\end{code}
\end{fence}

On the other hand, if neither of \texttt{u} and
\texttt{u\textquotesingle{}} is greater than a function, then their join
is also not greater than a function.

\begin{fence}
\begin{code}
not-above-fun-⊔ : ∀{u u' : Value}
               → ¬ above-fun u → ¬ above-fun u'
               → ¬ above-fun (u ⊔ u')
not-above-fun-⊔ naf1 naf2 af12
    with above-fun-⊔ af12
... | inj₁ af1 = contradiction af1 naf1
... | inj₂ af2 = contradiction af2 naf2
\end{code}
\end{fence}

The converse is also true. If the join of two values is not above a
function, then neither of them is individually.

\begin{fence}
\begin{code}
not-above-fun-⊔-inv : ∀{u u' : Value} → ¬ above-fun (u ⊔ u')
              → ¬ above-fun u × ¬ above-fun u'
not-above-fun-⊔-inv af = ⟨ f af , g af ⟩
  where
    f : ∀{u u' : Value} → ¬ above-fun (u ⊔ u') → ¬ above-fun u
    f{u}{u'} af12 ⟨ v , ⟨ w , lt ⟩ ⟩ =
        contradiction ⟨ v , ⟨ w , ⊑-conj-R1 lt ⟩ ⟩ af12
    g : ∀{u u' : Value} → ¬ above-fun (u ⊔ u') → ¬ above-fun u'
    g{u}{u'} af12 ⟨ v , ⟨ w , lt ⟩ ⟩ =
        contradiction ⟨ v , ⟨ w , ⊑-conj-R2 lt ⟩ ⟩ af12
\end{code}
\end{fence}

The property of being greater than a function value is decidable, as
exhibited by the following function.

\begin{fence}
\begin{code}
above-fun? : (v : Value) → Dec (above-fun v)
above-fun? ⊥ = no above-fun⊥
above-fun? (v ↦ w) = yes ⟨ v , ⟨ w , ⊑-refl ⟩ ⟩
above-fun? (u ⊔ u')
    with above-fun? u | above-fun? u'
... | yes ⟨ v , ⟨ w , lt ⟩ ⟩ | _ = yes ⟨ v , ⟨ w , (⊑-conj-R1 lt) ⟩ ⟩
... | no _ | yes ⟨ v , ⟨ w , lt ⟩ ⟩ = yes ⟨ v , ⟨ w , (⊑-conj-R2 lt) ⟩ ⟩
... | no x | no y = no (not-above-fun-⊔ x y)
\end{code}
\end{fence}

\hypertarget{relating-values-to-closures}{%
\section{Relating values to
closures}\label{relating-values-to-closures}}

Next we relate semantic values to closures. The relation \texttt{𝕍} is
for closures whose term is a lambda abstraction, i.e., in weak-head
normal form (WHNF). The relation 𝔼 is for any closure. Roughly speaking,
\texttt{𝔼\ v\ c} will hold if, when \texttt{v} is greater than a
function value, \texttt{c} evaluates to a closure
\texttt{c\textquotesingle{}} in WHNF and
\texttt{𝕍\ v\ c\textquotesingle{}}. Regarding \texttt{𝕍\ v\ c}, it will
hold when \texttt{c} is in WHNF, and if \texttt{v} is a function, the
body of \texttt{c} evaluates according to \texttt{v}.

\begin{fence}
\begin{code}
𝕍 : Value → Clos → Set
𝔼 : Value → Clos → Set
\end{code}
\end{fence}

We define \texttt{𝕍} as a function from values and closures to
\texttt{Set} and not as a data type because it is mutually recursive
with \texttt{𝔼} in a negative position (to the left of an implication).
We first perform case analysis on the term in the closure. If the term
is a variable or application, then \texttt{𝕍} is false (\texttt{Bot}).
If the term is a lambda abstraction, we define \texttt{𝕍} by recursion
on the value, which we describe below.

\begin{fence}
\begin{code}
𝕍 v (clos (` x₁) γ) = Bot
𝕍 v (clos (M · M₁) γ) = Bot
𝕍 ⊥ (clos (ƛ M) γ) = ⊤
𝕍 (v ↦ w) (clos (ƛ N) γ) =
    (∀{c : Clos} → 𝔼 v c → above-fun w → Σ[ c' ∈ Clos ]
        (γ ,' c) ⊢ N ⇓ c'  ×  𝕍 w c')
𝕍 (u ⊔ v) (clos (ƛ N) γ) = 𝕍 u (clos (ƛ N) γ) × 𝕍 v (clos (ƛ N) γ)
\end{code}
\end{fence}

\begin{itemize}
\item
  If the value is \texttt{⊥}, then the result is true (\texttt{⊤}).
\item
  If the value is a join (u ⊔ v), then the result is the pair
  (conjunction) of 𝕍 is true for both u and v.
\item
  The important case is for a function value \texttt{v\ ↦\ w} and
  closure \texttt{clos\ (ƛ\ N)\ γ}. Given any closure \texttt{c} such
  that \texttt{𝔼\ v\ c}, if \texttt{w} is greater than a function, then
  \texttt{N} evaluates (with \texttt{γ} extended with \texttt{c}) to
  some closure \texttt{c\textquotesingle{}} and we have
  \texttt{𝕍\ w\ c\textquotesingle{}}.
\end{itemize}

The definition of \texttt{𝔼} is straightforward. If \texttt{v} is a
greater than a function, then \texttt{M} evaluates to a closure related
to \texttt{v}.

\begin{fence}
\begin{code}
𝔼 v (clos M γ') = above-fun v → Σ[ c ∈ Clos ] γ' ⊢ M ⇓ c × 𝕍 v c
\end{code}
\end{fence}

The proof of the main lemma is by induction on \texttt{γ\ ⊢\ M\ ↓\ v},
so it goes underneath lambda abstractions and must therefore reason
about open terms (terms with variables). So we must relate environments
of semantic values to environments of closures. In the following,
\texttt{𝔾} relates \texttt{γ} to \texttt{γ\textquotesingle{}} if the
corresponding values and closures are related by \texttt{𝔼}.

\begin{fence}
\begin{code}
𝔾 : ∀{Γ} → Env Γ → ClosEnv Γ → Set
𝔾 {Γ} γ γ' = ∀{x : Γ ∋ ★} → 𝔼 (γ x) (γ' x)

𝔾-∅ : 𝔾 `∅ ∅'
𝔾-∅ {()}

𝔾-ext : ∀{Γ}{γ : Env Γ}{γ' : ClosEnv Γ}{v c}
      → 𝔾 γ γ' → 𝔼 v c → 𝔾 (γ `, v) (γ' ,' c)
𝔾-ext {Γ} {γ} {γ'} g e {Z} = e
𝔾-ext {Γ} {γ} {γ'} g e {S x} = g
\end{code}
\end{fence}

We need a few properties of the \texttt{𝕍} and \texttt{𝔼} relations. The
first is that a closure in the \texttt{𝕍} relation must be in weak-head
normal form. We define WHNF has follows.

\begin{fence}
\begin{code}
data WHNF : ∀ {Γ A} → Γ ⊢ A → Set where
  ƛ_ : ∀ {Γ} {N : Γ , ★ ⊢ ★}
     → WHNF (ƛ N)
\end{code}
\end{fence}

The proof goes by cases on the term in the closure.

\begin{fence}
\begin{code}
𝕍→WHNF : ∀{Γ}{γ : ClosEnv Γ}{M : Γ ⊢ ★}{v}
       → 𝕍 v (clos M γ) → WHNF M
𝕍→WHNF {M = ` x} {v} ()
𝕍→WHNF {M = ƛ N} {v} vc = ƛ_
𝕍→WHNF {M = L · M} {v} ()
\end{code}
\end{fence}

Next we have an introduction rule for \texttt{𝕍} that mimics the
\texttt{⊔-intro} rule. If both \texttt{u} and \texttt{v} are related to
a closure \texttt{c}, then their join is too.

\begin{fence}
\begin{code}
𝕍⊔-intro : ∀{c u v}
         → 𝕍 u c → 𝕍 v c
           ---------------
         → 𝕍 (u ⊔ v) c
𝕍⊔-intro {clos (` x) γ} () vc
𝕍⊔-intro {clos (ƛ N) γ} uc vc = ⟨ uc , vc ⟩
𝕍⊔-intro {clos (L · M) γ} () vc
\end{code}
\end{fence}

In a moment we prove that \texttt{𝕍} is preserved when going from a
greater value to a lesser value: if \texttt{𝕍\ v\ c} and
\texttt{v\textquotesingle{}\ ⊑\ v}, then
\texttt{𝕍\ v\textquotesingle{}\ c}. This property, named \texttt{𝕍-sub},
is needed by the main lemma in the case for the \texttt{sub} rule.

To prove \texttt{𝕍-sub}, we in turn need the following property
concerning values that are not greater than a function, that is, values
that are equivalent to \texttt{⊥}. In such cases,
\texttt{𝕍\ v\ (clos\ (ƛ\ N)\ γ\textquotesingle{})} is trivially true.

\begin{fence}
\begin{code}
not-above-fun-𝕍 : ∀{v : Value}{Γ}{γ' : ClosEnv Γ}{N : Γ , ★ ⊢ ★ }
    → ¬ above-fun v
      -------------------
    → 𝕍 v (clos (ƛ N) γ')
not-above-fun-𝕍 {⊥} af = tt
not-above-fun-𝕍 {v ↦ v'} af = ⊥-elim (contradiction ⟨ v , ⟨ v' , ⊑-refl ⟩ ⟩ af)
not-above-fun-𝕍 {v₁ ⊔ v₂} af
    with not-above-fun-⊔-inv af
... | ⟨ af1 , af2 ⟩ = ⟨ not-above-fun-𝕍 af1 , not-above-fun-𝕍 af2 ⟩
\end{code}
\end{fence}

The proofs of \texttt{𝕍-sub} and \texttt{𝔼-sub} are intertwined.

\begin{fence}
\begin{code}
sub-𝕍 : ∀{c : Clos}{v v'} → 𝕍 v c → v' ⊑ v → 𝕍 v' c
sub-𝔼 : ∀{c : Clos}{v v'} → 𝔼 v c → v' ⊑ v → 𝔼 v' c
\end{code}
\end{fence}

We prove \texttt{𝕍-sub} by case analysis on the closure's term, to
dispatch the cases for variables and application. We then proceed by
induction on \texttt{v\textquotesingle{}\ ⊑\ v}. We describe each case
below.

\begin{fence}
\begin{code}
sub-𝕍 {clos (` x) γ} {v} () lt
sub-𝕍 {clos (L · M) γ} () lt
sub-𝕍 {clos (ƛ N) γ} vc ⊑-bot = tt
sub-𝕍 {clos (ƛ N) γ} vc (⊑-conj-L lt1 lt2) = ⟨ (sub-𝕍 vc lt1) , sub-𝕍 vc lt2 ⟩
sub-𝕍 {clos (ƛ N) γ} ⟨ vv1 , vv2 ⟩ (⊑-conj-R1 lt) = sub-𝕍 vv1 lt
sub-𝕍 {clos (ƛ N) γ} ⟨ vv1 , vv2 ⟩ (⊑-conj-R2 lt) = sub-𝕍 vv2 lt
sub-𝕍 {clos (ƛ N) γ} vc (⊑-trans{v = v₂} lt1 lt2) = sub-𝕍 (sub-𝕍 vc lt2) lt1
sub-𝕍 {clos (ƛ N) γ} vc (⊑-fun lt1 lt2) ev1 sf
    with vc (sub-𝔼 ev1 lt1) (above-fun-⊑ sf lt2)
... | ⟨ c , ⟨ Nc , v4 ⟩ ⟩ = ⟨ c , ⟨ Nc , sub-𝕍 v4 lt2 ⟩ ⟩
sub-𝕍 {clos (ƛ N) γ} {v ↦ w ⊔ v ↦ w'} ⟨ vcw , vcw' ⟩ ⊑-dist ev1c sf
    with above-fun? w | above-fun? w'
... | yes af2 | yes af3
    with vcw ev1c af2 | vcw' ev1c af3
... | ⟨ clos L δ , ⟨ L⇓c₂ , 𝕍w ⟩ ⟩
    | ⟨ c₃ , ⟨ L⇓c₃ , 𝕍w' ⟩ ⟩ rewrite ⇓-determ L⇓c₃ L⇓c₂ with 𝕍→WHNF 𝕍w
... | ƛ_ =
      ⟨ clos L δ , ⟨ L⇓c₂ , ⟨ 𝕍w , 𝕍w' ⟩ ⟩ ⟩
sub-𝕍 {c} {v ↦ w ⊔ v ↦ w'} ⟨ vcw , vcw' ⟩  ⊑-dist ev1c sf
    | yes af2 | no naf3
    with vcw ev1c af2
... | ⟨ clos {Γ'} L γ₁ , ⟨ L⇓c2 , 𝕍w ⟩ ⟩
    with 𝕍→WHNF 𝕍w
... | ƛ_ {N = N'} =
      let 𝕍w' = not-above-fun-𝕍{w'}{Γ'}{γ₁}{N'} naf3 in
      ⟨ clos (ƛ N') γ₁ , ⟨ L⇓c2 , 𝕍⊔-intro 𝕍w 𝕍w' ⟩ ⟩
sub-𝕍 {c} {v ↦ w ⊔ v ↦ w'} ⟨ vcw , vcw' ⟩ ⊑-dist ev1c sf
    | no naf2 | yes af3
    with vcw' ev1c af3
... | ⟨ clos {Γ'} L γ₁ , ⟨ L⇓c3 , 𝕍w'c ⟩ ⟩
    with 𝕍→WHNF 𝕍w'c
... | ƛ_ {N = N'} =
      let 𝕍wc = not-above-fun-𝕍{w}{Γ'}{γ₁}{N'} naf2 in
      ⟨ clos (ƛ N') γ₁ , ⟨ L⇓c3 , 𝕍⊔-intro 𝕍wc 𝕍w'c ⟩ ⟩
sub-𝕍 {c} {v ↦ w ⊔ v ↦ w'} ⟨ vcw , vcw' ⟩ ⊑-dist ev1c ⟨ v' , ⟨ w'' , lt ⟩ ⟩
    | no naf2 | no naf3
    with above-fun-⊔ ⟨ v' , ⟨ w'' , lt ⟩ ⟩
... | inj₁ af2 = ⊥-elim (contradiction af2 naf2)
... | inj₂ af3 = ⊥-elim (contradiction af3 naf3)
\end{code}
\end{fence}

\begin{itemize}
\item
  Case \texttt{⊑-bot}. We immediately have
  \texttt{𝕍\ ⊥\ (clos\ (ƛ\ N)\ γ)}.
\item
  Case \texttt{⊑-conj-L}.

  \begin{myDisplay}
    v₁' ⊑ v     v₂' ⊑ v
    -------------------
    (v₁' ⊔ v₂') ⊑ v
  \end{myDisplay}

  The induction hypotheses gives us
  \texttt{𝕍\ v₁\textquotesingle{}\ (clos\ (ƛ\ N)\ γ)} and
  \texttt{𝕍\ v₂\textquotesingle{}\ (clos\ (ƛ\ N)\ γ)}, which is all we
  need for this case.
\item
  Case \texttt{⊑-conj-R1}.

  \begin{myDisplay}
    v' ⊑ v₁
    -------------
    v' ⊑ (v₁ ⊔ v₂)
  \end{myDisplay}

  The induction hypothesis gives us
  \texttt{𝕍\ v\textquotesingle{}\ (clos\ (ƛ\ N)\ γ)}.
\item
  Case \texttt{⊑-conj-R2}.

  \begin{myDisplay}
    v' ⊑ v₂
    -------------
    v' ⊑ (v₁ ⊔ v₂)
  \end{myDisplay}

  Again, the induction hypothesis gives us
  \texttt{𝕍\ v\textquotesingle{}\ (clos\ (ƛ\ N)\ γ)}.
\item
  Case \texttt{⊑-trans}.

  \begin{myDisplay}
    v' ⊑ v₂   v₂ ⊑ v
    -----------------
         v' ⊑ v
  \end{myDisplay}

  The induction hypothesis for \texttt{v₂\ ⊑\ v} gives us
  \texttt{𝕍\ v₂\ (clos\ (ƛ\ N)\ γ)}. We apply the induction hypothesis
  for \texttt{v\textquotesingle{}\ ⊑\ v₂} to conclude that
  \texttt{𝕍\ v\textquotesingle{}\ (clos\ (ƛ\ N)\ γ)}.
\item
  Case \texttt{⊑-dist}. This case is the most difficult. We have

  \begin{myDisplay}
    𝕍 (v ↦ w) (clos (ƛ N) γ)
    𝕍 (v ↦ w') (clos (ƛ N) γ)
  \end{myDisplay}

  and need to show that

  \begin{myDisplay}
    𝕍 (v ↦ (w ⊔ w')) (clos (ƛ N) γ)
  \end{myDisplay}

  Let \texttt{c} be an arbitrary closure such that \texttt{𝔼\ v\ c}.
  Assume \texttt{w\ ⊔\ w\textquotesingle{}} is greater than a function.
  Unfortunately, this does not mean that both \texttt{w} and
  \texttt{w\textquotesingle{}} are above functions. But thanks to the
  lemma \texttt{above-fun-⊔}, we know that at least one of them is
  greater than a function.

  \begin{itemize}
  \item
    Suppose both of them are greater than a function. Then we have
    \texttt{γ\ ⊢\ N\ ⇓\ clos\ L\ δ} and \texttt{𝕍\ w\ (clos\ L\ δ)}. We
    also have \texttt{γ\ ⊢\ N\ ⇓\ c₃} and
    \texttt{𝕍\ w\textquotesingle{}\ c₃}. Because the big-step semantics
    is deterministic, we have \texttt{c₃\ ≡\ clos\ L\ δ}. Also, from
    \texttt{𝕍\ w\ (clos\ L\ δ)} we know that
    \texttt{L\ ≡\ ƛ\ N\textquotesingle{}} for some
    \texttt{N\textquotesingle{}}. We conclude that
    \texttt{𝕍\ (w\ ⊔\ w\textquotesingle{})\ (clos\ (ƛ\ N\textquotesingle{})\ δ)}.
  \item
    Suppose one of them is greater than a function and the other is not:
    say \texttt{above-fun\ w} and
    \texttt{¬\ above-fun\ w\textquotesingle{}}. Then from
    \texttt{𝕍\ (v\ ↦\ w)\ (clos\ (ƛ\ N)\ γ)} we have
    \texttt{γ\ ⊢\ N\ ⇓\ clos\ L\ γ₁} and \texttt{𝕍\ w\ (clos\ L\ γ₁)}.
    From this we have \texttt{L\ ≡\ ƛ\ N\textquotesingle{}} for some
    \texttt{N\textquotesingle{}}. Meanwhile, from
    \texttt{¬\ above-fun\ w\textquotesingle{}} we have
    \texttt{𝕍\ w\textquotesingle{}\ (clos\ L\ γ₁)}. We conclude that
    \texttt{𝕍\ (w\ ⊔\ w\textquotesingle{})\ (clos\ (ƛ\ N\textquotesingle{})\ γ₁)}.
  \end{itemize}
\end{itemize}

The proof of \texttt{sub-𝔼} is direct and explained below.

\begin{fence}
\begin{code}
sub-𝔼 {clos M γ} {v} {v'} 𝔼v v'⊑v fv'
    with 𝔼v (above-fun-⊑ fv' v'⊑v)
... | ⟨ c , ⟨ M⇓c , 𝕍v ⟩ ⟩ =
      ⟨ c , ⟨ M⇓c , sub-𝕍 𝕍v v'⊑v ⟩ ⟩
\end{code}
\end{fence}

From \texttt{above-fun\ v\textquotesingle{}} and
\texttt{v\textquotesingle{}\ ⊑\ v} we have \texttt{above-fun\ v}. Then
with \texttt{𝔼\ v\ c} we obtain a closure \texttt{c} such that
\texttt{γ\ ⊢\ M\ ⇓\ c} and \texttt{𝕍\ v\ c}. We conclude with an
application of \texttt{sub-𝕍} with \texttt{v\textquotesingle{}\ ⊑\ v} to
show \texttt{𝕍\ v\textquotesingle{}\ c}.

\hypertarget{programs-with-function-denotation-terminate-via-call-by-name}{%
\section{Programs with function denotation terminate via
call-by-name}\label{programs-with-function-denotation-terminate-via-call-by-name}}

The main lemma proves that if a term has a denotation that is above a
function, then it terminates via call-by-name. More formally, if
\texttt{γ\ ⊢\ M\ ↓\ v} and \texttt{𝔾\ γ\ γ\textquotesingle{}}, then
\texttt{𝔼\ v\ (clos\ M\ γ\textquotesingle{})}. The proof is by induction
on the derivation of \texttt{γ\ ⊢\ M\ ↓\ v} we discuss each case below.

The following lemma, kth-x, is used in the case for the \texttt{var}
rule.

\begin{fence}
\begin{code}
kth-x : ∀{Γ}{γ' : ClosEnv Γ}{x : Γ ∋ ★}
     → Σ[ Δ ∈ Context ] Σ[ δ ∈ ClosEnv Δ ] Σ[ M ∈ Δ ⊢ ★ ]
                 γ' x ≡ clos M δ
kth-x{γ' = γ'}{x = x} with γ' x
... | clos{Γ = Δ} M δ = ⟨ Δ , ⟨ δ , ⟨ M , refl ⟩ ⟩ ⟩
\end{code}
\end{fence}

\begin{fence}
\begin{code}
↓→𝔼 : ∀{Γ}{γ : Env Γ}{γ' : ClosEnv Γ}{M : Γ ⊢ ★ }{v}
            → 𝔾 γ γ' → γ ⊢ M ↓ v → 𝔼 v (clos M γ')
↓→𝔼 {Γ} {γ} {γ'} 𝔾γγ' (var{x = x}) fγx
    with kth-x{Γ}{γ'}{x} | 𝔾γγ'{x = x}
... | ⟨ Δ , ⟨ δ , ⟨ M' , eq ⟩ ⟩ ⟩ | 𝔾γγ'x rewrite eq
    with 𝔾γγ'x fγx
... | ⟨ c , ⟨ M'⇓c , 𝕍γx ⟩ ⟩ =
      ⟨ c , ⟨ (⇓-var eq M'⇓c) , 𝕍γx ⟩ ⟩
↓→𝔼 {Γ} {γ} {γ'} 𝔾γγ' (↦-elim{L = L}{M = M}{v = v₁}{w = v} d₁ d₂) fv
    with ↓→𝔼 𝔾γγ' d₁ ⟨ v₁ , ⟨ v , ⊑-refl ⟩ ⟩
... | ⟨ clos L' δ , ⟨ L⇓L' , 𝕍v₁↦v ⟩ ⟩
    with 𝕍→WHNF 𝕍v₁↦v
... | ƛ_ {N = N}
    with 𝕍v₁↦v {clos M γ'} (↓→𝔼 𝔾γγ' d₂) fv
... | ⟨ c' , ⟨ N⇓c' , 𝕍v ⟩ ⟩ =
    ⟨ c' , ⟨ ⇓-app L⇓L' N⇓c' , 𝕍v ⟩ ⟩
↓→𝔼 {Γ} {γ} {γ'} 𝔾γγ' (↦-intro{N = N}{v = v}{w = w} d) fv↦w =
    ⟨ clos (ƛ N) γ' , ⟨ ⇓-lam , E ⟩ ⟩
    where E : {c : Clos} → 𝔼 v c → above-fun w
            → Σ[ c' ∈ Clos ] (γ' ,' c) ⊢ N ⇓ c'  ×  𝕍 w c'
          E {c} 𝔼vc fw = ↓→𝔼 (λ {x} → 𝔾-ext{Γ}{γ}{γ'} 𝔾γγ' 𝔼vc {x}) d fw
↓→𝔼 𝔾γγ' ⊥-intro f⊥ = ⊥-elim (above-fun⊥ f⊥)
↓→𝔼 𝔾γγ' (⊔-intro{v = v₁}{w = v₂} d₁ d₂) fv12
    with above-fun? v₁ | above-fun? v₂
... | yes fv1 | yes fv2
    with ↓→𝔼 𝔾γγ' d₁ fv1 | ↓→𝔼 𝔾γγ' d₂ fv2
... | ⟨ c₁ , ⟨ M⇓c₁ , 𝕍v₁ ⟩ ⟩ | ⟨ c₂ , ⟨ M⇓c₂ , 𝕍v₂ ⟩ ⟩
    rewrite ⇓-determ M⇓c₂ M⇓c₁ =
    ⟨ c₁ , ⟨ M⇓c₁ , 𝕍⊔-intro 𝕍v₁ 𝕍v₂ ⟩ ⟩
↓→𝔼 𝔾γγ' (⊔-intro{v = v₁}{w = v₂} d₁ d₂) fv12 | yes fv1 | no nfv2
    with ↓→𝔼 𝔾γγ' d₁ fv1
... | ⟨ clos {Γ'} M' γ₁ , ⟨ M⇓c₁ , 𝕍v₁ ⟩ ⟩
    with 𝕍→WHNF 𝕍v₁
... | ƛ_ {N = N} =
    let 𝕍v₂ = not-above-fun-𝕍{v₂}{Γ'}{γ₁}{N} nfv2 in
    ⟨ clos (ƛ N) γ₁ , ⟨ M⇓c₁ , 𝕍⊔-intro 𝕍v₁ 𝕍v₂ ⟩ ⟩
↓→𝔼 𝔾γγ' (⊔-intro{v = v₁}{w = v₂} d₁ d₂) fv12 | no nfv1  | yes fv2
    with ↓→𝔼 𝔾γγ' d₂ fv2
... | ⟨ clos {Γ'} M' γ₁ , ⟨ M'⇓c₂ , 𝕍2c ⟩ ⟩
    with 𝕍→WHNF 𝕍2c
... | ƛ_ {N = N} =
    let 𝕍1c = not-above-fun-𝕍{v₁}{Γ'}{γ₁}{N} nfv1 in
    ⟨ clos (ƛ N) γ₁ , ⟨ M'⇓c₂ , 𝕍⊔-intro 𝕍1c 𝕍2c ⟩ ⟩
↓→𝔼 𝔾γγ' (⊔-intro d₁ d₂) fv12 | no nfv1  | no nfv2
    with above-fun-⊔ fv12
... | inj₁ fv1 = ⊥-elim (contradiction fv1 nfv1)
... | inj₂ fv2 = ⊥-elim (contradiction fv2 nfv2)
↓→𝔼 {Γ} {γ} {γ'} {M} {v'} 𝔾γγ' (sub{v = v} d v'⊑v) fv'
    with ↓→𝔼 {Γ} {γ} {γ'} {M} 𝔾γγ' d (above-fun-⊑ fv' v'⊑v)
... | ⟨ c , ⟨ M⇓c , 𝕍v ⟩ ⟩ =
      ⟨ c , ⟨ M⇓c , sub-𝕍 𝕍v v'⊑v ⟩ ⟩
\end{code}
\end{fence}

\begin{itemize}
\item
  Case \texttt{var}. Looking up \texttt{x} in
  \texttt{γ\textquotesingle{}} yields some closure,
  \texttt{clos\ M\textquotesingle{}\ δ}, and from
  \texttt{𝔾\ γ\ γ\textquotesingle{}} we have
  \texttt{𝔼\ (γ\ x)\ (clos\ M\textquotesingle{}\ δ)}. With the premise
  \texttt{above-fun\ (γ\ x)}, we obtain a closure \texttt{c} such that
  \texttt{δ\ ⊢\ M\textquotesingle{}\ ⇓\ c} and \texttt{𝕍\ (γ\ x)\ c}. To
  conclude \texttt{γ\textquotesingle{}\ ⊢\ x\ ⇓\ c} via \texttt{⇓-var},
  we need
  \texttt{γ\textquotesingle{}\ x\ ≡\ clos\ M\textquotesingle{}\ δ},
  which is obvious, but it requires some Agda shananigans via the
  \texttt{kth-x} lemma to get our hands on it.
\item
  Case \texttt{↦-elim}. We have \texttt{γ\ ⊢\ L\ ·\ M\ ↓\ v}. The
  induction hypothesis for \texttt{γ\ ⊢\ L\ ↓\ v₁\ ↦\ v} gives us
  \texttt{γ\textquotesingle{}\ ⊢\ L\ ⇓\ clos\ L\textquotesingle{}\ δ}
  and \texttt{𝕍\ v\ (clos\ L\textquotesingle{}\ δ)}. Of course,
  \texttt{L\textquotesingle{}\ ≡\ ƛ\ N} for some \texttt{N}. By the
  induction hypothesis for \texttt{γ\ ⊢\ M\ ↓\ v₁}, we have
  \texttt{𝔼\ v₁\ (clos\ M\ γ\textquotesingle{})}. Together with the
  premise \texttt{above-fun\ v} and
  \texttt{𝕍\ v\ (clos\ L\textquotesingle{}\ δ)}, we obtain a closure
  \texttt{c\textquotesingle{}} such that
  \texttt{δ\ ⊢\ N\ ⇓\ c\textquotesingle{}} and
  \texttt{𝕍\ v\ c\textquotesingle{}}. We conclude that
  \texttt{γ\textquotesingle{}\ ⊢\ L\ ·\ M\ ⇓\ c\textquotesingle{}} by
  rule \texttt{⇓-app}.
\item
  Case \texttt{↦-intro}. We have \texttt{γ\ ⊢\ ƛ\ N\ ↓\ v\ ↦\ w}. We
  immediately have
  \texttt{γ\textquotesingle{}\ ⊢\ ƛ\ M\ ⇓\ clos\ (ƛ\ M)\ γ\textquotesingle{}}
  by rule \texttt{⇓-lam}. But we also need to prove
  \texttt{𝕍\ (v\ ↦\ w)\ (clos\ (ƛ\ N)\ γ\textquotesingle{})}. Let
  \texttt{c} by an arbitrary closure such that \texttt{𝔼\ v\ c}. Suppose
  \texttt{v\textquotesingle{}} is greater than a function value. We need
  to show that
  \texttt{γ\textquotesingle{}\ ,\ c\ ⊢\ N\ ⇓\ c\textquotesingle{}} and
  \texttt{𝕍\ v\textquotesingle{}\ c\textquotesingle{}} for some
  \texttt{c\textquotesingle{}}. We prove this by the induction
  hypothesis for \texttt{γ\ ,\ v\ ⊢\ N\ ↓\ v\textquotesingle{}} but we
  must first show that
  \texttt{𝔾\ (γ\ ,\ v)\ (γ\textquotesingle{}\ ,\ c)}. We prove that by
  the lemma \texttt{𝔾-ext}, using facts
  \texttt{𝔾\ γ\ γ\textquotesingle{}} and \texttt{𝔼\ v\ c}.
\item
  Case \texttt{⊥-intro}. We have the premise \texttt{above-fun\ ⊥}, but
  that's impossible.
\item
  Case \texttt{⊔-intro}. We have \texttt{γ\ ⊢\ M\ ↓\ (v₁\ ⊔\ v₂)} and
  \texttt{above-fun\ (v₁\ ⊔\ v₂)} and need to show
  \texttt{γ\textquotesingle{}\ ⊢\ M\ ↓\ c} and
  \texttt{𝕍\ (v₁\ ⊔\ v₂)\ c} for some \texttt{c}. Again, by
  \texttt{above-fun-⊔}, at least one of \texttt{v₁} or \texttt{v₂} is
  greater than a function.

  \begin{itemize}
  \item
    Suppose both \texttt{v₁} and \texttt{v₂} are greater than a function
    value. By the induction hypotheses for \texttt{γ\ ⊢\ M\ ↓\ v₁} and
    \texttt{γ\ ⊢\ M\ ↓\ v₂} we have
    \texttt{γ\textquotesingle{}\ ⊢\ M\ ⇓\ c₁}, \texttt{𝕍\ v₁\ c₁},
    \texttt{γ\textquotesingle{}\ ⊢\ M\ ⇓\ c₂}, and \texttt{𝕍\ v₂\ c₂}
    for some \texttt{c₁} and \texttt{c₂}. Because \texttt{⇓} is
    deterministic, we have \texttt{c₂\ ≡\ c₁}. Then by \texttt{𝕍⊔-intro}
    we conclude that \texttt{𝕍\ (v₁\ ⊔\ v₂)\ c₁}.
  \item
    Without loss of generality, suppose \texttt{v₁} is greater than a
    function value but \texttt{v₂} is not. By the induction hypotheses
    for \texttt{γ\ ⊢\ M\ ↓\ v₁}, and using \texttt{𝕍→WHNF}, we have
    \texttt{γ\textquotesingle{}\ ⊢\ M\ ⇓\ clos\ (ƛ\ N)\ γ₁} and
    \texttt{𝕍\ v₁\ (clos\ (ƛ\ N)\ γ₁)}. Then because \texttt{v₂} is not
    greater than a function, we also have
    \texttt{𝕍\ v₂\ (clos\ (ƛ\ N)\ γ₁)}. We conclude that
    \texttt{𝕍\ (v₁\ ⊔\ v₂)\ (clos\ (ƛ\ N)\ γ₁)}.
  \end{itemize}
\item
  Case \texttt{sub}. We have \texttt{γ\ ⊢\ M\ ↓\ v},
  \texttt{v\textquotesingle{}\ ⊑\ v}, and
  \texttt{above-fun\ v\textquotesingle{}}. We need to show that
  \texttt{γ\textquotesingle{}\ ⊢\ M\ ⇓\ c} and
  \texttt{𝕍\ v\textquotesingle{}\ c} for some \texttt{c}. We have
  \texttt{above-fun\ v} by \texttt{above-fun-⊑}, so the induction
  hypothesis for \texttt{γ\ ⊢\ M\ ↓\ v} gives us a closure \texttt{c}
  such that \texttt{γ\textquotesingle{}\ ⊢\ M\ ⇓\ c} and
  \texttt{𝕍\ v\ c}. We conclude that \texttt{𝕍\ v\textquotesingle{}\ c}
  by \texttt{sub-𝕍}.
\end{itemize}

\hypertarget{proof-of-denotational-adequacy}{%
\section{Proof of denotational
adequacy}\label{proof-of-denotational-adequacy}}

From the main lemma we can directly show that
\texttt{ℰ\ M\ ≃\ ℰ\ (ƛ\ N)} implies that \texttt{M} big-steps to a
lambda, i.e., \texttt{∅\ ⊢\ M\ ⇓\ clos\ (ƛ\ N′)\ γ}.

\begin{fence}
\begin{code}
↓→⇓ : ∀{M : ∅ ⊢ ★}{N : ∅ , ★ ⊢ ★}  →  ℰ M ≃ ℰ (ƛ N)
         →  Σ[ Γ ∈ Context ] Σ[ N′ ∈ (Γ , ★ ⊢ ★) ] Σ[ γ ∈ ClosEnv Γ ]
            ∅' ⊢ M ⇓ clos (ƛ N′) γ
↓→⇓{M}{N} eq
    with ↓→𝔼 𝔾-∅ ((proj₂ (eq `∅ (⊥ ↦ ⊥))) (↦-intro ⊥-intro))
                 ⟨ ⊥ , ⟨ ⊥ , ⊑-refl ⟩ ⟩
... | ⟨ clos {Γ} M′ γ , ⟨ M⇓c , Vc ⟩ ⟩
    with 𝕍→WHNF Vc
... | ƛ_ {N = N′} =
    ⟨ Γ , ⟨ N′ , ⟨ γ , M⇓c ⟩  ⟩ ⟩
\end{code}
\end{fence}

The proof goes as follows. We derive \texttt{∅\ ⊢\ ƛ\ N\ ↓\ ⊥\ ↦\ ⊥} and
then \texttt{ℰ\ M\ ≃\ ℰ\ (ƛ\ N)} gives us \texttt{∅\ ⊢\ M\ ↓\ ⊥\ ↦\ ⊥}.
We conclude by applying the main lemma to obtain
\texttt{∅\ ⊢\ M\ ⇓\ clos\ (ƛ\ N′)\ γ} for some \texttt{N′} and
\texttt{γ}.

Now to prove the adequacy property. We apply the above lemma to obtain
\texttt{∅\ ⊢\ M\ ⇓\ clos\ (ƛ\ N′)\ γ} and then apply \texttt{cbn→reduce}
to conclude.

\begin{fence}
\begin{code}
adequacy : ∀{M : ∅ ⊢ ★}{N : ∅ , ★ ⊢ ★}
   →  ℰ M ≃ ℰ (ƛ N)
   → Σ[ N′ ∈ (∅ , ★ ⊢ ★) ]
     (M —↠ ƛ N′)
adequacy{M}{N} eq
    with ↓→⇓ eq
... | ⟨ Γ , ⟨ N′ , ⟨ γ , M⇓ ⟩ ⟩ ⟩ =
    cbn→reduce M⇓
\end{code}
\end{fence}

\hypertarget{call-by-name-is-equivalent-to-beta-reduction}{%
\section{Call-by-name is equivalent to beta
reduction}\label{call-by-name-is-equivalent-to-beta-reduction}}

As promised, we return to the question of whether call-by-name
evaluation is equivalent to beta reduction. In chapter
\protect\hyperlink{BigStep}{BigStep} we established the forward
direction: that if call-by-name produces a result, then the program beta
reduces to a lambda abstraction (\texttt{cbn→reduce}). We now prove the
backward direction of the if-and-only-if, leveraging our results about
the denotational semantics.

\begin{fence}
\begin{code}
reduce→cbn : ∀ {M : ∅ ⊢ ★} {N : ∅ , ★ ⊢ ★}
           → M —↠ ƛ N
           → Σ[ Δ ∈ Context ] Σ[ N′ ∈ Δ , ★ ⊢ ★ ] Σ[ δ ∈ ClosEnv Δ ]
             ∅' ⊢ M ⇓ clos (ƛ N′) δ
reduce→cbn M—↠ƛN = ↓→⇓ (soundness M—↠ƛN)
\end{code}
\end{fence}

Suppose \texttt{M\ —↠\ ƛ\ N}. Soundness of the denotational semantics
gives us \texttt{ℰ\ M\ ≃\ ℰ\ (ƛ\ N)}. Then by \texttt{↓→⇓} we conclude
that \texttt{∅\textquotesingle{}\ ⊢\ M\ ⇓\ clos\ (ƛ\ N′)\ δ} for some
\texttt{N′} and \texttt{δ}.

Putting the two directions of the if-and-only-if together, we establish
that call-by-name evaluation is equivalent to beta reduction in the
following sense.

\begin{fence}
\begin{code}
cbn↔reduce : ∀ {M : ∅ ⊢ ★}
           → (Σ[ N ∈ ∅ , ★ ⊢ ★ ] (M —↠ ƛ N))
             iff
             (Σ[ Δ ∈ Context ] Σ[ N′ ∈ Δ , ★ ⊢ ★ ] Σ[ δ ∈ ClosEnv Δ ]
               ∅' ⊢ M ⇓ clos (ƛ N′) δ)
cbn↔reduce {M} = ⟨ (λ x → reduce→cbn (proj₂ x)) ,
                   (λ x → cbn→reduce (proj₂ (proj₂ (proj₂ x)))) ⟩
\end{code}
\end{fence}

\hypertarget{unicode}{%
\section{Unicode}\label{unicode}}

This chapter uses the following unicode:

\begin{myDisplay}
𝔼  U+1D53C  MATHEMATICAL DOUBLE-STRUCK CAPITAL E (\bE)
𝔾  U+1D53E  MATHEMATICAL DOUBLE-STRUCK CAPITAL G (\bG)
𝕍  U+1D53E  MATHEMATICAL DOUBLE-STRUCK CAPITAL V (\bV)
\end{myDisplay}

