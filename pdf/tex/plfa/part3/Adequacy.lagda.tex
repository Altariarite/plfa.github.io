\hypertarget{Adequacy}{%
\chapter{Adequacy: Adequacy of denotational semantics with respect to
operational semantics}\label{Adequacy}}

\begin{fence}
\begin{code}
module plfa.part3.Adequacy where
\end{code}
\end{fence}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

Having proved a preservation property in the last chapter, a natural
next step would be to prove progress. That is, to prove a property of
the form

\begin{myDisplay}
If Î³ âŠ¢ M â†“ v, then either M is a lambda abstraction or M â€”â†’ N for some N.
\end{myDisplay}

Such a property would tell us that having a denotation implies either
reduction to normal form or divergence. This is indeed true, but we can
prove a much stronger property! In fact, having a denotation that is a
function value (not \texttt{âŠ¥}) implies reduction to a lambda
abstraction.

This stronger property, reformulated a bit, is known as \emph{adequacy}.
That is, if a term \texttt{M} is denotationally equal to a lambda
abstraction, then \texttt{M} reduces to a lambda abstraction.

\begin{myDisplay}
â„° M â‰ƒ â„° (Æ› N)  implies M â€”â†  Æ› N' for some N'
\end{myDisplay}

Recall that \texttt{â„°\ M\ â‰ƒ\ â„°\ (Æ›\ N)} is equivalent to saying that
\texttt{Î³\ âŠ¢\ M\ â†“\ (v\ â†¦\ w)} for some \texttt{v} and \texttt{w}. We
will show that \texttt{Î³\ âŠ¢\ M\ â†“\ (v\ â†¦\ w)} implies multi-step
reduction a lambda abstraction. The recursive structure of the
derivations for \texttt{Î³\ âŠ¢\ M\ â†“\ (v\ â†¦\ w)} are completely different
from the structure of multi-step reductions, so a direct proof would be
challenging. However, The structure of \texttt{Î³\ âŠ¢\ M\ â†“\ (v\ â†¦\ w)}
closer to that of \protect\hyperlink{BigStep}{BigStep} call-by-name
evaluation. Further, we already proved that big-step evaluation implies
multi-step reduction to a lambda (\texttt{cbnâ†’reduce}). So we shall
prove that \texttt{Î³\ âŠ¢\ M\ â†“\ (v\ â†¦\ w)} implies that
\texttt{Î³\textquotesingle{}\ âŠ¢\ M\ â‡“\ c}, where \texttt{c} is a closure
(a term paired with an environment), \texttt{Î³\textquotesingle{}} is an
environment that maps variables to closures, and \texttt{Î³} and
\texttt{Î³\textquotesingle{}} are appropriate related. The proof will be
an induction on the derivation of \texttt{Î³\ âŠ¢\ M\ â†“\ v}, and to
strengthen the induction hypothesis, we will relate semantic values to
closures using a \emph{logical relation} \texttt{ğ•}.

The rest of this chapter is organized as follows.

\begin{itemize}
\item
  To make the \texttt{ğ•} relation down-closed with respect to
  \texttt{âŠ‘}, we must loosen the requirement that \texttt{M} result in a
  function value and instead require that \texttt{M} result in a value
  that is greater than or equal to a function value. We establish
  several properties about being ``greater than a function'\,'.
\item
  We define the logical relation \texttt{ğ•} that relates values and
  closures, and extend it to a relation on terms \texttt{ğ”¼} and
  environments \texttt{ğ”¾}. We prove several lemmas that culminate in the
  property that if \texttt{ğ•\ v\ c} and \texttt{vâ€²\ âŠ‘\ v}, then
  \texttt{ğ•\ vâ€²\ c}.
\item
  We prove the main lemma, that if \texttt{ğ”¾\ Î³\ Î³\textquotesingle{}}
  and \texttt{Î³\ âŠ¢\ M\ â†“\ v}, then
  \texttt{ğ”¼\ v\ (clos\ M\ Î³\textquotesingle{})}.
\item
  We prove adequacy as a corollary to the main lemma.
\end{itemize}

\hypertarget{imports}{%
\section{Imports}\label{imports}}

\begin{fence}
\begin{code}
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_â‰¡_; _â‰¢_; refl; trans; sym; cong; congâ‚‚; cong-app)
open import Data.Product using (_Ã—_; Î£; Î£-syntax; âˆƒ; âˆƒ-syntax; projâ‚; projâ‚‚)
  renaming (_,_ to âŸ¨_,_âŸ©)
open import Data.Sum
open import Relation.Nullary using (Â¬_)
open import Relation.Nullary.Negation using (contradiction)
open import Data.Empty using (âŠ¥-elim) renaming (âŠ¥ to Bot)
open import Data.Unit
open import Relation.Nullary using (Dec; yes; no)
open import Function using (_âˆ˜_)
open import plfa.part2.Untyped
     using (Context; _âŠ¢_; â˜…; _âˆ‹_; âˆ…; _,_; Z; S_; `_; Æ›_; _Â·_;
            rename; subst; ext; exts; _[_]; subst-zero;
            _â€”â† _; _â€”â†’âŸ¨_âŸ©_; _âˆ; _â€”â†’_; Î¾â‚; Î¾â‚‚; Î²; Î¶)
open import plfa.part2.Substitution using (ids; sub-id)
open import plfa.part2.BigStep
     using (Clos; clos; ClosEnv; âˆ…'; _,'_; _âŠ¢_â‡“_; â‡“-var; â‡“-lam; â‡“-app; â‡“-determ;
            cbnâ†’reduce)
open import plfa.part3.Denotational
     using (Value; Env; `âˆ…; _`,_; _â†¦_; _âŠ‘_; _âŠ¢_â†“_; âŠ¥; all-funsâˆˆ; _âŠ”_; âˆˆâ†’âŠ‘;
            var; â†¦-elim; â†¦-intro; âŠ”-intro; âŠ¥-intro; sub; â„°; _â‰ƒ_; _iff_;
            âŠ‘-trans; âŠ‘-conj-R1; âŠ‘-conj-R2; âŠ‘-conj-L; âŠ‘-refl; âŠ‘-fun; âŠ‘-bot; âŠ‘-dist;
            sub-inv-fun)
open import plfa.part3.Soundness using (soundness)

\end{code}
\end{fence}

\hypertarget{the-property-of-being-greater-or-equal-to-a-function}{%
\section{The property of being greater or equal to a
function}\label{the-property-of-being-greater-or-equal-to-a-function}}

We define the following short-hand for saying that a value is
greater-than or equal to a function value.

\begin{fence}
\begin{code}
above-fun : Value â†’ Set
above-fun u = Î£[ v âˆˆ Value ] Î£[ w âˆˆ Value ] v â†¦ w âŠ‘ u
\end{code}
\end{fence}

If a value \texttt{u} is greater than a function, then an even greater
value \texttt{u\textquotesingle{}} is too.

\begin{fence}
\begin{code}
above-fun-âŠ‘ : âˆ€{u u' : Value}
      â†’ above-fun u â†’ u âŠ‘ u'
        -------------------
      â†’ above-fun u'
above-fun-âŠ‘ âŸ¨ v , âŸ¨ w , lt' âŸ© âŸ© lt = âŸ¨ v , âŸ¨ w , âŠ‘-trans lt' lt âŸ© âŸ©
\end{code}
\end{fence}

The bottom value \texttt{âŠ¥} is not greater than a function.

\begin{fence}
\begin{code}
above-funâŠ¥ : Â¬ above-fun âŠ¥
above-funâŠ¥ âŸ¨ v , âŸ¨ w , lt âŸ© âŸ©
    with sub-inv-fun lt
... | âŸ¨ Î“ , âŸ¨ f , âŸ¨ Î“âŠ†âŠ¥ , âŸ¨ lt1 , lt2 âŸ© âŸ© âŸ© âŸ©
    with all-funsâˆˆ f
... | âŸ¨ A , âŸ¨ B , m âŸ© âŸ©
    with Î“âŠ†âŠ¥ m
... | ()
\end{code}
\end{fence}

If the join of two values \texttt{u} and \texttt{u\textquotesingle{}} is
greater than a function, then at least one of them is too.

\begin{fence}
\begin{code}
above-fun-âŠ” : âˆ€{u u'}
           â†’ above-fun (u âŠ” u')
           â†’ above-fun u âŠ above-fun u'
above-fun-âŠ”{u}{u'} âŸ¨ v , âŸ¨ w , vâ†¦wâŠ‘uâŠ”u' âŸ© âŸ©
    with sub-inv-fun vâ†¦wâŠ‘uâŠ”u'
... | âŸ¨ Î“ , âŸ¨ f , âŸ¨ Î“âŠ†uâŠ”u' , âŸ¨ lt1 , lt2 âŸ© âŸ© âŸ© âŸ©
    with all-funsâˆˆ f
... | âŸ¨ A , âŸ¨ B , m âŸ© âŸ©
    with Î“âŠ†uâŠ”u' m
... | injâ‚ x = injâ‚ âŸ¨ A , âŸ¨ B , (âˆˆâ†’âŠ‘ x) âŸ© âŸ©
... | injâ‚‚ x = injâ‚‚ âŸ¨ A , âŸ¨ B , (âˆˆâ†’âŠ‘ x) âŸ© âŸ©
\end{code}
\end{fence}

On the other hand, if neither of \texttt{u} and
\texttt{u\textquotesingle{}} is greater than a function, then their join
is also not greater than a function.

\begin{fence}
\begin{code}
not-above-fun-âŠ” : âˆ€{u u' : Value}
               â†’ Â¬ above-fun u â†’ Â¬ above-fun u'
               â†’ Â¬ above-fun (u âŠ” u')
not-above-fun-âŠ” naf1 naf2 af12
    with above-fun-âŠ” af12
... | injâ‚ af1 = contradiction af1 naf1
... | injâ‚‚ af2 = contradiction af2 naf2
\end{code}
\end{fence}

The converse is also true. If the join of two values is not above a
function, then neither of them is individually.

\begin{fence}
\begin{code}
not-above-fun-âŠ”-inv : âˆ€{u u' : Value} â†’ Â¬ above-fun (u âŠ” u')
              â†’ Â¬ above-fun u Ã— Â¬ above-fun u'
not-above-fun-âŠ”-inv af = âŸ¨ f af , g af âŸ©
  where
    f : âˆ€{u u' : Value} â†’ Â¬ above-fun (u âŠ” u') â†’ Â¬ above-fun u
    f{u}{u'} af12 âŸ¨ v , âŸ¨ w , lt âŸ© âŸ© =
        contradiction âŸ¨ v , âŸ¨ w , âŠ‘-conj-R1 lt âŸ© âŸ© af12
    g : âˆ€{u u' : Value} â†’ Â¬ above-fun (u âŠ” u') â†’ Â¬ above-fun u'
    g{u}{u'} af12 âŸ¨ v , âŸ¨ w , lt âŸ© âŸ© =
        contradiction âŸ¨ v , âŸ¨ w , âŠ‘-conj-R2 lt âŸ© âŸ© af12
\end{code}
\end{fence}

The property of being greater than a function value is decidable, as
exhibited by the following function.

\begin{fence}
\begin{code}
above-fun? : (v : Value) â†’ Dec (above-fun v)
above-fun? âŠ¥ = no above-funâŠ¥
above-fun? (v â†¦ w) = yes âŸ¨ v , âŸ¨ w , âŠ‘-refl âŸ© âŸ©
above-fun? (u âŠ” u')
    with above-fun? u | above-fun? u'
... | yes âŸ¨ v , âŸ¨ w , lt âŸ© âŸ© | _ = yes âŸ¨ v , âŸ¨ w , (âŠ‘-conj-R1 lt) âŸ© âŸ©
... | no _ | yes âŸ¨ v , âŸ¨ w , lt âŸ© âŸ© = yes âŸ¨ v , âŸ¨ w , (âŠ‘-conj-R2 lt) âŸ© âŸ©
... | no x | no y = no (not-above-fun-âŠ” x y)
\end{code}
\end{fence}

\hypertarget{relating-values-to-closures}{%
\section{Relating values to
closures}\label{relating-values-to-closures}}

Next we relate semantic values to closures. The relation \texttt{ğ•} is
for closures whose term is a lambda abstraction, i.e., in weak-head
normal form (WHNF). The relation ğ”¼ is for any closure. Roughly speaking,
\texttt{ğ”¼\ v\ c} will hold if, when \texttt{v} is greater than a
function value, \texttt{c} evaluates to a closure
\texttt{c\textquotesingle{}} in WHNF and
\texttt{ğ•\ v\ c\textquotesingle{}}. Regarding \texttt{ğ•\ v\ c}, it will
hold when \texttt{c} is in WHNF, and if \texttt{v} is a function, the
body of \texttt{c} evaluates according to \texttt{v}.

\begin{fence}
\begin{code}
ğ• : Value â†’ Clos â†’ Set
ğ”¼ : Value â†’ Clos â†’ Set
\end{code}
\end{fence}

We define \texttt{ğ•} as a function from values and closures to
\texttt{Set} and not as a data type because it is mutually recursive
with \texttt{ğ”¼} in a negative position (to the left of an implication).
We first perform case analysis on the term in the closure. If the term
is a variable or application, then \texttt{ğ•} is false (\texttt{Bot}).
If the term is a lambda abstraction, we define \texttt{ğ•} by recursion
on the value, which we describe below.

\begin{fence}
\begin{code}
ğ• v (clos (` xâ‚) Î³) = Bot
ğ• v (clos (M Â· Mâ‚) Î³) = Bot
ğ• âŠ¥ (clos (Æ› M) Î³) = âŠ¤
ğ• (v â†¦ w) (clos (Æ› N) Î³) =
    (âˆ€{c : Clos} â†’ ğ”¼ v c â†’ above-fun w â†’ Î£[ c' âˆˆ Clos ]
        (Î³ ,' c) âŠ¢ N â‡“ c'  Ã—  ğ• w c')
ğ• (u âŠ” v) (clos (Æ› N) Î³) = ğ• u (clos (Æ› N) Î³) Ã— ğ• v (clos (Æ› N) Î³)
\end{code}
\end{fence}

\begin{itemize}
\item
  If the value is \texttt{âŠ¥}, then the result is true (\texttt{âŠ¤}).
\item
  If the value is a join (u âŠ” v), then the result is the pair
  (conjunction) of ğ• is true for both u and v.
\item
  The important case is for a function value \texttt{v\ â†¦\ w} and
  closure \texttt{clos\ (Æ›\ N)\ Î³}. Given any closure \texttt{c} such
  that \texttt{ğ”¼\ v\ c}, if \texttt{w} is greater than a function, then
  \texttt{N} evaluates (with \texttt{Î³} extended with \texttt{c}) to
  some closure \texttt{c\textquotesingle{}} and we have
  \texttt{ğ•\ w\ c\textquotesingle{}}.
\end{itemize}

The definition of \texttt{ğ”¼} is straightforward. If \texttt{v} is a
greater than a function, then \texttt{M} evaluates to a closure related
to \texttt{v}.

\begin{fence}
\begin{code}
ğ”¼ v (clos M Î³') = above-fun v â†’ Î£[ c âˆˆ Clos ] Î³' âŠ¢ M â‡“ c Ã— ğ• v c
\end{code}
\end{fence}

The proof of the main lemma is by induction on \texttt{Î³\ âŠ¢\ M\ â†“\ v},
so it goes underneath lambda abstractions and must therefore reason
about open terms (terms with variables). So we must relate environments
of semantic values to environments of closures. In the following,
\texttt{ğ”¾} relates \texttt{Î³} to \texttt{Î³\textquotesingle{}} if the
corresponding values and closures are related by \texttt{ğ”¼}.

\begin{fence}
\begin{code}
ğ”¾ : âˆ€{Î“} â†’ Env Î“ â†’ ClosEnv Î“ â†’ Set
ğ”¾ {Î“} Î³ Î³' = âˆ€{x : Î“ âˆ‹ â˜…} â†’ ğ”¼ (Î³ x) (Î³' x)

ğ”¾-âˆ… : ğ”¾ `âˆ… âˆ…'
ğ”¾-âˆ… {()}

ğ”¾-ext : âˆ€{Î“}{Î³ : Env Î“}{Î³' : ClosEnv Î“}{v c}
      â†’ ğ”¾ Î³ Î³' â†’ ğ”¼ v c â†’ ğ”¾ (Î³ `, v) (Î³' ,' c)
ğ”¾-ext {Î“} {Î³} {Î³'} g e {Z} = e
ğ”¾-ext {Î“} {Î³} {Î³'} g e {S x} = g
\end{code}
\end{fence}

We need a few properties of the \texttt{ğ•} and \texttt{ğ”¼} relations. The
first is that a closure in the \texttt{ğ•} relation must be in weak-head
normal form. We define WHNF has follows.

\begin{fence}
\begin{code}
data WHNF : âˆ€ {Î“ A} â†’ Î“ âŠ¢ A â†’ Set where
  Æ›_ : âˆ€ {Î“} {N : Î“ , â˜… âŠ¢ â˜…}
     â†’ WHNF (Æ› N)
\end{code}
\end{fence}

The proof goes by cases on the term in the closure.

\begin{fence}
\begin{code}
ğ•â†’WHNF : âˆ€{Î“}{Î³ : ClosEnv Î“}{M : Î“ âŠ¢ â˜…}{v}
       â†’ ğ• v (clos M Î³) â†’ WHNF M
ğ•â†’WHNF {M = ` x} {v} ()
ğ•â†’WHNF {M = Æ› N} {v} vc = Æ›_
ğ•â†’WHNF {M = L Â· M} {v} ()
\end{code}
\end{fence}

Next we have an introduction rule for \texttt{ğ•} that mimics the
\texttt{âŠ”-intro} rule. If both \texttt{u} and \texttt{v} are related to
a closure \texttt{c}, then their join is too.

\begin{fence}
\begin{code}
ğ•âŠ”-intro : âˆ€{c u v}
         â†’ ğ• u c â†’ ğ• v c
           ---------------
         â†’ ğ• (u âŠ” v) c
ğ•âŠ”-intro {clos (` x) Î³} () vc
ğ•âŠ”-intro {clos (Æ› N) Î³} uc vc = âŸ¨ uc , vc âŸ©
ğ•âŠ”-intro {clos (L Â· M) Î³} () vc
\end{code}
\end{fence}

In a moment we prove that \texttt{ğ•} is preserved when going from a
greater value to a lesser value: if \texttt{ğ•\ v\ c} and
\texttt{v\textquotesingle{}\ âŠ‘\ v}, then
\texttt{ğ•\ v\textquotesingle{}\ c}. This property, named \texttt{ğ•-sub},
is needed by the main lemma in the case for the \texttt{sub} rule.

To prove \texttt{ğ•-sub}, we in turn need the following property
concerning values that are not greater than a function, that is, values
that are equivalent to \texttt{âŠ¥}. In such cases,
\texttt{ğ•\ v\ (clos\ (Æ›\ N)\ Î³\textquotesingle{})} is trivially true.

\begin{fence}
\begin{code}
not-above-fun-ğ• : âˆ€{v : Value}{Î“}{Î³' : ClosEnv Î“}{N : Î“ , â˜… âŠ¢ â˜… }
    â†’ Â¬ above-fun v
      -------------------
    â†’ ğ• v (clos (Æ› N) Î³')
not-above-fun-ğ• {âŠ¥} af = tt
not-above-fun-ğ• {v â†¦ v'} af = âŠ¥-elim (contradiction âŸ¨ v , âŸ¨ v' , âŠ‘-refl âŸ© âŸ© af)
not-above-fun-ğ• {vâ‚ âŠ” vâ‚‚} af
    with not-above-fun-âŠ”-inv af
... | âŸ¨ af1 , af2 âŸ© = âŸ¨ not-above-fun-ğ• af1 , not-above-fun-ğ• af2 âŸ©
\end{code}
\end{fence}

The proofs of \texttt{ğ•-sub} and \texttt{ğ”¼-sub} are intertwined.

\begin{fence}
\begin{code}
sub-ğ• : âˆ€{c : Clos}{v v'} â†’ ğ• v c â†’ v' âŠ‘ v â†’ ğ• v' c
sub-ğ”¼ : âˆ€{c : Clos}{v v'} â†’ ğ”¼ v c â†’ v' âŠ‘ v â†’ ğ”¼ v' c
\end{code}
\end{fence}

We prove \texttt{ğ•-sub} by case analysis on the closure's term, to
dispatch the cases for variables and application. We then proceed by
induction on \texttt{v\textquotesingle{}\ âŠ‘\ v}. We describe each case
below.

\begin{fence}
\begin{code}
sub-ğ• {clos (` x) Î³} {v} () lt
sub-ğ• {clos (L Â· M) Î³} () lt
sub-ğ• {clos (Æ› N) Î³} vc âŠ‘-bot = tt
sub-ğ• {clos (Æ› N) Î³} vc (âŠ‘-conj-L lt1 lt2) = âŸ¨ (sub-ğ• vc lt1) , sub-ğ• vc lt2 âŸ©
sub-ğ• {clos (Æ› N) Î³} âŸ¨ vv1 , vv2 âŸ© (âŠ‘-conj-R1 lt) = sub-ğ• vv1 lt
sub-ğ• {clos (Æ› N) Î³} âŸ¨ vv1 , vv2 âŸ© (âŠ‘-conj-R2 lt) = sub-ğ• vv2 lt
sub-ğ• {clos (Æ› N) Î³} vc (âŠ‘-trans{v = vâ‚‚} lt1 lt2) = sub-ğ• (sub-ğ• vc lt2) lt1
sub-ğ• {clos (Æ› N) Î³} vc (âŠ‘-fun lt1 lt2) ev1 sf
    with vc (sub-ğ”¼ ev1 lt1) (above-fun-âŠ‘ sf lt2)
... | âŸ¨ c , âŸ¨ Nc , v4 âŸ© âŸ© = âŸ¨ c , âŸ¨ Nc , sub-ğ• v4 lt2 âŸ© âŸ©
sub-ğ• {clos (Æ› N) Î³} {v â†¦ w âŠ” v â†¦ w'} âŸ¨ vcw , vcw' âŸ© âŠ‘-dist ev1c sf
    with above-fun? w | above-fun? w'
... | yes af2 | yes af3
    with vcw ev1c af2 | vcw' ev1c af3
... | âŸ¨ clos L Î´ , âŸ¨ Lâ‡“câ‚‚ , ğ•w âŸ© âŸ©
    | âŸ¨ câ‚ƒ , âŸ¨ Lâ‡“câ‚ƒ , ğ•w' âŸ© âŸ© rewrite â‡“-determ Lâ‡“câ‚ƒ Lâ‡“câ‚‚ with ğ•â†’WHNF ğ•w
... | Æ›_ =
      âŸ¨ clos L Î´ , âŸ¨ Lâ‡“câ‚‚ , âŸ¨ ğ•w , ğ•w' âŸ© âŸ© âŸ©
sub-ğ• {c} {v â†¦ w âŠ” v â†¦ w'} âŸ¨ vcw , vcw' âŸ©  âŠ‘-dist ev1c sf
    | yes af2 | no naf3
    with vcw ev1c af2
... | âŸ¨ clos {Î“'} L Î³â‚ , âŸ¨ Lâ‡“c2 , ğ•w âŸ© âŸ©
    with ğ•â†’WHNF ğ•w
... | Æ›_ {N = N'} =
      let ğ•w' = not-above-fun-ğ•{w'}{Î“'}{Î³â‚}{N'} naf3 in
      âŸ¨ clos (Æ› N') Î³â‚ , âŸ¨ Lâ‡“c2 , ğ•âŠ”-intro ğ•w ğ•w' âŸ© âŸ©
sub-ğ• {c} {v â†¦ w âŠ” v â†¦ w'} âŸ¨ vcw , vcw' âŸ© âŠ‘-dist ev1c sf
    | no naf2 | yes af3
    with vcw' ev1c af3
... | âŸ¨ clos {Î“'} L Î³â‚ , âŸ¨ Lâ‡“c3 , ğ•w'c âŸ© âŸ©
    with ğ•â†’WHNF ğ•w'c
... | Æ›_ {N = N'} =
      let ğ•wc = not-above-fun-ğ•{w}{Î“'}{Î³â‚}{N'} naf2 in
      âŸ¨ clos (Æ› N') Î³â‚ , âŸ¨ Lâ‡“c3 , ğ•âŠ”-intro ğ•wc ğ•w'c âŸ© âŸ©
sub-ğ• {c} {v â†¦ w âŠ” v â†¦ w'} âŸ¨ vcw , vcw' âŸ© âŠ‘-dist ev1c âŸ¨ v' , âŸ¨ w'' , lt âŸ© âŸ©
    | no naf2 | no naf3
    with above-fun-âŠ” âŸ¨ v' , âŸ¨ w'' , lt âŸ© âŸ©
... | injâ‚ af2 = âŠ¥-elim (contradiction af2 naf2)
... | injâ‚‚ af3 = âŠ¥-elim (contradiction af3 naf3)
\end{code}
\end{fence}

\begin{itemize}
\item
  Case \texttt{âŠ‘-bot}. We immediately have
  \texttt{ğ•\ âŠ¥\ (clos\ (Æ›\ N)\ Î³)}.
\item
  Case \texttt{âŠ‘-conj-L}.

  \begin{myDisplay}
    vâ‚' âŠ‘ v     vâ‚‚' âŠ‘ v
    -------------------
    (vâ‚' âŠ” vâ‚‚') âŠ‘ v
  \end{myDisplay}

  The induction hypotheses gives us
  \texttt{ğ•\ vâ‚\textquotesingle{}\ (clos\ (Æ›\ N)\ Î³)} and
  \texttt{ğ•\ vâ‚‚\textquotesingle{}\ (clos\ (Æ›\ N)\ Î³)}, which is all we
  need for this case.
\item
  Case \texttt{âŠ‘-conj-R1}.

  \begin{myDisplay}
    v' âŠ‘ vâ‚
    -------------
    v' âŠ‘ (vâ‚ âŠ” vâ‚‚)
  \end{myDisplay}

  The induction hypothesis gives us
  \texttt{ğ•\ v\textquotesingle{}\ (clos\ (Æ›\ N)\ Î³)}.
\item
  Case \texttt{âŠ‘-conj-R2}.

  \begin{myDisplay}
    v' âŠ‘ vâ‚‚
    -------------
    v' âŠ‘ (vâ‚ âŠ” vâ‚‚)
  \end{myDisplay}

  Again, the induction hypothesis gives us
  \texttt{ğ•\ v\textquotesingle{}\ (clos\ (Æ›\ N)\ Î³)}.
\item
  Case \texttt{âŠ‘-trans}.

  \begin{myDisplay}
    v' âŠ‘ vâ‚‚   vâ‚‚ âŠ‘ v
    -----------------
         v' âŠ‘ v
  \end{myDisplay}

  The induction hypothesis for \texttt{vâ‚‚\ âŠ‘\ v} gives us
  \texttt{ğ•\ vâ‚‚\ (clos\ (Æ›\ N)\ Î³)}. We apply the induction hypothesis
  for \texttt{v\textquotesingle{}\ âŠ‘\ vâ‚‚} to conclude that
  \texttt{ğ•\ v\textquotesingle{}\ (clos\ (Æ›\ N)\ Î³)}.
\item
  Case \texttt{âŠ‘-dist}. This case is the most difficult. We have

  \begin{myDisplay}
    ğ• (v â†¦ w) (clos (Æ› N) Î³)
    ğ• (v â†¦ w') (clos (Æ› N) Î³)
  \end{myDisplay}

  and need to show that

  \begin{myDisplay}
    ğ• (v â†¦ (w âŠ” w')) (clos (Æ› N) Î³)
  \end{myDisplay}

  Let \texttt{c} be an arbitrary closure such that \texttt{ğ”¼\ v\ c}.
  Assume \texttt{w\ âŠ”\ w\textquotesingle{}} is greater than a function.
  Unfortunately, this does not mean that both \texttt{w} and
  \texttt{w\textquotesingle{}} are above functions. But thanks to the
  lemma \texttt{above-fun-âŠ”}, we know that at least one of them is
  greater than a function.

  \begin{itemize}
  \item
    Suppose both of them are greater than a function. Then we have
    \texttt{Î³\ âŠ¢\ N\ â‡“\ clos\ L\ Î´} and \texttt{ğ•\ w\ (clos\ L\ Î´)}. We
    also have \texttt{Î³\ âŠ¢\ N\ â‡“\ câ‚ƒ} and
    \texttt{ğ•\ w\textquotesingle{}\ câ‚ƒ}. Because the big-step semantics
    is deterministic, we have \texttt{câ‚ƒ\ â‰¡\ clos\ L\ Î´}. Also, from
    \texttt{ğ•\ w\ (clos\ L\ Î´)} we know that
    \texttt{L\ â‰¡\ Æ›\ N\textquotesingle{}} for some
    \texttt{N\textquotesingle{}}. We conclude that
    \texttt{ğ•\ (w\ âŠ”\ w\textquotesingle{})\ (clos\ (Æ›\ N\textquotesingle{})\ Î´)}.
  \item
    Suppose one of them is greater than a function and the other is not:
    say \texttt{above-fun\ w} and
    \texttt{Â¬\ above-fun\ w\textquotesingle{}}. Then from
    \texttt{ğ•\ (v\ â†¦\ w)\ (clos\ (Æ›\ N)\ Î³)} we have
    \texttt{Î³\ âŠ¢\ N\ â‡“\ clos\ L\ Î³â‚} and \texttt{ğ•\ w\ (clos\ L\ Î³â‚)}.
    From this we have \texttt{L\ â‰¡\ Æ›\ N\textquotesingle{}} for some
    \texttt{N\textquotesingle{}}. Meanwhile, from
    \texttt{Â¬\ above-fun\ w\textquotesingle{}} we have
    \texttt{ğ•\ w\textquotesingle{}\ (clos\ L\ Î³â‚)}. We conclude that
    \texttt{ğ•\ (w\ âŠ”\ w\textquotesingle{})\ (clos\ (Æ›\ N\textquotesingle{})\ Î³â‚)}.
  \end{itemize}
\end{itemize}

The proof of \texttt{sub-ğ”¼} is direct and explained below.

\begin{fence}
\begin{code}
sub-ğ”¼ {clos M Î³} {v} {v'} ğ”¼v v'âŠ‘v fv'
    with ğ”¼v (above-fun-âŠ‘ fv' v'âŠ‘v)
... | âŸ¨ c , âŸ¨ Mâ‡“c , ğ•v âŸ© âŸ© =
      âŸ¨ c , âŸ¨ Mâ‡“c , sub-ğ• ğ•v v'âŠ‘v âŸ© âŸ©
\end{code}
\end{fence}

From \texttt{above-fun\ v\textquotesingle{}} and
\texttt{v\textquotesingle{}\ âŠ‘\ v} we have \texttt{above-fun\ v}. Then
with \texttt{ğ”¼\ v\ c} we obtain a closure \texttt{c} such that
\texttt{Î³\ âŠ¢\ M\ â‡“\ c} and \texttt{ğ•\ v\ c}. We conclude with an
application of \texttt{sub-ğ•} with \texttt{v\textquotesingle{}\ âŠ‘\ v} to
show \texttt{ğ•\ v\textquotesingle{}\ c}.

\hypertarget{programs-with-function-denotation-terminate-via-call-by-name}{%
\section{Programs with function denotation terminate via
call-by-name}\label{programs-with-function-denotation-terminate-via-call-by-name}}

The main lemma proves that if a term has a denotation that is above a
function, then it terminates via call-by-name. More formally, if
\texttt{Î³\ âŠ¢\ M\ â†“\ v} and \texttt{ğ”¾\ Î³\ Î³\textquotesingle{}}, then
\texttt{ğ”¼\ v\ (clos\ M\ Î³\textquotesingle{})}. The proof is by induction
on the derivation of \texttt{Î³\ âŠ¢\ M\ â†“\ v} we discuss each case below.

The following lemma, kth-x, is used in the case for the \texttt{var}
rule.

\begin{fence}
\begin{code}
kth-x : âˆ€{Î“}{Î³' : ClosEnv Î“}{x : Î“ âˆ‹ â˜…}
     â†’ Î£[ Î” âˆˆ Context ] Î£[ Î´ âˆˆ ClosEnv Î” ] Î£[ M âˆˆ Î” âŠ¢ â˜… ]
                 Î³' x â‰¡ clos M Î´
kth-x{Î³' = Î³'}{x = x} with Î³' x
... | clos{Î“ = Î”} M Î´ = âŸ¨ Î” , âŸ¨ Î´ , âŸ¨ M , refl âŸ© âŸ© âŸ©
\end{code}
\end{fence}

\begin{fence}
\begin{code}
â†“â†’ğ”¼ : âˆ€{Î“}{Î³ : Env Î“}{Î³' : ClosEnv Î“}{M : Î“ âŠ¢ â˜… }{v}
            â†’ ğ”¾ Î³ Î³' â†’ Î³ âŠ¢ M â†“ v â†’ ğ”¼ v (clos M Î³')
â†“â†’ğ”¼ {Î“} {Î³} {Î³'} ğ”¾Î³Î³' (var{x = x}) fÎ³x
    with kth-x{Î“}{Î³'}{x} | ğ”¾Î³Î³'{x = x}
... | âŸ¨ Î” , âŸ¨ Î´ , âŸ¨ M' , eq âŸ© âŸ© âŸ© | ğ”¾Î³Î³'x rewrite eq
    with ğ”¾Î³Î³'x fÎ³x
... | âŸ¨ c , âŸ¨ M'â‡“c , ğ•Î³x âŸ© âŸ© =
      âŸ¨ c , âŸ¨ (â‡“-var eq M'â‡“c) , ğ•Î³x âŸ© âŸ©
â†“â†’ğ”¼ {Î“} {Î³} {Î³'} ğ”¾Î³Î³' (â†¦-elim{L = L}{M = M}{v = vâ‚}{w = v} dâ‚ dâ‚‚) fv
    with â†“â†’ğ”¼ ğ”¾Î³Î³' dâ‚ âŸ¨ vâ‚ , âŸ¨ v , âŠ‘-refl âŸ© âŸ©
... | âŸ¨ clos L' Î´ , âŸ¨ Lâ‡“L' , ğ•vâ‚â†¦v âŸ© âŸ©
    with ğ•â†’WHNF ğ•vâ‚â†¦v
... | Æ›_ {N = N}
    with ğ•vâ‚â†¦v {clos M Î³'} (â†“â†’ğ”¼ ğ”¾Î³Î³' dâ‚‚) fv
... | âŸ¨ c' , âŸ¨ Nâ‡“c' , ğ•v âŸ© âŸ© =
    âŸ¨ c' , âŸ¨ â‡“-app Lâ‡“L' Nâ‡“c' , ğ•v âŸ© âŸ©
â†“â†’ğ”¼ {Î“} {Î³} {Î³'} ğ”¾Î³Î³' (â†¦-intro{N = N}{v = v}{w = w} d) fvâ†¦w =
    âŸ¨ clos (Æ› N) Î³' , âŸ¨ â‡“-lam , E âŸ© âŸ©
    where E : {c : Clos} â†’ ğ”¼ v c â†’ above-fun w
            â†’ Î£[ c' âˆˆ Clos ] (Î³' ,' c) âŠ¢ N â‡“ c'  Ã—  ğ• w c'
          E {c} ğ”¼vc fw = â†“â†’ğ”¼ (Î» {x} â†’ ğ”¾-ext{Î“}{Î³}{Î³'} ğ”¾Î³Î³' ğ”¼vc {x}) d fw
â†“â†’ğ”¼ ğ”¾Î³Î³' âŠ¥-intro fâŠ¥ = âŠ¥-elim (above-funâŠ¥ fâŠ¥)
â†“â†’ğ”¼ ğ”¾Î³Î³' (âŠ”-intro{v = vâ‚}{w = vâ‚‚} dâ‚ dâ‚‚) fv12
    with above-fun? vâ‚ | above-fun? vâ‚‚
... | yes fv1 | yes fv2
    with â†“â†’ğ”¼ ğ”¾Î³Î³' dâ‚ fv1 | â†“â†’ğ”¼ ğ”¾Î³Î³' dâ‚‚ fv2
... | âŸ¨ câ‚ , âŸ¨ Mâ‡“câ‚ , ğ•vâ‚ âŸ© âŸ© | âŸ¨ câ‚‚ , âŸ¨ Mâ‡“câ‚‚ , ğ•vâ‚‚ âŸ© âŸ©
    rewrite â‡“-determ Mâ‡“câ‚‚ Mâ‡“câ‚ =
    âŸ¨ câ‚ , âŸ¨ Mâ‡“câ‚ , ğ•âŠ”-intro ğ•vâ‚ ğ•vâ‚‚ âŸ© âŸ©
â†“â†’ğ”¼ ğ”¾Î³Î³' (âŠ”-intro{v = vâ‚}{w = vâ‚‚} dâ‚ dâ‚‚) fv12 | yes fv1 | no nfv2
    with â†“â†’ğ”¼ ğ”¾Î³Î³' dâ‚ fv1
... | âŸ¨ clos {Î“'} M' Î³â‚ , âŸ¨ Mâ‡“câ‚ , ğ•vâ‚ âŸ© âŸ©
    with ğ•â†’WHNF ğ•vâ‚
... | Æ›_ {N = N} =
    let ğ•vâ‚‚ = not-above-fun-ğ•{vâ‚‚}{Î“'}{Î³â‚}{N} nfv2 in
    âŸ¨ clos (Æ› N) Î³â‚ , âŸ¨ Mâ‡“câ‚ , ğ•âŠ”-intro ğ•vâ‚ ğ•vâ‚‚ âŸ© âŸ©
â†“â†’ğ”¼ ğ”¾Î³Î³' (âŠ”-intro{v = vâ‚}{w = vâ‚‚} dâ‚ dâ‚‚) fv12 | no nfv1  | yes fv2
    with â†“â†’ğ”¼ ğ”¾Î³Î³' dâ‚‚ fv2
... | âŸ¨ clos {Î“'} M' Î³â‚ , âŸ¨ M'â‡“câ‚‚ , ğ•2c âŸ© âŸ©
    with ğ•â†’WHNF ğ•2c
... | Æ›_ {N = N} =
    let ğ•1c = not-above-fun-ğ•{vâ‚}{Î“'}{Î³â‚}{N} nfv1 in
    âŸ¨ clos (Æ› N) Î³â‚ , âŸ¨ M'â‡“câ‚‚ , ğ•âŠ”-intro ğ•1c ğ•2c âŸ© âŸ©
â†“â†’ğ”¼ ğ”¾Î³Î³' (âŠ”-intro dâ‚ dâ‚‚) fv12 | no nfv1  | no nfv2
    with above-fun-âŠ” fv12
... | injâ‚ fv1 = âŠ¥-elim (contradiction fv1 nfv1)
... | injâ‚‚ fv2 = âŠ¥-elim (contradiction fv2 nfv2)
â†“â†’ğ”¼ {Î“} {Î³} {Î³'} {M} {v'} ğ”¾Î³Î³' (sub{v = v} d v'âŠ‘v) fv'
    with â†“â†’ğ”¼ {Î“} {Î³} {Î³'} {M} ğ”¾Î³Î³' d (above-fun-âŠ‘ fv' v'âŠ‘v)
... | âŸ¨ c , âŸ¨ Mâ‡“c , ğ•v âŸ© âŸ© =
      âŸ¨ c , âŸ¨ Mâ‡“c , sub-ğ• ğ•v v'âŠ‘v âŸ© âŸ©
\end{code}
\end{fence}

\begin{itemize}
\item
  Case \texttt{var}. Looking up \texttt{x} in
  \texttt{Î³\textquotesingle{}} yields some closure,
  \texttt{clos\ M\textquotesingle{}\ Î´}, and from
  \texttt{ğ”¾\ Î³\ Î³\textquotesingle{}} we have
  \texttt{ğ”¼\ (Î³\ x)\ (clos\ M\textquotesingle{}\ Î´)}. With the premise
  \texttt{above-fun\ (Î³\ x)}, we obtain a closure \texttt{c} such that
  \texttt{Î´\ âŠ¢\ M\textquotesingle{}\ â‡“\ c} and \texttt{ğ•\ (Î³\ x)\ c}. To
  conclude \texttt{Î³\textquotesingle{}\ âŠ¢\ x\ â‡“\ c} via \texttt{â‡“-var},
  we need
  \texttt{Î³\textquotesingle{}\ x\ â‰¡\ clos\ M\textquotesingle{}\ Î´},
  which is obvious, but it requires some Agda shananigans via the
  \texttt{kth-x} lemma to get our hands on it.
\item
  Case \texttt{â†¦-elim}. We have \texttt{Î³\ âŠ¢\ L\ Â·\ M\ â†“\ v}. The
  induction hypothesis for \texttt{Î³\ âŠ¢\ L\ â†“\ vâ‚\ â†¦\ v} gives us
  \texttt{Î³\textquotesingle{}\ âŠ¢\ L\ â‡“\ clos\ L\textquotesingle{}\ Î´}
  and \texttt{ğ•\ v\ (clos\ L\textquotesingle{}\ Î´)}. Of course,
  \texttt{L\textquotesingle{}\ â‰¡\ Æ›\ N} for some \texttt{N}. By the
  induction hypothesis for \texttt{Î³\ âŠ¢\ M\ â†“\ vâ‚}, we have
  \texttt{ğ”¼\ vâ‚\ (clos\ M\ Î³\textquotesingle{})}. Together with the
  premise \texttt{above-fun\ v} and
  \texttt{ğ•\ v\ (clos\ L\textquotesingle{}\ Î´)}, we obtain a closure
  \texttt{c\textquotesingle{}} such that
  \texttt{Î´\ âŠ¢\ N\ â‡“\ c\textquotesingle{}} and
  \texttt{ğ•\ v\ c\textquotesingle{}}. We conclude that
  \texttt{Î³\textquotesingle{}\ âŠ¢\ L\ Â·\ M\ â‡“\ c\textquotesingle{}} by
  rule \texttt{â‡“-app}.
\item
  Case \texttt{â†¦-intro}. We have \texttt{Î³\ âŠ¢\ Æ›\ N\ â†“\ v\ â†¦\ w}. We
  immediately have
  \texttt{Î³\textquotesingle{}\ âŠ¢\ Æ›\ M\ â‡“\ clos\ (Æ›\ M)\ Î³\textquotesingle{}}
  by rule \texttt{â‡“-lam}. But we also need to prove
  \texttt{ğ•\ (v\ â†¦\ w)\ (clos\ (Æ›\ N)\ Î³\textquotesingle{})}. Let
  \texttt{c} by an arbitrary closure such that \texttt{ğ”¼\ v\ c}. Suppose
  \texttt{v\textquotesingle{}} is greater than a function value. We need
  to show that
  \texttt{Î³\textquotesingle{}\ ,\ c\ âŠ¢\ N\ â‡“\ c\textquotesingle{}} and
  \texttt{ğ•\ v\textquotesingle{}\ c\textquotesingle{}} for some
  \texttt{c\textquotesingle{}}. We prove this by the induction
  hypothesis for \texttt{Î³\ ,\ v\ âŠ¢\ N\ â†“\ v\textquotesingle{}} but we
  must first show that
  \texttt{ğ”¾\ (Î³\ ,\ v)\ (Î³\textquotesingle{}\ ,\ c)}. We prove that by
  the lemma \texttt{ğ”¾-ext}, using facts
  \texttt{ğ”¾\ Î³\ Î³\textquotesingle{}} and \texttt{ğ”¼\ v\ c}.
\item
  Case \texttt{âŠ¥-intro}. We have the premise \texttt{above-fun\ âŠ¥}, but
  that's impossible.
\item
  Case \texttt{âŠ”-intro}. We have \texttt{Î³\ âŠ¢\ M\ â†“\ (vâ‚\ âŠ”\ vâ‚‚)} and
  \texttt{above-fun\ (vâ‚\ âŠ”\ vâ‚‚)} and need to show
  \texttt{Î³\textquotesingle{}\ âŠ¢\ M\ â†“\ c} and
  \texttt{ğ•\ (vâ‚\ âŠ”\ vâ‚‚)\ c} for some \texttt{c}. Again, by
  \texttt{above-fun-âŠ”}, at least one of \texttt{vâ‚} or \texttt{vâ‚‚} is
  greater than a function.

  \begin{itemize}
  \item
    Suppose both \texttt{vâ‚} and \texttt{vâ‚‚} are greater than a function
    value. By the induction hypotheses for \texttt{Î³\ âŠ¢\ M\ â†“\ vâ‚} and
    \texttt{Î³\ âŠ¢\ M\ â†“\ vâ‚‚} we have
    \texttt{Î³\textquotesingle{}\ âŠ¢\ M\ â‡“\ câ‚}, \texttt{ğ•\ vâ‚\ câ‚},
    \texttt{Î³\textquotesingle{}\ âŠ¢\ M\ â‡“\ câ‚‚}, and \texttt{ğ•\ vâ‚‚\ câ‚‚}
    for some \texttt{câ‚} and \texttt{câ‚‚}. Because \texttt{â‡“} is
    deterministic, we have \texttt{câ‚‚\ â‰¡\ câ‚}. Then by \texttt{ğ•âŠ”-intro}
    we conclude that \texttt{ğ•\ (vâ‚\ âŠ”\ vâ‚‚)\ câ‚}.
  \item
    Without loss of generality, suppose \texttt{vâ‚} is greater than a
    function value but \texttt{vâ‚‚} is not. By the induction hypotheses
    for \texttt{Î³\ âŠ¢\ M\ â†“\ vâ‚}, and using \texttt{ğ•â†’WHNF}, we have
    \texttt{Î³\textquotesingle{}\ âŠ¢\ M\ â‡“\ clos\ (Æ›\ N)\ Î³â‚} and
    \texttt{ğ•\ vâ‚\ (clos\ (Æ›\ N)\ Î³â‚)}. Then because \texttt{vâ‚‚} is not
    greater than a function, we also have
    \texttt{ğ•\ vâ‚‚\ (clos\ (Æ›\ N)\ Î³â‚)}. We conclude that
    \texttt{ğ•\ (vâ‚\ âŠ”\ vâ‚‚)\ (clos\ (Æ›\ N)\ Î³â‚)}.
  \end{itemize}
\item
  Case \texttt{sub}. We have \texttt{Î³\ âŠ¢\ M\ â†“\ v},
  \texttt{v\textquotesingle{}\ âŠ‘\ v}, and
  \texttt{above-fun\ v\textquotesingle{}}. We need to show that
  \texttt{Î³\textquotesingle{}\ âŠ¢\ M\ â‡“\ c} and
  \texttt{ğ•\ v\textquotesingle{}\ c} for some \texttt{c}. We have
  \texttt{above-fun\ v} by \texttt{above-fun-âŠ‘}, so the induction
  hypothesis for \texttt{Î³\ âŠ¢\ M\ â†“\ v} gives us a closure \texttt{c}
  such that \texttt{Î³\textquotesingle{}\ âŠ¢\ M\ â‡“\ c} and
  \texttt{ğ•\ v\ c}. We conclude that \texttt{ğ•\ v\textquotesingle{}\ c}
  by \texttt{sub-ğ•}.
\end{itemize}

\hypertarget{proof-of-denotational-adequacy}{%
\section{Proof of denotational
adequacy}\label{proof-of-denotational-adequacy}}

From the main lemma we can directly show that
\texttt{â„°\ M\ â‰ƒ\ â„°\ (Æ›\ N)} implies that \texttt{M} big-steps to a
lambda, i.e., \texttt{âˆ…\ âŠ¢\ M\ â‡“\ clos\ (Æ›\ Nâ€²)\ Î³}.

\begin{fence}
\begin{code}
â†“â†’â‡“ : âˆ€{M : âˆ… âŠ¢ â˜…}{N : âˆ… , â˜… âŠ¢ â˜…}  â†’  â„° M â‰ƒ â„° (Æ› N)
         â†’  Î£[ Î“ âˆˆ Context ] Î£[ Nâ€² âˆˆ (Î“ , â˜… âŠ¢ â˜…) ] Î£[ Î³ âˆˆ ClosEnv Î“ ]
            âˆ…' âŠ¢ M â‡“ clos (Æ› Nâ€²) Î³
â†“â†’â‡“{M}{N} eq
    with â†“â†’ğ”¼ ğ”¾-âˆ… ((projâ‚‚ (eq `âˆ… (âŠ¥ â†¦ âŠ¥))) (â†¦-intro âŠ¥-intro))
                 âŸ¨ âŠ¥ , âŸ¨ âŠ¥ , âŠ‘-refl âŸ© âŸ©
... | âŸ¨ clos {Î“} Mâ€² Î³ , âŸ¨ Mâ‡“c , Vc âŸ© âŸ©
    with ğ•â†’WHNF Vc
... | Æ›_ {N = Nâ€²} =
    âŸ¨ Î“ , âŸ¨ Nâ€² , âŸ¨ Î³ , Mâ‡“c âŸ©  âŸ© âŸ©
\end{code}
\end{fence}

The proof goes as follows. We derive \texttt{âˆ…\ âŠ¢\ Æ›\ N\ â†“\ âŠ¥\ â†¦\ âŠ¥} and
then \texttt{â„°\ M\ â‰ƒ\ â„°\ (Æ›\ N)} gives us \texttt{âˆ…\ âŠ¢\ M\ â†“\ âŠ¥\ â†¦\ âŠ¥}.
We conclude by applying the main lemma to obtain
\texttt{âˆ…\ âŠ¢\ M\ â‡“\ clos\ (Æ›\ Nâ€²)\ Î³} for some \texttt{Nâ€²} and
\texttt{Î³}.

Now to prove the adequacy property. We apply the above lemma to obtain
\texttt{âˆ…\ âŠ¢\ M\ â‡“\ clos\ (Æ›\ Nâ€²)\ Î³} and then apply \texttt{cbnâ†’reduce}
to conclude.

\begin{fence}
\begin{code}
adequacy : âˆ€{M : âˆ… âŠ¢ â˜…}{N : âˆ… , â˜… âŠ¢ â˜…}
   â†’  â„° M â‰ƒ â„° (Æ› N)
   â†’ Î£[ Nâ€² âˆˆ (âˆ… , â˜… âŠ¢ â˜…) ]
     (M â€”â†  Æ› Nâ€²)
adequacy{M}{N} eq
    with â†“â†’â‡“ eq
... | âŸ¨ Î“ , âŸ¨ Nâ€² , âŸ¨ Î³ , Mâ‡“ âŸ© âŸ© âŸ© =
    cbnâ†’reduce Mâ‡“
\end{code}
\end{fence}

\hypertarget{call-by-name-is-equivalent-to-beta-reduction}{%
\section{Call-by-name is equivalent to beta
reduction}\label{call-by-name-is-equivalent-to-beta-reduction}}

As promised, we return to the question of whether call-by-name
evaluation is equivalent to beta reduction. In chapter
\protect\hyperlink{BigStep}{BigStep} we established the forward
direction: that if call-by-name produces a result, then the program beta
reduces to a lambda abstraction (\texttt{cbnâ†’reduce}). We now prove the
backward direction of the if-and-only-if, leveraging our results about
the denotational semantics.

\begin{fence}
\begin{code}
reduceâ†’cbn : âˆ€ {M : âˆ… âŠ¢ â˜…} {N : âˆ… , â˜… âŠ¢ â˜…}
           â†’ M â€”â†  Æ› N
           â†’ Î£[ Î” âˆˆ Context ] Î£[ Nâ€² âˆˆ Î” , â˜… âŠ¢ â˜… ] Î£[ Î´ âˆˆ ClosEnv Î” ]
             âˆ…' âŠ¢ M â‡“ clos (Æ› Nâ€²) Î´
reduceâ†’cbn Mâ€”â† Æ›N = â†“â†’â‡“ (soundness Mâ€”â† Æ›N)
\end{code}
\end{fence}

Suppose \texttt{M\ â€”â† \ Æ›\ N}. Soundness of the denotational semantics
gives us \texttt{â„°\ M\ â‰ƒ\ â„°\ (Æ›\ N)}. Then by \texttt{â†“â†’â‡“} we conclude
that \texttt{âˆ…\textquotesingle{}\ âŠ¢\ M\ â‡“\ clos\ (Æ›\ Nâ€²)\ Î´} for some
\texttt{Nâ€²} and \texttt{Î´}.

Putting the two directions of the if-and-only-if together, we establish
that call-by-name evaluation is equivalent to beta reduction in the
following sense.

\begin{fence}
\begin{code}
cbnâ†”reduce : âˆ€ {M : âˆ… âŠ¢ â˜…}
           â†’ (Î£[ N âˆˆ âˆ… , â˜… âŠ¢ â˜… ] (M â€”â†  Æ› N))
             iff
             (Î£[ Î” âˆˆ Context ] Î£[ Nâ€² âˆˆ Î” , â˜… âŠ¢ â˜… ] Î£[ Î´ âˆˆ ClosEnv Î” ]
               âˆ…' âŠ¢ M â‡“ clos (Æ› Nâ€²) Î´)
cbnâ†”reduce {M} = âŸ¨ (Î» x â†’ reduceâ†’cbn (projâ‚‚ x)) ,
                   (Î» x â†’ cbnâ†’reduce (projâ‚‚ (projâ‚‚ (projâ‚‚ x)))) âŸ©
\end{code}
\end{fence}

\hypertarget{unicode}{%
\section{Unicode}\label{unicode}}

This chapter uses the following unicode:

\begin{myDisplay}
ğ”¼  U+1D53C  MATHEMATICAL DOUBLE-STRUCK CAPITAL E (\bE)
ğ”¾  U+1D53E  MATHEMATICAL DOUBLE-STRUCK CAPITAL G (\bG)
ğ•  U+1D53E  MATHEMATICAL DOUBLE-STRUCK CAPITAL V (\bV)
\end{myDisplay}

