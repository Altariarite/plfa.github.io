\hypertarget{ContextualEquivalence}{%
\chapter{ContextualEquivalence: Denotational equality implies contextual
equivalence}\label{ContextualEquivalence}}

\begin{fence}
\begin{code}
module plfa.part3.ContextualEquivalence where
\end{code}
\end{fence}

\hypertarget{imports}{%
\section{Imports}\label{imports}}

\begin{fence}
\begin{code}
open import Data.Product using (_×_; Σ; Σ-syntax; ∃; ∃-syntax; proj₁; proj₂)
     renaming (_,_ to ⟨_,_⟩)
open import plfa.part2.Untyped using (_⊢_; ★; ∅; _,_; ƛ_; _—↠_)
open import plfa.part2.BigStep using (_⊢_⇓_; cbn→reduce)
open import plfa.part3.Denotational using (ℰ; _≃_; ≃-sym; ≃-trans; _iff_)
open import plfa.part3.Compositional using (Ctx; plug; compositionality)
open import plfa.part3.Soundness using (soundness)
open import plfa.part3.Adequacy using (↓→⇓)
\end{code}
\end{fence}

\hypertarget{contextual-equivalence}{%
\section{Contextual Equivalence}\label{contextual-equivalence}}

The notion of \emph{contextual equivalence} is an important one for
programming languages because it is the sufficient condition for
changing a subterm of a program while maintaining the program's overall
behavior. Two terms \texttt{M} and \texttt{N} are contextually
equivalent if they can plugged into any context \texttt{C} and produce
equivalent results. As discuss in the Denotational chapter, the result
of a program in the lambda calculus is to terminate or not. We
characterize termination with the reduction semantics as follows.

\begin{fence}
\begin{code}
terminates : ∀{Γ} → (M : Γ ⊢ ★) → Set
terminates {Γ} M = Σ[ N ∈ (Γ , ★ ⊢ ★) ] (M —↠ ƛ N)
\end{code}
\end{fence}

So two terms are contextually equivalent if plugging them into the same
context produces two programs that either terminate or diverge together.

\begin{fence}
\begin{code}
_≅_ : ∀{Γ} → (M N : Γ ⊢ ★) → Set
(_≅_ {Γ} M N) = ∀ {C : Ctx Γ ∅}
                → (terminates (plug C M)) iff (terminates (plug C N))
\end{code}
\end{fence}

The contextual equivalence of two terms is difficult to prove directly
based on the above definition because of the universal quantification of
the context \texttt{C}. One of the main motivations for developing
denotational semantics is to have an alternative way to prove contextual
equivalence that instead only requires reasoning about the two terms.

\hypertarget{denotational-equivalence-implies-contextual-equivalence}{%
\section{Denotational equivalence implies contextual
equivalence}\label{denotational-equivalence-implies-contextual-equivalence}}

Thankfully, the proof that denotational equality implies contextual
equivalence is an easy corollary of the results that we have already
established. Furthermore, the two directions of the if-and-only-if are
symmetric, so we can prove one lemma and then use it twice in the
theorem.

The lemma states that if \texttt{M} and \texttt{N} are denotationally
equal and if \texttt{M} plugged into \texttt{C} terminates, then so does
\texttt{N} plugged into \texttt{C}.

\begin{fence}
\begin{code}
denot-equal-terminates : ∀{Γ} {M N : Γ ⊢ ★} {C : Ctx Γ ∅}
  → ℰ M ≃ ℰ N  →  terminates (plug C M)
    -----------------------------------
  → terminates (plug C N)
denot-equal-terminates {Γ}{M}{N}{C} ℰM≃ℰN ⟨ N′ , CM—↠ƛN′ ⟩ =
  let ℰCM≃ℰƛN′ = soundness CM—↠ƛN′ in
  let ℰCM≃ℰCN = compositionality{Γ = Γ}{Δ = ∅}{C = C} ℰM≃ℰN in
  let ℰCN≃ℰƛN′ = ≃-trans (≃-sym ℰCM≃ℰCN) ℰCM≃ℰƛN′ in
    cbn→reduce (proj₂ (proj₂ (proj₂ (↓→⇓ ℰCN≃ℰƛN′))))
\end{code}
\end{fence}

The proof is direct. Because \texttt{plug\ C\ —↠\ plug\ C\ (ƛN′)}, we
can apply soundness to obtain

\begin{myDisplay}
ℰ (plug C M) ≃ ℰ (ƛN′)
\end{myDisplay}

From \texttt{ℰ\ M\ ≃\ ℰ\ N}, compositionality gives us

\begin{myDisplay}
ℰ (plug C M) ≃ ℰ (plug C N).
\end{myDisplay}

Putting these two facts together gives us

\begin{myDisplay}
ℰ (plug C N) ≃ ℰ (ƛN′).
\end{myDisplay}

We then apply \texttt{↓→⇓} from Chapter
\protect\hyperlink{Adequacy}{Adequacy} to deduce

\begin{myDisplay}
∅' ⊢ plug C N ⇓ clos (ƛ N′′) δ).
\end{myDisplay}

Call-by-name evaluation implies reduction to a lambda abstraction, so we
conclude that

\begin{myDisplay}
terminates (plug C N).
\end{myDisplay}

The main theorem follows by two applications of the lemma.

\begin{fence}
\begin{code}
denot-equal-contex-equal : ∀{Γ} {M N : Γ ⊢ ★}
  → ℰ M ≃ ℰ N
    ---------
  → M ≅ N
denot-equal-contex-equal{Γ}{M}{N} eq {C} =
   ⟨ (λ tm → denot-equal-terminates eq tm) ,
     (λ tn → denot-equal-terminates (≃-sym eq) tn) ⟩
\end{code}
\end{fence}

\hypertarget{unicode}{%
\section{Unicode}\label{unicode}}

This chapter uses the following unicode:

\begin{myDisplay}
≅  U+2245  APPROXIMATELY EQUAL TO (\~= or \cong)
\end{myDisplay}

