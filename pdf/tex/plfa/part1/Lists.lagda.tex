\hypertarget{Lists}{%
\chapter{Lists: Lists and higher-order functions}\label{Lists}}

\begin{fence}
\begin{code}
module plfa.part1.Lists where
\end{code}
\end{fence}

This chapter discusses the list data type. It gives further examples of
many of the techniques we have developed so far, and provides examples
of polymorphic types and higher-order functions.

\hypertarget{imports}{%
\section{Imports}\label{imports}}

\begin{fence}
\begin{code}
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl; sym; trans; cong)
open Eq.≡-Reasoning
open import Data.Bool using (Bool; true; false; T; _∧_; _∨_; not)
open import Data.Nat using (ℕ; zero; suc; _+_; _*_; _∸_; _≤_; s≤s; z≤n)
open import Data.Nat.Properties using
  (+-assoc; +-identityˡ; +-identityʳ; *-assoc; *-identityˡ; *-identityʳ)
open import Relation.Nullary using (¬_; Dec; yes; no)
open import Data.Product using (_×_; ∃; ∃-syntax) renaming (_,_ to ⟨_,_⟩)
open import Function using (_∘_)
open import Level using (Level)
open import plfa.part1.Isomorphism using (_≃_; _⇔_)
\end{code}
\end{fence}

\hypertarget{lists}{%
\section{Lists}\label{lists}}

Lists are defined in Agda as follows:

\begin{fence}
\begin{code}
data List (A : Set) : Set where
  []  : List A
  _∷_ : A → List A → List A

infixr 5 _∷_
\end{code}
\end{fence}

Let's unpack this definition. If \texttt{A} is a set, then
\texttt{List\ A} is a set. The next two lines tell us that
\texttt{{[}{]}} (pronounced \emph{nil}) is a list of type \texttt{A}
(often called the \emph{empty} list), and that \texttt{\_∷\_}
(pronounced \emph{cons}, short for \emph{constructor}) takes a value of
type \texttt{A} and a value of type \texttt{List\ A} and returns a value
of type \texttt{List\ A}. Operator \texttt{\_∷\_} has precedence level 5
and associates to the right.

For example,

\begin{fence}
\begin{code}
_ : List ℕ
_ = 0 ∷ 1 ∷ 2 ∷ []
\end{code}
\end{fence}

denotes the list of the first three natural numbers. Since
\texttt{\_∷\_} associates to the right, the term parses as
\texttt{0\ ∷\ (1\ ∷\ (2\ ∷\ {[}{]}))}. Here \texttt{0} is the first
element of the list, called the \emph{head}, and
\texttt{1\ ∷\ (2\ ∷\ {[}{]})} is a list of the remaining elements,
called the \emph{tail}. A list is a strange beast: it has a head and a
tail, nothing in between, and the tail is itself another list!

As we've seen, parameterised types can be translated to indexed types.
The definition above is equivalent to the following:

\begin{fence}
\begin{code}
data List′ : Set → Set where
  []′  : ∀ {A : Set} → List′ A
  _∷′_ : ∀ {A : Set} → A → List′ A → List′ A
\end{code}
\end{fence}

Each constructor takes the parameter as an implicit argument. Thus, our
example list could also be written:

\begin{fence}
\begin{code}
_ : List ℕ
_ = _∷_ {ℕ} 0 (_∷_ {ℕ} 1 (_∷_ {ℕ} 2 ([] {ℕ})))
\end{code}
\end{fence}

where here we have provided the implicit parameters explicitly.

Including the pragma:

\begin{myDisplay}
{-# BUILTIN LIST List #-}
\end{myDisplay}

tells Agda that the type \texttt{List} corresponds to the Haskell type
list, and the constructors \texttt{{[}{]}} and \texttt{\_∷\_} correspond
to nil and cons respectively, allowing a more efficient representation
of lists.

\hypertarget{list-syntax}{%
\section{List syntax}\label{list-syntax}}

We can write lists more conveniently by introducing the following
definitions:

\begin{fence}
\begin{code}
pattern [_] z = z ∷ []
pattern [_,_] y z = y ∷ z ∷ []
pattern [_,_,_] x y z = x ∷ y ∷ z ∷ []
pattern [_,_,_,_] w x y z = w ∷ x ∷ y ∷ z ∷ []
pattern [_,_,_,_,_] v w x y z = v ∷ w ∷ x ∷ y ∷ z ∷ []
pattern [_,_,_,_,_,_] u v w x y z = u ∷ v ∷ w ∷ x ∷ y ∷ z ∷ []
\end{code}
\end{fence}

This is our first use of pattern declarations. For instance, the third
line tells us that \texttt{{[}\ x\ ,\ y\ ,\ z\ {]}} is equivalent to
\texttt{x\ ∷\ y\ ∷\ z\ ∷\ {[}{]}}, and permits the former to appear
either in a pattern on the left-hand side of an equation, or a term on
the right-hand side of an equation.

\hypertarget{append}{%
\section{Append}\label{append}}

Our first function on lists is written \texttt{\_++\_} and pronounced
\emph{append}:

\begin{fence}
\begin{code}
infixr 5 _++_

_++_ : ∀ {A : Set} → List A → List A → List A
[]       ++ ys  =  ys
(x ∷ xs) ++ ys  =  x ∷ (xs ++ ys)
\end{code}
\end{fence}

The type \texttt{A} is an implicit argument to append, making it a
\emph{polymorphic} function (one that can be used at many types). A list
appended to the empty list yields the list itself. A list appended to a
non-empty list yields a list with the head the same as the head of the
non-empty list, and a tail the same as the other list appended to tail
of the non-empty list.

Here is an example, showing how to compute the result of appending two
lists:

\begin{fence}
\begin{code}
_ : [ 0 , 1 , 2 ] ++ [ 3 , 4 ] ≡ [ 0 , 1 , 2 , 3 , 4 ]
_ =
  begin
    0 ∷ 1 ∷ 2 ∷ [] ++ 3 ∷ 4 ∷ []
  ≡⟨⟩
    0 ∷ (1 ∷ 2 ∷ [] ++ 3 ∷ 4 ∷ [])
  ≡⟨⟩
    0 ∷ 1 ∷ (2 ∷ [] ++ 3 ∷ 4 ∷ [])
  ≡⟨⟩
    0 ∷ 1 ∷ 2 ∷ ([] ++ 3 ∷ 4 ∷ [])
  ≡⟨⟩
    0 ∷ 1 ∷ 2 ∷ 3 ∷ 4 ∷ []
  ∎
\end{code}
\end{fence}

Appending two lists requires time linear in the number of elements in
the first list.

\hypertarget{reasoning-about-append}{%
\section{Reasoning about append}\label{reasoning-about-append}}

We can reason about lists in much the same way that we reason about
numbers. Here is the proof that append is associative:

\begin{fence}
\begin{code}
++-assoc : ∀ {A : Set} (xs ys zs : List A)
  → (xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)
++-assoc [] ys zs =
  begin
    ([] ++ ys) ++ zs
  ≡⟨⟩
    ys ++ zs
  ≡⟨⟩
    [] ++ (ys ++ zs)
  ∎
++-assoc (x ∷ xs) ys zs =
  begin
    (x ∷ xs ++ ys) ++ zs
  ≡⟨⟩
    x ∷ (xs ++ ys) ++ zs
  ≡⟨⟩
    x ∷ ((xs ++ ys) ++ zs)
  ≡⟨ cong (x ∷_) (++-assoc xs ys zs) ⟩
    x ∷ (xs ++ (ys ++ zs))
  ≡⟨⟩
    x ∷ xs ++ (ys ++ zs)
  ∎
\end{code}
\end{fence}

The proof is by induction on the first argument. The base case
instantiates to \texttt{{[}{]}}, and follows by straightforward
computation. The inductive case instantiates to \texttt{x\ ∷\ xs}, and
follows by straightforward computation combined with the inductive
hypothesis. As usual, the inductive hypothesis is indicated by a
recursive invocation of the proof, in this case
\texttt{++-assoc\ xs\ ys\ zs}.

Recall that Agda supports
\protect\hyperlink{Induction-sections}{sections}. Applying
\texttt{cong\ (x\ ∷\_)} promotes the inductive hypothesis:

\begin{myDisplay}
(xs ++ ys) ++ zs ≡ xs ++ (ys ++ zs)
\end{myDisplay}

to the equality:

\begin{myDisplay}
x ∷ ((xs ++ ys) ++ zs) ≡ x ∷ (xs ++ (ys ++ zs))
\end{myDisplay}

which is needed in the proof.

It is also easy to show that \texttt{{[}{]}} is a left and right
identity for \texttt{\_++\_}. That it is a left identity is immediate
from the definition:

\begin{fence}
\begin{code}
++-identityˡ : ∀ {A : Set} (xs : List A) → [] ++ xs ≡ xs
++-identityˡ xs =
  begin
    [] ++ xs
  ≡⟨⟩
    xs
  ∎
\end{code}
\end{fence}

That it is a right identity follows by simple induction:

\begin{fence}
\begin{code}
++-identityʳ : ∀ {A : Set} (xs : List A) → xs ++ [] ≡ xs
++-identityʳ [] =
  begin
    [] ++ []
  ≡⟨⟩
    []
  ∎
++-identityʳ (x ∷ xs) =
  begin
    (x ∷ xs) ++ []
  ≡⟨⟩
    x ∷ (xs ++ [])
  ≡⟨ cong (x ∷_) (++-identityʳ xs) ⟩
    x ∷ xs
  ∎
\end{code}
\end{fence}

As we will see later, these three properties establish that
\texttt{\_++\_} and \texttt{{[}{]}} form a \emph{monoid} over lists.

\hypertarget{length}{%
\section{Length}\label{length}}

Our next function finds the length of a list:

\begin{fence}
\begin{code}
length : ∀ {A : Set} → List A → ℕ
length []        =  zero
length (x ∷ xs)  =  suc (length xs)
\end{code}
\end{fence}

Again, it takes an implicit parameter \texttt{A}. The length of the
empty list is zero. The length of a non-empty list is one greater than
the length of the tail of the list.

Here is an example showing how to compute the length of a list:

\begin{fence}
\begin{code}
_ : length [ 0 , 1 , 2 ] ≡ 3
_ =
  begin
    length (0 ∷ 1 ∷ 2 ∷ [])
  ≡⟨⟩
    suc (length (1 ∷ 2 ∷ []))
  ≡⟨⟩
    suc (suc (length (2 ∷ [])))
  ≡⟨⟩
    suc (suc (suc (length {ℕ} [])))
  ≡⟨⟩
    suc (suc (suc zero))
  ∎
\end{code}
\end{fence}

Computing the length of a list requires time linear in the number of
elements in the list.

In the second-to-last line, we cannot write simply
\texttt{length\ {[}{]}} but must instead write
\texttt{length\ \{ℕ\}\ {[}{]}}. Since \texttt{{[}{]}} has no elements,
Agda has insufficient information to infer the implicit parameter.

\hypertarget{reasoning-about-length}{%
\section{Reasoning about length}\label{reasoning-about-length}}

The length of one list appended to another is the sum of the lengths of
the lists:

\begin{fence}
\begin{code}
length-++ : ∀ {A : Set} (xs ys : List A)
  → length (xs ++ ys) ≡ length xs + length ys
length-++ {A} [] ys =
  begin
    length ([] ++ ys)
  ≡⟨⟩
    length ys
  ≡⟨⟩
    length {A} [] + length ys
  ∎
length-++ (x ∷ xs) ys =
  begin
    length ((x ∷ xs) ++ ys)
  ≡⟨⟩
    suc (length (xs ++ ys))
  ≡⟨ cong suc (length-++ xs ys) ⟩
    suc (length xs + length ys)
  ≡⟨⟩
    length (x ∷ xs) + length ys
  ∎
\end{code}
\end{fence}

The proof is by induction on the first argument. The base case
instantiates to \texttt{{[}{]}}, and follows by straightforward
computation. As before, Agda cannot infer the implicit type parameter to
\texttt{length}, and it must be given explicitly. The inductive case
instantiates to \texttt{x\ ∷\ xs}, and follows by straightforward
computation combined with the inductive hypothesis. As usual, the
inductive hypothesis is indicated by a recursive invocation of the
proof, in this case \texttt{length-++\ xs\ ys}, and it is promoted by
the congruence \texttt{cong\ suc}.

\hypertarget{reverse}{%
\section{Reverse}\label{reverse}}

Using append, it is easy to formulate a function to reverse a list:

\begin{fence}
\begin{code}
reverse : ∀ {A : Set} → List A → List A
reverse []        =  []
reverse (x ∷ xs)  =  reverse xs ++ [ x ]
\end{code}
\end{fence}

The reverse of the empty list is the empty list. The reverse of a
non-empty list is the reverse of its tail appended to a unit list
containing its head.

Here is an example showing how to reverse a list:

\begin{fence}
\begin{code}
_ : reverse [ 0 , 1 , 2 ] ≡ [ 2 , 1 , 0 ]
_ =
  begin
    reverse (0 ∷ 1 ∷ 2 ∷ [])
  ≡⟨⟩
    reverse (1 ∷ 2 ∷ []) ++ [ 0 ]
  ≡⟨⟩
    (reverse (2 ∷ []) ++ [ 1 ]) ++ [ 0 ]
  ≡⟨⟩
    ((reverse [] ++ [ 2 ]) ++ [ 1 ]) ++ [ 0 ]
  ≡⟨⟩
    (([] ++ [ 2 ]) ++ [ 1 ]) ++ [ 0 ]
  ≡⟨⟩
    (([] ++ 2 ∷ []) ++ 1 ∷ []) ++ 0 ∷ []
  ≡⟨⟩
    (2 ∷ [] ++ 1 ∷ []) ++ 0 ∷ []
  ≡⟨⟩
    2 ∷ ([] ++ 1 ∷ []) ++ 0 ∷ []
  ≡⟨⟩
    (2 ∷ 1 ∷ []) ++ 0 ∷ []
  ≡⟨⟩
    2 ∷ (1 ∷ [] ++ 0 ∷ [])
  ≡⟨⟩
    2 ∷ 1 ∷ ([] ++ 0 ∷ [])
  ≡⟨⟩
    2 ∷ 1 ∷ 0 ∷ []
  ≡⟨⟩
    [ 2 , 1 , 0 ]
  ∎
\end{code}
\end{fence}

Reversing a list in this way takes time \emph{quadratic} in the length
of the list. This is because reverse ends up appending lists of lengths
\texttt{1}, \texttt{2}, up to \texttt{n\ -\ 1}, where \texttt{n} is the
length of the list being reversed, append takes time linear in the
length of the first list, and the sum of the numbers up to
\texttt{n\ -\ 1} is \texttt{n\ *\ (n\ -\ 1)\ /\ 2}. (We will validate
that last fact in an exercise later in this chapter.)

\hypertarget{exercise-reverse--distrib-recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{reverse-++-distrib}
(recommended)}{Exercise reverse-++-distrib (recommended)}}\label{exercise-reverse--distrib-recommended}}

Show that the reverse of one list appended to another is the reverse of
the second appended to the reverse of the first:

\begin{myDisplay}
reverse (xs ++ ys) ≡ reverse ys ++ reverse xs
\end{myDisplay}

\hypertarget{exercise-reverse-involutive-recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{reverse-involutive}
(recommended)}{Exercise reverse-involutive (recommended)}}\label{exercise-reverse-involutive-recommended}}

A function is an \emph{involution} if when applied twice it acts as the
identity function. Show that reverse is an involution:

\begin{myDisplay}
reverse (reverse xs) ≡ xs
\end{myDisplay}

\hypertarget{faster-reverse}{%
\section{Faster reverse}\label{faster-reverse}}

The definition above, while easy to reason about, is less efficient than
one might expect since it takes time quadratic in the length of the
list. The idea is that we generalise reverse to take an additional
argument:

\begin{fence}
\begin{code}
shunt : ∀ {A : Set} → List A → List A → List A
shunt []       ys  =  ys
shunt (x ∷ xs) ys  =  shunt xs (x ∷ ys)
\end{code}
\end{fence}

The definition is by recursion on the first argument. The second
argument actually becomes \emph{larger}, but this is not a problem
because the argument on which we recurse becomes \emph{smaller}.

Shunt is related to reverse as follows:

\begin{fence}
\begin{code}
shunt-reverse : ∀ {A : Set} (xs ys : List A)
  → shunt xs ys ≡ reverse xs ++ ys
shunt-reverse [] ys =
  begin
    shunt [] ys
  ≡⟨⟩
    ys
  ≡⟨⟩
    reverse [] ++ ys
  ∎
shunt-reverse (x ∷ xs) ys =
  begin
    shunt (x ∷ xs) ys
  ≡⟨⟩
    shunt xs (x ∷ ys)
  ≡⟨ shunt-reverse xs (x ∷ ys) ⟩
    reverse xs ++ (x ∷ ys)
  ≡⟨⟩
    reverse xs ++ ([ x ] ++ ys)
  ≡⟨ sym (++-assoc (reverse xs) [ x ] ys) ⟩
    (reverse xs ++ [ x ]) ++ ys
  ≡⟨⟩
    reverse (x ∷ xs) ++ ys
  ∎
\end{code}
\end{fence}

The proof is by induction on the first argument. The base case
instantiates to \texttt{{[}{]}}, and follows by straightforward
computation. The inductive case instantiates to \texttt{x\ ∷\ xs} and
follows by the inductive hypothesis and associativity of append. When we
invoke the inductive hypothesis, the second argument actually becomes
\emph{larger}, but this is not a problem because the argument on which
we induct becomes \emph{smaller}.

Generalising on an auxiliary argument, which becomes larger as the
argument on which we recurse or induct becomes smaller, is a common
trick. It belongs in your quiver of arrows, ready to slay the right
problem.

Having defined shunt be generalisation, it is now easy to respecialise
to give a more efficient definition of reverse:

\begin{fence}
\begin{code}
reverse′ : ∀ {A : Set} → List A → List A
reverse′ xs = shunt xs []
\end{code}
\end{fence}

Given our previous lemma, it is straightforward to show the two
definitions equivalent:

\begin{fence}
\begin{code}
reverses : ∀ {A : Set} (xs : List A)
  → reverse′ xs ≡ reverse xs
reverses xs =
  begin
    reverse′ xs
  ≡⟨⟩
    shunt xs []
  ≡⟨ shunt-reverse xs [] ⟩
    reverse xs ++ []
  ≡⟨ ++-identityʳ (reverse xs) ⟩
    reverse xs
  ∎
\end{code}
\end{fence}

Here is an example showing fast reverse of the list
\texttt{{[}\ 0\ ,\ 1\ ,\ 2\ {]}}:

\begin{fence}
\begin{code}
_ : reverse′ [ 0 , 1 , 2 ] ≡ [ 2 , 1 , 0 ]
_ =
  begin
    reverse′ (0 ∷ 1 ∷ 2 ∷ [])
  ≡⟨⟩
    shunt (0 ∷ 1 ∷ 2 ∷ []) []
  ≡⟨⟩
    shunt (1 ∷ 2 ∷ []) (0 ∷ [])
  ≡⟨⟩
    shunt (2 ∷ []) (1 ∷ 0 ∷ [])
  ≡⟨⟩
    shunt [] (2 ∷ 1 ∷ 0 ∷ [])
  ≡⟨⟩
    2 ∷ 1 ∷ 0 ∷ []
  ∎
\end{code}
\end{fence}

Now the time to reverse a list is linear in the length of the list.

\hypertarget{Lists-Map}{%
\section{Map}\label{Lists-Map}}

Map applies a function to every element of a list to generate a
corresponding list. Map is an example of a \emph{higher-order function},
one which takes a function as an argument or returns a function as a
result:

\begin{fence}
\begin{code}
map : ∀ {A B : Set} → (A → B) → List A → List B
map f []        =  []
map f (x ∷ xs)  =  f x ∷ map f xs
\end{code}
\end{fence}

Map of the empty list is the empty list. Map of a non-empty list yields
a list with head the same as the function applied to the head of the
given list, and tail the same as map of the function applied to the tail
of the given list.

Here is an example showing how to use map to increment every element of
a list:

\begin{fence}
\begin{code}
_ : map suc [ 0 , 1 , 2 ] ≡ [ 1 , 2 , 3 ]
_ =
  begin
    map suc (0 ∷ 1 ∷ 2 ∷ [])
  ≡⟨⟩
    suc 0 ∷ map suc (1 ∷ 2 ∷ [])
  ≡⟨⟩
    suc 0 ∷ suc 1 ∷ map suc (2 ∷ [])
  ≡⟨⟩
    suc 0 ∷ suc 1 ∷ suc 2 ∷ map suc []
  ≡⟨⟩
    suc 0 ∷ suc 1 ∷ suc 2 ∷ []
  ≡⟨⟩
    1 ∷ 2 ∷ 3 ∷ []
  ∎
\end{code}
\end{fence}

Map requires time linear in the length of the list.

It is often convenient to exploit currying by applying map to a function
to yield a new function, and at a later point applying the resulting
function:

\begin{fence}
\begin{code}
sucs : List ℕ → List ℕ
sucs = map suc

_ : sucs [ 0 , 1 , 2 ] ≡ [ 1 , 2 , 3 ]
_ =
  begin
    sucs [ 0 , 1 , 2 ]
  ≡⟨⟩
    map suc [ 0 , 1 , 2 ]
  ≡⟨⟩
    [ 1 , 2 , 3 ]
  ∎
\end{code}
\end{fence}

Any type that is parameterised on another type, such as lists, has a
corresponding map, which accepts a function and returns a function from
the type parameterised on the domain of the function to the type
parameterised on the range of the function. Further, a type that is
parameterised on \emph{n} types will have a map that is parameterised on
\emph{n} functions.

\hypertarget{exercise-map-compose-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{map-compose}
(practice)}{Exercise map-compose (practice)}}\label{exercise-map-compose-practice}}

Prove that the map of a composition is equal to the composition of two
maps:

\begin{myDisplay}
map (g ∘ f) ≡ map g ∘ map f
\end{myDisplay}

The last step of the proof requires extensionality.

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{exercise-map--distribute-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{map-++-distribute}
(practice)}{Exercise map-++-distribute (practice)}}\label{exercise-map--distribute-practice}}

Prove the following relationship between map and append:

\begin{myDisplay}
map f (xs ++ ys) ≡ map f xs ++ map f ys
\end{myDisplay}

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{exercise-map-tree-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{map-Tree}
(practice)}{Exercise map-Tree (practice)}}\label{exercise-map-tree-practice}}

Define a type of trees with leaves of type \texttt{A} and internal nodes
of type \texttt{B}:

\begin{fence}
\begin{code}
data Tree (A B : Set) : Set where
  leaf : A → Tree A B
  node : Tree A B → B → Tree A B → Tree A B
\end{code}
\end{fence}

Define a suitable map operator over trees:

\begin{myDisplay}
map-Tree : ∀ {A B C D : Set} → (A → C) → (B → D) → Tree A B → Tree C D
\end{myDisplay}

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{Lists-Fold}{%
\section{Fold}\label{Lists-Fold}}

Fold takes an operator and a value, and uses the operator to combine
each of the elements of the list, taking the given value as the result
for the empty list:

\begin{fence}
\begin{code}
foldr : ∀ {A B : Set} → (A → B → B) → B → List A → B
foldr _⊗_ e []        =  e
foldr _⊗_ e (x ∷ xs)  =  x ⊗ foldr _⊗_ e xs
\end{code}
\end{fence}

Fold of the empty list is the given value. Fold of a non-empty list uses
the operator to combine the head of the list and the fold of the tail of
the list.

Here is an example showing how to use fold to find the sum of a list:

\begin{fence}
\begin{code}
_ : foldr _+_ 0 [ 1 , 2 , 3 , 4 ] ≡ 10
_ =
  begin
    foldr _+_ 0 (1 ∷ 2 ∷ 3 ∷ 4 ∷ [])
  ≡⟨⟩
    1 + foldr _+_ 0 (2 ∷ 3 ∷ 4 ∷ [])
  ≡⟨⟩
    1 + (2 + foldr _+_ 0 (3 ∷ 4 ∷ []))
  ≡⟨⟩
    1 + (2 + (3 + foldr _+_ 0 (4 ∷ [])))
  ≡⟨⟩
    1 + (2 + (3 + (4 + foldr _+_ 0 [])))
  ≡⟨⟩
    1 + (2 + (3 + (4 + 0)))
  ∎
\end{code}
\end{fence}

Here we have an instance of \texttt{foldr} where \texttt{A} and
\texttt{B} are both \texttt{ℕ}. Fold requires time linear in the length
of the list.

It is often convenient to exploit currying by applying fold to an
operator and a value to yield a new function, and at a later point
applying the resulting function:

\begin{fence}
\begin{code}
sum : List ℕ → ℕ
sum = foldr _+_ 0

_ : sum [ 1 , 2 , 3 , 4 ] ≡ 10
_ =
  begin
    sum [ 1 , 2 , 3 , 4 ]
  ≡⟨⟩
    foldr _+_ 0 [ 1 , 2 , 3 , 4 ]
  ≡⟨⟩
    10
  ∎
\end{code}
\end{fence}

Just as the list type has two constructors, \texttt{{[}{]}} and
\texttt{\_∷\_}, so the fold function takes two arguments, \texttt{e} and
\texttt{\_⊗\_} (in addition to the list argument). In general, a data
type with \emph{n} constructors will have a corresponding fold function
that takes \emph{n} arguments.

As another example, observe that

\begin{myDisplay}
foldr _∷_ [] xs ≡ xs
\end{myDisplay}

Here, if \texttt{xs} is of type \texttt{List\ A}, then we see we have an
instance of \texttt{foldr} where \texttt{A} is \texttt{A} and \texttt{B}
is \texttt{List\ A}. It follows that

\begin{myDisplay}
xs ++ ys ≡ foldr _∷_ ys xs
\end{myDisplay}

Demonstrating both these equations is left as an exercise.

\hypertarget{exercise-product-recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{product}
(recommended)}{Exercise product (recommended)}}\label{exercise-product-recommended}}

Use fold to define a function to find the product of a list of numbers.
For example:

\begin{myDisplay}
product [ 1 , 2 , 3 , 4 ] ≡ 24
\end{myDisplay}

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{exercise-foldr--recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{foldr-++}
(recommended)}{Exercise foldr-++ (recommended)}}\label{exercise-foldr--recommended}}

Show that fold and append are related as follows:

\begin{myDisplay}
foldr _⊗_ e (xs ++ ys) ≡ foldr _⊗_ (foldr _⊗_ e ys) xs
\end{myDisplay}

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{exercise-foldr--practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{foldr-∷}
(practice)}{Exercise foldr-∷ (practice)}}\label{exercise-foldr--practice}}

Show

\begin{myDisplay}
foldr _∷_ [] xs ≡ xs
\end{myDisplay}

Show as a consequence of \texttt{foldr-++} above that

\begin{myDisplay}
xs ++ ys ≡ foldr _∷_ ys xs
\end{myDisplay}

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{exercise-map-is-foldr-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{map-is-foldr}
(practice)}{Exercise map-is-foldr (practice)}}\label{exercise-map-is-foldr-practice}}

Show that map can be defined using fold:

\begin{myDisplay}
map f ≡ foldr (λ x xs → f x ∷ xs) []
\end{myDisplay}

The proof requires extensionality.

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{exercise-fold-tree-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{fold-Tree}
(practice)}{Exercise fold-Tree (practice)}}\label{exercise-fold-tree-practice}}

Define a suitable fold function for the type of trees given earlier:

\begin{myDisplay}
fold-Tree : ∀ {A B C : Set} → (A → C) → (C → B → C → C) → Tree A B → C
\end{myDisplay}

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{exercise-map-is-fold-tree-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{map-is-fold-Tree}
(practice)}{Exercise map-is-fold-Tree (practice)}}\label{exercise-map-is-fold-tree-practice}}

Demonstrate an analogue of \texttt{map-is-foldr} for the type of trees.

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{exercise-sum-downfrom-stretch}{%
\subsubsection{\texorpdfstring{Exercise \texttt{sum-downFrom}
(stretch)}{Exercise sum-downFrom (stretch)}}\label{exercise-sum-downfrom-stretch}}

Define a function that counts down as follows:

\begin{fence}
\begin{code}
downFrom : ℕ → List ℕ
downFrom zero     =  []
downFrom (suc n)  =  n ∷ downFrom n
\end{code}
\end{fence}

For example:

\begin{fence}
\begin{code}
_ : downFrom 3 ≡ [ 2 , 1 , 0 ]
_ = refl
\end{code}
\end{fence}

Prove that the sum of the numbers \texttt{(n\ -\ 1)\ +\ ⋯\ +\ 0} is
equal to \texttt{n\ *\ (n\ ∸\ 1)\ /\ 2}:

\begin{myDisplay}
sum (downFrom n) * 2 ≡ n * (n ∸ 1)
\end{myDisplay}

\hypertarget{monoids}{%
\section{Monoids}\label{monoids}}

Typically when we use a fold the operator is associative and the value
is a left and right identity for the operator, meaning that the operator
and the value form a \emph{monoid}.

We can define a monoid as a suitable record type:

\begin{fence}
\begin{code}
record IsMonoid {A : Set} (_⊗_ : A → A → A) (e : A) : Set where
  field
    assoc : ∀ (x y z : A) → (x ⊗ y) ⊗ z ≡ x ⊗ (y ⊗ z)
    identityˡ : ∀ (x : A) → e ⊗ x ≡ x
    identityʳ : ∀ (x : A) → x ⊗ e ≡ x

open IsMonoid
\end{code}
\end{fence}

As examples, sum and zero, multiplication and one, and append and the
empty list, are all examples of monoids:

\begin{fence}
\begin{code}
+-monoid : IsMonoid _+_ 0
+-monoid =
  record
    { assoc = +-assoc
    ; identityˡ = +-identityˡ
    ; identityʳ = +-identityʳ
    }

*-monoid : IsMonoid _*_ 1
*-monoid =
  record
    { assoc = *-assoc
    ; identityˡ = *-identityˡ
    ; identityʳ = *-identityʳ
    }

++-monoid : ∀ {A : Set} → IsMonoid {List A} _++_ []
++-monoid =
  record
    { assoc = ++-assoc
    ; identityˡ = ++-identityˡ
    ; identityʳ = ++-identityʳ
    }
\end{code}
\end{fence}

If \texttt{\_⊗\_} and \texttt{e} form a monoid, then we can re-express
fold on the same operator and an arbitrary value:

\begin{fence}
\begin{code}
foldr-monoid : ∀ {A : Set} (_⊗_ : A → A → A) (e : A) → IsMonoid _⊗_ e →
  ∀ (xs : List A) (y : A) → foldr _⊗_ y xs ≡ foldr _⊗_ e xs ⊗ y
foldr-monoid _⊗_ e ⊗-monoid [] y =
  begin
    foldr _⊗_ y []
  ≡⟨⟩
    y
  ≡⟨ sym (identityˡ ⊗-monoid y) ⟩
    (e ⊗ y)
  ≡⟨⟩
    foldr _⊗_ e [] ⊗ y
  ∎
foldr-monoid _⊗_ e ⊗-monoid (x ∷ xs) y =
  begin
    foldr _⊗_ y (x ∷ xs)
  ≡⟨⟩
    x ⊗ (foldr _⊗_ y xs)
  ≡⟨ cong (x ⊗_) (foldr-monoid _⊗_ e ⊗-monoid xs y) ⟩
    x ⊗ (foldr _⊗_ e xs ⊗ y)
  ≡⟨ sym (assoc ⊗-monoid x (foldr _⊗_ e xs) y) ⟩
    (x ⊗ foldr _⊗_ e xs) ⊗ y
  ≡⟨⟩
    foldr _⊗_ e (x ∷ xs) ⊗ y
  ∎
\end{code}
\end{fence}

In a previous exercise we showed the following.

\begin{fence}
\begin{code}
postulate
  foldr-++ : ∀ {A : Set} (_⊗_ : A → A → A) (e : A) (xs ys : List A) →
    foldr _⊗_ e (xs ++ ys) ≡ foldr _⊗_ (foldr _⊗_ e ys) xs
\end{code}
\end{fence}

As a consequence, using a previous exercise, we have the following:

\begin{fence}
\begin{code}
foldr-monoid-++ : ∀ {A : Set} (_⊗_ : A → A → A) (e : A) → IsMonoid _⊗_ e →
  ∀ (xs ys : List A) → foldr _⊗_ e (xs ++ ys) ≡ foldr _⊗_ e xs ⊗ foldr _⊗_ e ys
foldr-monoid-++ _⊗_ e monoid-⊗ xs ys =
  begin
    foldr _⊗_ e (xs ++ ys)
  ≡⟨ foldr-++ _⊗_ e xs ys ⟩
    foldr _⊗_ (foldr _⊗_ e ys) xs
  ≡⟨ foldr-monoid _⊗_ e monoid-⊗ xs (foldr _⊗_ e ys) ⟩
    foldr _⊗_ e xs ⊗ foldr _⊗_ e ys
  ∎
\end{code}
\end{fence}

\hypertarget{exercise-foldl-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{foldl}
(practice)}{Exercise foldl (practice)}}\label{exercise-foldl-practice}}

Define a function \texttt{foldl} which is analogous to \texttt{foldr},
but where operations associate to the left rather than the right. For
example:

\begin{myDisplay}
foldr _⊗_ e [ x , y , z ]  =  x ⊗ (y ⊗ (z ⊗ e))
foldl _⊗_ e [ x , y , z ]  =  ((e ⊗ x) ⊗ y) ⊗ z
\end{myDisplay}

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{exercise-foldr-monoid-foldl-practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{foldr-monoid-foldl}
(practice)}{Exercise foldr-monoid-foldl (practice)}}\label{exercise-foldr-monoid-foldl-practice}}

Show that if \texttt{\_⊗\_} and \texttt{e} form a monoid, then
\texttt{foldr\ \_⊗\_\ e} and \texttt{foldl\ \_⊗\_\ e} always compute the
same result.

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{Lists-All}{%
\section{All}\label{Lists-All}}

We can also define predicates over lists. Two of the most important are
\texttt{All} and \texttt{Any}.

Predicate \texttt{All\ P} holds if predicate \texttt{P} is satisfied by
every element of a list:

\begin{fence}
\begin{code}
data All {A : Set} (P : A → Set) : List A → Set where
  []  : All P []
  _∷_ : ∀ {x : A} {xs : List A} → P x → All P xs → All P (x ∷ xs)
\end{code}
\end{fence}

The type has two constructors, reusing the names of the same
constructors for lists. The first asserts that \texttt{P} holds for
every element of the empty list. The second asserts that if \texttt{P}
holds of the head of a list and for every element of the tail of a list,
then \texttt{P} holds for every element of the list. Agda uses types to
disambiguate whether the constructor is building a list or evidence that
\texttt{All\ P} holds.

For example, \texttt{All\ (\_≤\ 2)} holds of a list where every element
is less than or equal to two. Recall that \texttt{z≤n} proves
\texttt{zero\ ≤\ n} for any \texttt{n}, and that if \texttt{m≤n} proves
\texttt{m\ ≤\ n} then \texttt{s≤s\ m≤n} proves
\texttt{suc\ m\ ≤\ suc\ n}, for any \texttt{m} and \texttt{n}:

\begin{fence}
\begin{code}
_ : All (_≤ 2) [ 0 , 1 , 2 ]
_ = z≤n ∷ s≤s z≤n ∷ s≤s (s≤s z≤n) ∷ []
\end{code}
\end{fence}

Here \texttt{\_∷\_} and \texttt{{[}{]}} are the constructors of
\texttt{All\ P} rather than of \texttt{List\ A}. The three items are
proofs of \texttt{0\ ≤\ 2}, \texttt{1\ ≤\ 2}, and \texttt{2\ ≤\ 2},
respectively.

(One might wonder whether a pattern such as \texttt{{[}\_,\_,\_{]}} can
be used to construct values of type \texttt{All} as well as type
\texttt{List}, since both use the same constructors. Indeed it can, so
long as both types are in scope when the pattern is declared. That's not
the case here, since \texttt{List} is defined before
\texttt{{[}\_,\_,\_{]}}, but \texttt{All} is defined later.)

\hypertarget{any}{%
\section{Any}\label{any}}

Predicate \texttt{Any\ P} holds if predicate \texttt{P} is satisfied by
some element of a list:

\begin{fence}
\begin{code}
data Any {A : Set} (P : A → Set) : List A → Set where
  here  : ∀ {x : A} {xs : List A} → P x → Any P (x ∷ xs)
  there : ∀ {x : A} {xs : List A} → Any P xs → Any P (x ∷ xs)
\end{code}
\end{fence}

The first constructor provides evidence that the head of the list
satisfies \texttt{P}, while the second provides evidence that some
element of the tail of the list satisfies \texttt{P}. For example, we
can define list membership as follows:

\begin{fence}
\begin{code}
infix 4 _∈_ _∉_

_∈_ : ∀ {A : Set} (x : A) (xs : List A) → Set
x ∈ xs = Any (x ≡_) xs

_∉_ : ∀ {A : Set} (x : A) (xs : List A) → Set
x ∉ xs = ¬ (x ∈ xs)
\end{code}
\end{fence}

For example, zero is an element of the list
\texttt{{[}\ 0\ ,\ 1\ ,\ 0\ ,\ 2\ {]}}. Indeed, we can demonstrate this
fact in two different ways, corresponding to the two different
occurrences of zero in the list, as the first element and as the third
element:

\begin{fence}
\begin{code}
_ : 0 ∈ [ 0 , 1 , 0 , 2 ]
_ = here refl

_ : 0 ∈ [ 0 , 1 , 0 , 2 ]
_ = there (there (here refl))
\end{code}
\end{fence}

Further, we can demonstrate that three is not in the list, because any
possible proof that it is in the list leads to contradiction:

\begin{fence}
\begin{code}
not-in : 3 ∉ [ 0 , 1 , 0 , 2 ]
not-in (here ())
not-in (there (here ()))
not-in (there (there (here ())))
not-in (there (there (there (here ()))))
not-in (there (there (there (there ()))))
\end{code}
\end{fence}

The five occurrences of \texttt{()} attest to the fact that there is no
possible evidence for \texttt{3\ ≡\ 0}, \texttt{3\ ≡\ 1},
\texttt{3\ ≡\ 0}, \texttt{3\ ≡\ 2}, and \texttt{3\ ∈\ {[}{]}},
respectively.

\hypertarget{all-and-append}{%
\section{All and append}\label{all-and-append}}

A predicate holds for every element of one list appended to another if
and only if it holds for every element of both lists:

\begin{fence}
\begin{code}
All-++-⇔ : ∀ {A : Set} {P : A → Set} (xs ys : List A) →
  All P (xs ++ ys) ⇔ (All P xs × All P ys)
All-++-⇔ xs ys =
  record
    { to       =  to xs ys
    ; from     =  from xs ys
    }
  where

  to : ∀ {A : Set} {P : A → Set} (xs ys : List A) →
    All P (xs ++ ys) → (All P xs × All P ys)
  to [] ys Pys = ⟨ [] , Pys ⟩
  to (x ∷ xs) ys (Px ∷ Pxs++ys) with to xs ys Pxs++ys
  ... | ⟨ Pxs , Pys ⟩ = ⟨ Px ∷ Pxs , Pys ⟩

  from : ∀ { A : Set} {P : A → Set} (xs ys : List A) →
    All P xs × All P ys → All P (xs ++ ys)
  from [] ys ⟨ [] , Pys ⟩ = Pys
  from (x ∷ xs) ys ⟨ Px ∷ Pxs , Pys ⟩ =  Px ∷ from xs ys ⟨ Pxs , Pys ⟩
\end{code}
\end{fence}

\hypertarget{exercise-any---recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{Any-++-⇔}
(recommended)}{Exercise Any-++-⇔ (recommended)}}\label{exercise-any---recommended}}

Prove a result similar to \texttt{All-++-⇔}, but with \texttt{Any} in
place of \texttt{All}, and a suitable replacement for \texttt{\_×\_}. As
a consequence, demonstrate an equivalence relating \texttt{\_∈\_} and
\texttt{\_++\_}.

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{exercise-all---stretch}{%
\subsubsection{\texorpdfstring{Exercise \texttt{All-++-≃}
(stretch)}{Exercise All-++-≃ (stretch)}}\label{exercise-all---stretch}}

Show that the equivalence \texttt{All-++-⇔} can be extended to an
isomorphism.

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{exercise-anyall-recommended}{%
\subsubsection{\texorpdfstring{Exercise \texttt{¬Any⇔All¬}
(recommended)}{Exercise ¬Any⇔All¬ (recommended)}}\label{exercise-anyall-recommended}}

Show that \texttt{Any} and \texttt{All} satisfy a version of De Morgan's
Law:

\begin{myDisplay}
(¬_ ∘ Any P) xs ⇔ All (¬_ ∘ P) xs
\end{myDisplay}

(Can you see why it is important that here \texttt{\_∘\_} is generalised
to arbitrary levels, as described in the section on
\protect\hyperlink{Equality-unipoly}{universe polymorphism}?)

Do we also have the following?

\begin{myDisplay}
(¬_ ∘ All P) xs ⇔ Any (¬_ ∘ P) xs
\end{myDisplay}

If so, prove; if not, explain why.

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{exercise-anyall-stretch}{%
\subsubsection{\texorpdfstring{Exercise \texttt{¬Any≃All¬}
(stretch)}{Exercise ¬Any≃All¬ (stretch)}}\label{exercise-anyall-stretch}}

Show that the equivalence \texttt{¬Any⇔All¬} can be extended to an
isomorphism. You will need to use extensionality.

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{exercise-all--practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{All-∀}
(practice)}{Exercise All-∀ (practice)}}\label{exercise-all--practice}}

Show that \texttt{All\ P\ xs} is isomorphic to
\texttt{∀\ \{x\}\ →\ x\ ∈\ xs\ →\ P\ x}.

\begin{fence}
\begin{code}
-- You code goes here
\end{code}
\end{fence}

\hypertarget{exercise-any--practice}{%
\subsubsection{\texorpdfstring{Exercise \texttt{Any-∃}
(practice)}{Exercise Any-∃ (practice)}}\label{exercise-any--practice}}

Show that \texttt{Any\ P\ xs} is isomorphic to
\texttt{∃{[}\ x\ {]}\ (x\ ∈\ xs\ ×\ P\ x)}.

\begin{fence}
\begin{code}
-- You code goes here
\end{code}
\end{fence}

\hypertarget{decidability-of-all}{%
\section{Decidability of All}\label{decidability-of-all}}

If we consider a predicate as a function that yields a boolean, it is
easy to define an analogue of \texttt{All}, which returns true if a
given predicate returns true for every element of a list:

\begin{fence}
\begin{code}
all : ∀ {A : Set} → (A → Bool) → List A → Bool
all p  =  foldr _∧_ true ∘ map p
\end{code}
\end{fence}

The function can be written in a particularly compact style by using the
higher-order functions \texttt{map} and \texttt{foldr}.

As one would hope, if we replace booleans by decidables there is again
an analogue of \texttt{All}. First, return to the notion of a predicate
\texttt{P} as a function of type \texttt{A\ →\ Set}, taking a value
\texttt{x} of type \texttt{A} into evidence \texttt{P\ x} that a
property holds for \texttt{x}. Say that a predicate \texttt{P} is
\emph{decidable} if we have a function that for a given \texttt{x} can
decide \texttt{P\ x}:

\begin{fence}
\begin{code}
Decidable : ∀ {A : Set} → (A → Set) → Set
Decidable {A} P  =  ∀ (x : A) → Dec (P x)
\end{code}
\end{fence}

Then if predicate \texttt{P} is decidable, it is also decidable whether
every element of a list satisfies the predicate:

\begin{fence}
\begin{code}
All? : ∀ {A : Set} {P : A → Set} → Decidable P → Decidable (All P)
All? P? []                                 =  yes []
All? P? (x ∷ xs) with P? x   | All? P? xs
...                 | yes Px | yes Pxs     =  yes (Px ∷ Pxs)
...                 | no ¬Px | _           =  no λ{ (Px ∷ Pxs) → ¬Px Px   }
...                 | _      | no ¬Pxs     =  no λ{ (Px ∷ Pxs) → ¬Pxs Pxs }
\end{code}
\end{fence}

If the list is empty, then trivially \texttt{P} holds for every element
of the list. Otherwise, the structure of the proof is similar to that
showing that the conjunction of two decidable propositions is itself
decidable, using \texttt{\_∷\_} rather than \texttt{⟨\_,\_⟩} to combine
the evidence for the head and tail of the list.

\hypertarget{exercise-any-stretch}{%
\subsubsection{\texorpdfstring{Exercise \texttt{Any?}
(stretch)}{Exercise Any? (stretch)}}\label{exercise-any-stretch}}

Just as \texttt{All} has analogues \texttt{all} and \texttt{All?} which
determine whether a predicate holds for every element of a list, so does
\texttt{Any} have analogues \texttt{any} and \texttt{Any?} which
determine whether a predicate holds for some element of a list. Give
their definitions.

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{exercise-split-stretch}{%
\subsubsection{\texorpdfstring{Exercise \texttt{split}
(stretch)}{Exercise split (stretch)}}\label{exercise-split-stretch}}

The relation \texttt{merge} holds when two lists merge to give a third
list.

\begin{fence}
\begin{code}
data merge {A : Set} : (xs ys zs : List A) → Set where

  [] :
      --------------
      merge [] [] []

  left-∷ : ∀ {x xs ys zs}
    → merge xs ys zs
      --------------------------
    → merge (x ∷ xs) ys (x ∷ zs)

  right-∷ : ∀ {y xs ys zs}
    → merge xs ys zs
      --------------------------
    → merge xs (y ∷ ys) (y ∷ zs)
\end{code}
\end{fence}

For example,

\begin{fence}
\begin{code}
_ : merge [ 1 , 4 ] [ 2 , 3 ] [ 1 , 2 , 3 , 4 ]
_ = left-∷ (right-∷ (right-∷ (left-∷ [])))

\end{code}
\end{fence}

Given a decidable predicate and a list, we can split the list into two
lists that merge to give the original list, where all elements of one
list satisfy the predicate, and all elements of the other do not satisfy
the predicate.

Define the following variant of the traditional \texttt{filter} function
on lists, which given a decidable predicate and a list returns a list of
elements that satisfy the predicate and a list of elements that don't,
with their corresponding proofs.

\begin{myDisplay}
split : ∀ {A : Set} {P : A → Set} (P? : Decidable P) (zs : List A)
  → ∃[ xs ] ∃[ ys ] ( merge xs ys zs × All P xs × All (¬_ ∘ P) ys )
\end{myDisplay}

\begin{fence}
\begin{code}
-- Your code goes here
\end{code}
\end{fence}

\hypertarget{standard-library}{%
\section{Standard Library}\label{standard-library}}

Definitions similar to those in this chapter can be found in the
standard library:

\begin{fence}
\begin{code}
import Data.List using (List; _++_; length; reverse; map; foldr; downFrom)
import Data.List.Relation.Unary.All using (All; []; _∷_)
import Data.List.Relation.Unary.Any using (Any; here; there)
import Data.List.Membership.Propositional using (_∈_)
import Data.List.Properties
  using (reverse-++-commute; map-compose; map-++-commute; foldr-++)
  renaming (mapIsFold to map-is-foldr)
import Algebra.Structures using (IsMonoid)
import Relation.Unary using (Decidable)
import Relation.Binary using (Decidable)
\end{code}
\end{fence}

The standard library version of \texttt{IsMonoid} differs from the one
given here, in that it is also parameterised on an equivalence relation.

Both \texttt{Relation.Unary} and \texttt{Relation.Binary} define a
version of \texttt{Decidable}, one for unary relations (as used in this
chapter where \texttt{P} ranges over unary predicates) and one for
binary relations (as used earlier, where \texttt{\_≤\_} ranges over a
binary relation).

\hypertarget{unicode}{%
\section{Unicode}\label{unicode}}

This chapter uses the following unicode:

\begin{myDisplay}
∷  U+2237  PROPORTION  (\::)
⊗  U+2297  CIRCLED TIMES  (\otimes, \ox)
∈  U+2208  ELEMENT OF  (\in)
∉  U+2209  NOT AN ELEMENT OF  (\inn, \notin)
\end{myDisplay}

